C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE KEYBOARD_CONTROL
OBJECT MODULE PLACED IN .\Objects\keyboard_control.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE keyboard_control.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\keyboard_control.lst) OBJECT(.\Objects\keyboard_control.obj)

line level    source

   1          #include "keyboard_control.h"
   2          #include "relay.h"
   3          #include "flowmeter.h"
   4          #include "i2c.h"  // 添加I2C头文件
   5          
   6          // 定时浇水配置 - 默认值：6:00:01开始，浇100毫升
   7          TimedWatering xdata timed_watering = {0, 6, 0, 1, 100, 0, 0, 0, 0};
   8          
   9          // 手动浇水记录
  10          WateringRecord xdata manual_watering_record;
  11          
  12          // 显示模式：0=时钟，1=自动浇水参数
  13          BYTE auto_display_mode = DISPLAY_MODE_CLOCK;
  14          
  15          // 参数设置模式：0=开始小时，1=开始分钟，2=开始秒，3=浇水毫升数
  16          BYTE param_mode = PARAM_MODE_HOUR;
  17          
  18          // 显示更新标志
  19          bit display_update_flag = 0;
  20          
  21          // 按键状态记录（用于消抖）
  22          static BYTE xdata key_prev_state = 0;
  23          
  24          // 按键延时消抖
  25          static void KeyDelay(void) {
  26   1          BYTE i = 30;
  27   1          while(i--);
  28   1      }
  29          
  30          // 优化：开始手动浇水记录 - 避免传参，直接写死类型
  31          void StartManualWateringRecord(void) {
  32   1          // 记录开始时间 - 直接写死手动类型
  33   1          manual_watering_record.type = WATERING_TYPE_MANUAL;
  34   1          manual_watering_record.start_year = PCA_GetYear();
  35   1          manual_watering_record.start_month = PCA_GetMonth();
  36   1          manual_watering_record.start_day = PCA_GetDay();
  37   1          manual_watering_record.start_hour = PCA_GetHour();
  38   1          manual_watering_record.start_min = PCA_GetMin();
  39   1          manual_watering_record.start_sec = PCA_GetSec();
  40   1          
  41   1          // 记录开始时的累计流量
  42   1          manual_watering_record.total_flow = FlowMeter_GetTotalFlow();
  43   1      }
  44          
  45          // 优化：开始自动浇水记录 - 避免传参，直接写死类型
  46          void StartAutoWateringRecord(void) {
  47   1          // 记录开始时间 - 直接写死自动类型
  48   1          timed_watering.current_record.type = WATERING_TYPE_AUTO;
  49   1          timed_watering.current_record.start_year = PCA_GetYear();
  50   1          timed_watering.current_record.start_month = PCA_GetMonth();
  51   1          timed_watering.current_record.start_day = PCA_GetDay();
  52   1          timed_watering.current_record.start_hour = PCA_GetHour();
  53   1          timed_watering.current_record.start_min = PCA_GetMin();
  54   1          timed_watering.current_record.start_sec = PCA_GetSec();
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 2   

  55   1          
  56   1          // 记录开始时的累计流量
  57   1          timed_watering.start_total_flow = FlowMeter_GetTotalFlow();
  58   1      }
  59          
  60          // 优化：计算手动浇水持续时间 - 内联计算，避免传参
  61          static void CalculateManualDuration(void) {
  62   1          unsigned int start_total_sec, end_total_sec, duration;
  63   1          
  64   1          // 将开始和结束时间转换为总秒数
  65   1          start_total_sec = manual_watering_record.start_hour * 3600 + 
  66   1                           manual_watering_record.start_min * 60 + 
  67   1                           manual_watering_record.start_sec;
  68   1          end_total_sec = manual_watering_record.end_hour * 3600 + 
  69   1                         manual_watering_record.end_min * 60 + 
  70   1                         manual_watering_record.end_sec;
  71   1          
  72   1          // 处理跨日期情况
  73   1          if(end_total_sec < start_total_sec) {
  74   2              end_total_sec += 24 * 3600;  // 加上一天的秒数
  75   2          }
  76   1          
  77   1          duration = end_total_sec - start_total_sec;
  78   1          manual_watering_record.duration_min = duration / 60;
  79   1          manual_watering_record.duration_sec = duration % 60;
  80   1      }
  81          
  82          // 优化：计算自动浇水持续时间 - 内联计算，避免传参
  83          static void CalculateAutoDuration(void) {
  84   1          unsigned int start_total_sec, end_total_sec, duration;
  85   1          
  86   1          // 将开始和结束时间转换为总秒数
  87   1          start_total_sec = timed_watering.current_record.start_hour * 3600 + 
  88   1                           timed_watering.current_record.start_min * 60 + 
  89   1                           timed_watering.current_record.start_sec;
  90   1          end_total_sec = timed_watering.current_record.end_hour * 3600 + 
  91   1                         timed_watering.current_record.end_min * 60 + 
  92   1                         timed_watering.current_record.end_sec;
  93   1          
  94   1          // 处理跨日期情况
  95   1          if(end_total_sec < start_total_sec) {
  96   2              end_total_sec += 24 * 3600;  // 加上一天的秒数
  97   2          }
  98   1          
  99   1          duration = end_total_sec - start_total_sec;
 100   1          timed_watering.current_record.duration_min = duration / 60;
 101   1          timed_watering.current_record.duration_sec = duration % 60;
 102   1      }
 103          
 104          // 优化：结束手动浇水记录 - 避免传参，直接访问全局变量
 105          void EndManualWateringRecord(void) {
 106   1          unsigned long current_total_flow;
 107   1          
 108   1          // 记录结束时间
 109   1          manual_watering_record.end_year = PCA_GetYear();
 110   1          manual_watering_record.end_month = PCA_GetMonth();
 111   1          manual_watering_record.end_day = PCA_GetDay();
 112   1          manual_watering_record.end_hour = PCA_GetHour();
 113   1          manual_watering_record.end_min = PCA_GetMin();
 114   1          manual_watering_record.end_sec = PCA_GetSec();
 115   1          
 116   1          // 计算浇水量和累计流量
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 3   

 117   1          current_total_flow = FlowMeter_GetTotalFlow();
 118   1          manual_watering_record.water_volume = current_total_flow - manual_watering_record.total_flow;
 119   1          manual_watering_record.total_flow = current_total_flow;
 120   1          
 121   1          // 计算持续时间
 122   1          CalculateManualDuration();
 123   1          
 124   1          // 发送浇水记录到串口
 125   1          UART_SendManualWateringRecord();
 126   1      }
 127          
 128          // 优化：结束自动浇水记录 - 避免传参，直接访问全局变量
 129          void EndAutoWateringRecord(void) {
 130   1          unsigned long current_total_flow;
 131   1          
 132   1          // 记录结束时间
 133   1          timed_watering.current_record.end_year = PCA_GetYear();
 134   1          timed_watering.current_record.end_month = PCA_GetMonth();
 135   1          timed_watering.current_record.end_day = PCA_GetDay();
 136   1          timed_watering.current_record.end_hour = PCA_GetHour();
 137   1          timed_watering.current_record.end_min = PCA_GetMin();
 138   1          timed_watering.current_record.end_sec = PCA_GetSec();
 139   1          
 140   1          // 计算浇水量和累计流量
 141   1          current_total_flow = FlowMeter_GetTotalFlow();
 142   1          timed_watering.current_record.water_volume = current_total_flow - timed_watering.start_total_flow;
 143   1          timed_watering.current_record.total_flow = current_total_flow;
 144   1          
 145   1          // 计算持续时间
 146   1          CalculateAutoDuration();
 147   1          
 148   1          // 发送浇水记录到串口
 149   1          UART_SendAutoWateringRecord();
 150   1      }
 151          
 152          // 初始化按键控制
 153          void KeyboardControl_Init(void) {
 154   1          // 设置按键引脚为输入（上拉）
 155   1          P1 |= 0xFC;  // P1.2-P1.7设为高电平（输入模式）
 156   1          
 157   1          // 初始化I2C和24C02
 158   1          I2C_Init();
 159   1          
 160   1          // 初始化定时浇水参数为默认值（不从24C02加载）
 161   1          timed_watering.enabled = 0;
 162   1          timed_watering.start_hour = 6;      // 默认6点
 163   1          timed_watering.start_min = 0;       // 0分
 164   1          timed_watering.start_sec = 1;       // 1秒开始浇水
 165   1          timed_watering.water_volume_ml = 100; // 浇水100毫升
 166   1          timed_watering.is_watering = 0;
 167   1          timed_watering.watering_volume_left = 0;
 168   1          timed_watering.triggered_today = 0;
 169   1          timed_watering.start_total_flow = 0;
 170   1          
 171   1          auto_display_mode = DISPLAY_MODE_CLOCK;
 172   1          param_mode = PARAM_MODE_HOUR;
 173   1      }
 174          
 175          /*
 176           * ========================================
 177           * 定时定量浇花功能详细使用说明
 178           * ========================================
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 4   

 179           * 
 180           * 功能概述：
 181           * 本系统可以设置在指定时间点自动开始浇水，并按设定的毫升数定量浇水。
 182           * 累计流量数据保存在24C02中，掉电不丢失。
 183           * 
 184           * 【第一步：参数设置】
 185           * ==================
 186           * 
 187           * 1. 设置开始浇水时间：
 188           *    操作：按P1.7 (KEY_MODE) 切换到时间设置模式
 189           *    显示：数码管右侧显示模式标识符
 190           *    
 191           *    a) 设置小时：
 192           *       - 数码管显示格式："HH0003" (例如："060003"表示6点)
 193           *       - 按P1.3 (KEY_TIME_UP) 增加小时 (0-23)
 194           *       - 按P1.4 (KEY_TIME_DOWN) 减少小时
 195           *       - 右侧显示"03"表示当前在设置小时
 196           *    
 197           *    b) 设置分钟：
 198           *       - 再按P1.7切换到分钟设置
 199           *       - 数码管显示格式："MM0002" (例如："000002"表示0分)
 200           *       - 按P1.3/P1.4调节分钟数 (0-59)
 201           *       - 右侧显示"02"表示当前在设置分钟
 202           *    
 203           *    c) 设置秒：
 204           *       - 再按P1.7切换到秒设置
 205           *       - 数码管显示格式："SS0001" (例如："010001"表示1秒)
 206           *       - 按P1.3/P1.4调节秒数 (0-59)
 207           *       - 右侧显示"01"表示当前在设置秒
 208           * 
 209           * 2. 设置浇水量：
 210           *    - 再按P1.7切换到毫升设置
 211           *    - 数码管显示格式："MMMM05" (例如："010005"表示100毫升)
 212           *    - 按P1.3 (KEY_TIME_UP) 增加毫升数，每次+50ml
 213           *    - 按P1.4 (KEY_TIME_DOWN) 减少毫升数，每次-50ml
 214           *    - 范围：50-9999毫升
 215           *    - 右侧显示"05"表示当前在设置毫升数
 216           * 
 217           * 【第二步：启动定时浇水】
 218           * ====================
 219           * 
 220           * 操作：按P1.2 (KEY_AUTO) 启动定时浇水功能
 221           * 结果：系统进入定时浇水模式，等待设定时间到达
 222           * 显示：数码管显示当前设置的参数并闪烁
 223           * 
 224           * 【第三步：系统自动运行】
 225           * ====================
 226           * 
 227           * 1. 等待阶段：
 228           *    - 系统持续监控当前时间
 229           *    - 数码管轮流显示设置的参数
 230           *    - 当到达设定时间点时，自动开始浇水
 231           * 
 232           * 2. 浇水阶段：
 233           *    - 继电器自动闭合，开始浇水
 234           *    - 流量计开始计数脉冲
 235           *    - 数码管显示剩余毫升数："XXXX05"
 236           *    - 每个脉冲代表1毫升水流
 237           * 
 238           * 3. 停止阶段：
 239           *    - 当累计流量达到设定毫升数时
 240           *    - 继电器自动断开，停止浇水
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 5   

 241           *    - 标记今天已完成浇水，明天同一时间再次触发
 242           * 
 243           * 【第四步：数据保存】
 244           * ==================
 245           * 
 246           * - 累计流量每10秒自动保存到24C02
 247           * - 断电重启后累计流量数据不丢失
 248           * - 定时设置保存在内存中，断电后需重新设置
 249           * 
 250           * 【使用示例】
 251           * ============
 252           * 
 253           * 目标：设置每天早上6:00:01自动浇水100毫升
 254           * 
 255           * 操作步骤：
 256           * 1. 按P1.7，显示"060003" → 用P1.3/P1.4设置为6点
 257           * 2. 按P1.7，显示"000002" → 用P1.3/P1.4设置为0分
 258           * 3. 按P1.7，显示"010001" → 用P1.3/P1.4设置为1秒
 259           * 4. 按P1.7，显示"010005" → 用P1.3/P1.4设置为100毫升
 260           * 5. 按P1.2启动定时浇水
 261           * 6. 系统将在每天6:00:01自动浇水100毫升
 262           * 
 263           * 【停止定时浇水】
 264           * ==============
 265           * 
 266           * 操作：再次按P1.2 (KEY_AUTO)
 267           * 结果：停止定时浇水功能，返回时钟显示模式
 268           * 
 269           * 【注意事项】
 270           * ============
 271           * 
 272           * 1. 每天只触发一次，避免重复浇水
 273           * 2. 如果当天已经浇过水，不会再次触发
 274           * 3. 过了午夜(00:00:00)会重置触发标志
 275           * 4. 手动浇水不影响定时浇水功能
 276           * 5. 定时浇水进行中时，手动按键无效
 277           */
 278          
 279          // 按键扫描
 280          void KeyboardControl_Scan(void) {
 281   1          BYTE current_keys = 0;
 282   1          BYTE key_pressed;
 283   1          
 284   1          // 读取当前按键状态
 285   1          if(KEY_AUTO == 0) current_keys |= 0x01;
 286   1          if(KEY_TIME_UP == 0) current_keys |= 0x02;
 287   1          if(KEY_TIME_DOWN == 0) current_keys |= 0x04;
 288   1          if(KEY_VOL_UP == 0) current_keys |= 0x08;
 289   1          if(KEY_VOL_DOWN == 0) current_keys |= 0x10;
 290   1          if(KEY_MODE == 0) current_keys |= 0x20;
 291   1          
 292   1          // 检测按键按下（下降沿）
 293   1          key_pressed = (~key_prev_state) & current_keys;
 294   1          
 295   1          if(key_pressed & 0x01) {  // KEY_AUTO按下
 296   2              KeyDelay();
 297   2              if(KEY_AUTO == 0) {
 298   3                  if(timed_watering.enabled) {
 299   4                      TimedWatering_Stop();
 300   4                      auto_display_mode = DISPLAY_MODE_CLOCK;
 301   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 302   4                      display_update_flag = 1;
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 6   

 303   4                  } else {
 304   4                      TimedWatering_Start();
 305   4                  }
 306   3              }
 307   2          }
 308   1          
 309   1          if(key_pressed & 0x20) {  // KEY_MODE按下
 310   2              KeyDelay();
 311   2              if(KEY_MODE == 0) {
 312   3                  param_mode = (param_mode + 1) % 4;  // 4个参数模式
 313   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 314   3                  display_update_flag = 1;
 315   3              }
 316   2          }
 317   1          
 318   1          if(key_pressed & 0x02) {  // KEY_TIME_UP按下
 319   2              KeyDelay();
 320   2              if(KEY_TIME_UP == 0) {
 321   3                  switch(param_mode) {
 322   4                      case PARAM_MODE_HOUR:
 323   4                          timed_watering.start_hour = (timed_watering.start_hour + 1) % 24;
 324   4                          break;
 325   4                      case PARAM_MODE_MIN:
 326   4                          timed_watering.start_min = (timed_watering.start_min + 1) % 60;
 327   4                          break;
 328   4                      case PARAM_MODE_SEC:
 329   4                          timed_watering.start_sec = (timed_watering.start_sec + 1) % 60;
 330   4                          break;
 331   4                      case PARAM_MODE_VOLUME:
 332   4                          if(timed_watering.water_volume_ml < 9950) {
 333   5                              timed_watering.water_volume_ml += 50;
 334   5                          }
 335   4                          break;
 336   4                  }
 337   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 338   3                  display_update_flag = 1;
 339   3              }
 340   2          }
 341   1          
 342   1          if(key_pressed & 0x04) {  // KEY_TIME_DOWN按下
 343   2              KeyDelay();
 344   2              if(KEY_TIME_DOWN == 0) {
 345   3                  switch(param_mode) {
 346   4                      case PARAM_MODE_HOUR:
 347   4                          timed_watering.start_hour = (timed_watering.start_hour == 0) ? 23 : (timed_watering.st
             -art_hour - 1);
 348   4                          break;
 349   4                      case PARAM_MODE_MIN:
 350   4                          timed_watering.start_min = (timed_watering.start_min == 0) ? 59 : (timed_watering.star
             -t_min - 1);
 351   4                          break;
 352   4                      case PARAM_MODE_SEC:
 353   4                          timed_watering.start_sec = (timed_watering.start_sec == 0) ? 59 : (timed_watering.star
             -t_sec - 1);
 354   4                          break;
 355   4                      case PARAM_MODE_VOLUME:
 356   4                          if(timed_watering.water_volume_ml > 50) {
 357   5                              timed_watering.water_volume_ml -= 50;
 358   5                          }
 359   4                          break;
 360   4                  }
 361   3                  auto_display_mode = DISPLAY_MODE_AUTO;
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 7   

 362   3                  display_update_flag = 1;
 363   3              }
 364   2          }
 365   1          
 366   1          key_prev_state = current_keys;
 367   1      }
 368          
 369          // 启动定时浇水
 370          void TimedWatering_Start(void) {
 371   1          timed_watering.enabled = 1;
 372   1          timed_watering.is_watering = 0;
 373   1          timed_watering.triggered_today = 0;  // 重置触发标志
 374   1          
 375   1          // 启动后立即返回时钟显示模式，而不是显示参数
 376   1          auto_display_mode = DISPLAY_MODE_CLOCK;
 377   1          display_update_flag = 1;  // 设置标志立即更新显示
 378   1          
 379   1          // 强制更新时钟显示
 380   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 381   1      }
 382          
 383          // 停止定时浇水
 384          void TimedWatering_Stop(void) {
 385   1          timed_watering.enabled = 0;
 386   1          timed_watering.triggered_today = 0;
 387   1          
 388   1          // 如果正在浇水，立即停止并记录
 389   1          if(timed_watering.is_watering) {
 390   2              timed_watering.is_watering = 0;
 391   2              Relay_Off();
 392   2              FlowMeter_Stop();
 393   2              FlowMeter_SetMode(FLOW_MODE_OFF);
 394   2              
 395   2              // 记录自动浇水结束
 396   2              EndAutoWateringRecord();
 397   2          }
 398   1      }
 399          
 400          // 更新定时浇水状态（每秒调用一次）
 401          void TimedWatering_Update(void) {
 402   1          unsigned long current_total_flow;
 403   1          unsigned long watered_volume;
 404   1          
 405   1          if(!timed_watering.enabled) return;
 406   1          
 407   1          if(timed_watering.is_watering) {
 408   2              // 正在浇水，检查累计流量是否达到目标
 409   2              current_total_flow = FlowMeter_GetTotalFlow();
 410   2              watered_volume = current_total_flow - timed_watering.start_total_flow;
 411   2              
 412   2              if(watered_volume >= timed_watering.water_volume_ml) {
 413   3                  // 达到目标毫升数，停止浇水
 414   3                  timed_watering.is_watering = 0;
 415   3                  timed_watering.triggered_today = 1;  // 标记今天已触发
 416   3                  
 417   3                  Relay_Off();
 418   3                  FlowMeter_Stop();
 419   3                  FlowMeter_SetMode(FLOW_MODE_OFF);
 420   3                  
 421   3                  // 保存累计流量到24C02
 422   3                  AT24C02_WriteTotalFlow(current_total_flow);
 423   3                  
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 8   

 424   3                  // 记录自动浇水结束
 425   3                  EndAutoWateringRecord();
 426   3                  
 427   3                  // 浇水完成后返回时钟显示
 428   3                  auto_display_mode = DISPLAY_MODE_CLOCK;
 429   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 430   3                  display_update_flag = 1;
 431   3              } else {
 432   3                  // 更新剩余毫升数显示
 433   3                  timed_watering.watering_volume_left = timed_watering.water_volume_ml - watered_volume;
 434   3                  if(auto_display_mode != DISPLAY_MODE_AUTO) {
 435   4                      auto_display_mode = DISPLAY_MODE_AUTO;
 436   4                      display_update_flag = 1;
 437   4                  }
 438   3              }
 439   2          } else {
 440   2              // 每天检查是否到达设定时间点
 441   2              if(!timed_watering.triggered_today &&
 442   2                 SysPara1.hour == timed_watering.start_hour &&
 443   2                 SysPara1.min == timed_watering.start_min &&
 444   2                 SysPara1.sec == timed_watering.start_sec) {
 445   3                  
 446   3                  // 开始浇水 - 每天在设定时间自动触发
 447   3                  timed_watering.is_watering = 1;
 448   3                  timed_watering.watering_volume_left = timed_watering.water_volume_ml;
 449   3                  timed_watering.start_total_flow = FlowMeter_GetTotalFlow();
 450   3                  
 451   3                  // 记录自动浇水开始
 452   3                  StartAutoWateringRecord();
 453   3                  
 454   3                  Relay_On();
 455   3                  FlowMeter_Start();
 456   3                  FlowMeter_SetMode(FLOW_MODE_CURR);
 457   3                  
 458   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 459   3                  display_update_flag = 1;
 460   3              }
 461   2              
 462   2              // 午夜重置，确保每天都能触发
 463   2              if(timed_watering.triggered_today && 
 464   2                 SysPara1.hour == 0 && SysPara1.min == 0 && SysPara1.sec == 0) {
 465   3                  timed_watering.triggered_today = 0;  // 重置标志，准备明天的触发
 466   3              }
 467   2          }
 468   1      }
 469          
 470          // 显示自动浇水参数
 471          void DisplayAutoWateringParams(void) {
 472   1          BYTE val1, val2, val3, val4, val5, val6;
 473   1          
 474   1          if(timed_watering.is_watering) {
 475   2              // 显示剩余毫升数
 476   2              val1 = timed_watering.watering_volume_left % 10;
 477   2              val2 = (timed_watering.watering_volume_left / 10) % 10;
 478   2              val3 = (timed_watering.watering_volume_left / 100) % 10;
 479   2              val4 = (timed_watering.watering_volume_left / 1000) % 10;
 480   2              val5 = 0;  // 显示0
 481   2              val6 = 5;  // 显示5（剩余毫升标识）
 482   2          } else {
 483   2              // 显示当前参数
 484   2              switch(param_mode) {
 485   3                  case PARAM_MODE_HOUR:
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 9   

 486   3                      // 显示开始小时 "小时数03"
 487   3                      val1 = timed_watering.start_hour % 10;
 488   3                      val2 = (timed_watering.start_hour / 10) % 10;
 489   3                      val3 = 0;
 490   3                      val4 = 0;
 491   3                      val5 = 0;
 492   3                      val6 = 3;  // 显示3（小时标识）
 493   3                      break;
 494   3                      
 495   3                  case PARAM_MODE_MIN:
 496   3                      // 显示开始分钟 "分钟数02"
 497   3                      val1 = timed_watering.start_min % 10;
 498   3                      val2 = (timed_watering.start_min / 10) % 10;
 499   3                      val3 = 0;
 500   3                      val4 = 0;
 501   3                      val5 = 0;
 502   3                      val6 = 2;  // 显示2（分钟标识）
 503   3                      break;
 504   3                      
 505   3                  case PARAM_MODE_SEC:
 506   3                      // 显示开始秒 "秒数01"
 507   3                      val1 = timed_watering.start_sec % 10;
 508   3                      val2 = (timed_watering.start_sec / 10) % 10;
 509   3                      val3 = 0;
 510   3                      val4 = 0;
 511   3                      val5 = 0;
 512   3                      val6 = 1;  // 显示1（秒标识）
 513   3                      break;
 514   3                      
 515   3                  case PARAM_MODE_VOLUME:
 516   3                      // 显示浇水毫升数 "毫升数05"
 517   3                      val1 = timed_watering.water_volume_ml % 10;
 518   3                      val2 = (timed_watering.water_volume_ml / 10) % 10;
 519   3                      val3 = (timed_watering.water_volume_ml / 100) % 10;
 520   3                      val4 = (timed_watering.water_volume_ml / 1000) % 10;
 521   3                      val5 = 0;
 522   3                      val6 = 5;  // 显示5（毫升标识）
 523   3                      break;
 524   3                      
 525   3                  default:
 526   3                      val1 = val2 = val3 = val4 = val5 = val6 = 0;
 527   3                      break;
 528   3              }
 529   2          }
 530   1          
 531   1          FillCustomDispBuf(val1, val2, val3, val4, val5, val6);
 532   1      }
 533          
 534          // 检查并更新自动显示
 535          void CheckAndUpdateAutoDisplay(void) {
 536   1          if(display_update_flag) {
 537   2              display_update_flag = 0;  // 清除标志
 538   2              
 539   2              if(auto_display_mode == DISPLAY_MODE_AUTO) {
 540   3                  DisplayAutoWateringParams();
 541   3              }
 542   2          }
 543   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1681    ----
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 12:47:23 PAGE 10  

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     65    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
