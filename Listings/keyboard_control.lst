C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/27/2025 19:56:24 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE KEYBOARD_CONTROL
OBJECT MODULE PLACED IN .\Objects\keyboard_control.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE keyboard_control.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\keyboard_control.lst) OBJECT(.\Objects\keyboard_control.obj)

line level    source

   1          #include "keyboard_control.h"
   2          #include "relay.h"
   3          #include "flowmeter.h"
   4          #include "i2c.h"  // 添加I2C头文件
   5          
   6          // 定时浇水配置 - 默认值：6:00:01开始，浇100毫升
   7          TimedWatering xdata timed_watering = {0, 6, 0, 1, 100, 0, 0, 0};
   8          
   9          // 显示模式：0=时钟，1=自动浇水参数
  10          BYTE auto_display_mode = DISPLAY_MODE_CLOCK;
  11          
  12          // 参数设置模式：0=开始小时，1=开始分钟，2=开始秒，3=浇水毫升数
  13          BYTE param_mode = PARAM_MODE_HOUR;  // 修正：使用PARAM_MODE_HOUR而不是PARAM_MODE_INTERVAL
  14          
  15          // 显示更新标志
  16          bit display_update_flag = 0;
  17          
  18          // 按键状态记录（用于消抖）
  19          static BYTE key_prev_state = 0;
  20          
  21          // 按键延时消抖
  22          static void KeyDelay(void) {
  23   1          BYTE i = 30;
  24   1          while(i--);
  25   1      }
  26          
  27          // 初始化按键控制
  28          void KeyboardControl_Init(void) {
  29   1          // 设置按键引脚为输入（上拉）
  30   1          P1 |= 0xFC;  // P1.2-P1.7设为高电平（输入模式）
  31   1          
  32   1          // 初始化I2C和24C02
  33   1          I2C_Init();
  34   1          
  35   1          // 初始化定时浇水参数为默认值（不从24C02加载）
  36   1          timed_watering.enabled = 0;
  37   1          timed_watering.start_hour = 6;      // 默认6点
  38   1          timed_watering.start_min = 0;       // 0分
  39   1          timed_watering.start_sec = 1;       // 1秒开始浇水
  40   1          timed_watering.water_volume_ml = 100; // 浇水100毫升
  41   1          timed_watering.is_watering = 0;
  42   1          timed_watering.watering_volume_left = 0;
  43   1          timed_watering.triggered_today = 0;
  44   1          
  45   1          auto_display_mode = DISPLAY_MODE_CLOCK;
  46   1          param_mode = PARAM_MODE_HOUR;
  47   1      }
  48          
  49          /*
  50           * ========================================
  51           * 定时定量浇花功能详细使用说明
  52           * ========================================
  53           * 
  54           * 功能概述：
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/27/2025 19:56:24 PAGE 2   

  55           * 本系统可以设置在指定时间点自动开始浇水，并按设定的毫升数定量浇水。
  56           * 累计流量数据保存在24C02中，掉电不丢失。
  57           * 
  58           * 【第一步：参数设置】
  59           * ==================
  60           * 
  61           * 1. 设置开始浇水时间：
  62           *    操作：按P1.7 (KEY_MODE) 切换到时间设置模式
  63           *    显示：数码管右侧显示模式标识符
  64           *    
  65           *    a) 设置小时：
  66           *       - 数码管显示格式："HH0003" (例如："060003"表示6点)
  67           *       - 按P1.3 (KEY_TIME_UP) 增加小时 (0-23)
  68           *       - 按P1.4 (KEY_TIME_DOWN) 减少小时
  69           *       - 右侧显示"03"表示当前在设置小时
  70           *    
  71           *    b) 设置分钟：
  72           *       - 再按P1.7切换到分钟设置
  73           *       - 数码管显示格式："MM0002" (例如："000002"表示0分)
  74           *       - 按P1.3/P1.4调节分钟数 (0-59)
  75           *       - 右侧显示"02"表示当前在设置分钟
  76           *    
  77           *    c) 设置秒：
  78           *       - 再按P1.7切换到秒设置
  79           *       - 数码管显示格式："SS0001" (例如："010001"表示1秒)
  80           *       - 按P1.3/P1.4调节秒数 (0-59)
  81           *       - 右侧显示"01"表示当前在设置秒
  82           * 
  83           * 2. 设置浇水量：
  84           *    - 再按P1.7切换到毫升设置
  85           *    - 数码管显示格式："MMMM05" (例如："010005"表示100毫升)
  86           *    - 按P1.3 (KEY_TIME_UP) 增加毫升数，每次+50ml
  87           *    - 按P1.4 (KEY_TIME_DOWN) 减少毫升数，每次-50ml
  88           *    - 范围：50-9999毫升
  89           *    - 右侧显示"05"表示当前在设置毫升数
  90           * 
  91           * 【第二步：启动定时浇水】
  92           * ====================
  93           * 
  94           * 操作：按P1.2 (KEY_AUTO) 启动定时浇水功能
  95           * 结果：系统进入定时浇水模式，等待设定时间到达
  96           * 显示：数码管显示当前设置的参数并闪烁
  97           * 
  98           * 【第三步：系统自动运行】
  99           * ====================
 100           * 
 101           * 1. 等待阶段：
 102           *    - 系统持续监控当前时间
 103           *    - 数码管轮流显示设置的参数
 104           *    - 当到达设定时间点时，自动开始浇水
 105           * 
 106           * 2. 浇水阶段：
 107           *    - 继电器自动闭合，开始浇水
 108           *    - 流量计开始计数脉冲
 109           *    - 数码管显示剩余毫升数："XXXX05"
 110           *    - 每个脉冲代表1毫升水流
 111           * 
 112           * 3. 停止阶段：
 113           *    - 当累计流量达到设定毫升数时
 114           *    - 继电器自动断开，停止浇水
 115           *    - 标记今天已完成浇水，明天同一时间再次触发
 116           * 
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/27/2025 19:56:24 PAGE 3   

 117           * 【第四步：数据保存】
 118           * ==================
 119           * 
 120           * - 累计流量每10秒自动保存到24C02
 121           * - 断电重启后累计流量数据不丢失
 122           * - 定时设置保存在内存中，断电后需重新设置
 123           * 
 124           * 【使用示例】
 125           * ============
 126           * 
 127           * 目标：设置每天早上6:00:01自动浇水100毫升
 128           * 
 129           * 操作步骤：
 130           * 1. 按P1.7，显示"060003" → 用P1.3/P1.4设置为6点
 131           * 2. 按P1.7，显示"000002" → 用P1.3/P1.4设置为0分
 132           * 3. 按P1.7，显示"010001" → 用P1.3/P1.4设置为1秒
 133           * 4. 按P1.7，显示"010005" → 用P1.3/P1.4设置为100毫升
 134           * 5. 按P1.2启动定时浇水
 135           * 6. 系统将在每天6:00:01自动浇水100毫升
 136           * 
 137           * 【停止定时浇水】
 138           * ==============
 139           * 
 140           * 操作：再次按P1.2 (KEY_AUTO)
 141           * 结果：停止定时浇水功能，返回时钟显示模式
 142           * 
 143           * 【注意事项】
 144           * ============
 145           * 
 146           * 1. 每天只触发一次，避免重复浇水
 147           * 2. 如果当天已经浇过水，不会再次触发
 148           * 3. 过了午夜(00:00:00)会重置触发标志
 149           * 4. 手动浇水不影响定时浇水功能
 150           * 5. 定时浇水进行中时，手动按键无效
 151           */
 152          
 153          // 按键扫描
 154          void KeyboardControl_Scan(void) {
 155   1          BYTE current_keys = 0;
 156   1          BYTE key_pressed;
 157   1          
 158   1          // 读取当前按键状态
 159   1          if(KEY_AUTO == 0) current_keys |= 0x01;
 160   1          if(KEY_TIME_UP == 0) current_keys |= 0x02;
 161   1          if(KEY_TIME_DOWN == 0) current_keys |= 0x04;
 162   1          if(KEY_VOL_UP == 0) current_keys |= 0x08;
 163   1          if(KEY_VOL_DOWN == 0) current_keys |= 0x10;
 164   1          if(KEY_MODE == 0) current_keys |= 0x20;
 165   1          
 166   1          // 检测按键按下（下降沿）
 167   1          key_pressed = (~key_prev_state) & current_keys;
 168   1          
 169   1          if(key_pressed & 0x01) {  // KEY_AUTO按下
 170   2              KeyDelay();
 171   2              if(KEY_AUTO == 0) {
 172   3                  if(timed_watering.enabled) {
 173   4                      TimedWatering_Stop();
 174   4                      auto_display_mode = DISPLAY_MODE_CLOCK;
 175   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 176   4                      display_update_flag = 1;
 177   4                  } else {
 178   4                      TimedWatering_Start();
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/27/2025 19:56:24 PAGE 4   

 179   4                  }
 180   3              }
 181   2          }
 182   1          
 183   1          if(key_pressed & 0x20) {  // KEY_MODE按下
 184   2              KeyDelay();
 185   2              if(KEY_MODE == 0) {
 186   3                  param_mode = (param_mode + 1) % 4;  // 4个参数模式
 187   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 188   3                  display_update_flag = 1;
 189   3              }
 190   2          }
 191   1          
 192   1          if(key_pressed & 0x02) {  // KEY_TIME_UP按下
 193   2              KeyDelay();
 194   2              if(KEY_TIME_UP == 0) {
 195   3                  switch(param_mode) {
 196   4                      case PARAM_MODE_HOUR:
 197   4                          timed_watering.start_hour = (timed_watering.start_hour + 1) % 24;
 198   4                          break;
 199   4                      case PARAM_MODE_MIN:
 200   4                          timed_watering.start_min = (timed_watering.start_min + 1) % 60;
 201   4                          break;
 202   4                      case PARAM_MODE_SEC:
 203   4                          timed_watering.start_sec = (timed_watering.start_sec + 1) % 60;
 204   4                          break;
 205   4                      case PARAM_MODE_VOLUME:
 206   4                          if(timed_watering.water_volume_ml < 9950) {
 207   5                              timed_watering.water_volume_ml += 50;
 208   5                          }
 209   4                          break;
 210   4                  }
 211   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 212   3                  display_update_flag = 1;
 213   3              }
 214   2          }
 215   1          
 216   1          if(key_pressed & 0x04) {  // KEY_TIME_DOWN按下
 217   2              KeyDelay();
 218   2              if(KEY_TIME_DOWN == 0) {
 219   3                  switch(param_mode) {
 220   4                      case PARAM_MODE_HOUR:
 221   4                          timed_watering.start_hour = (timed_watering.start_hour == 0) ? 23 : (timed_watering.st
             -art_hour - 1);
 222   4                          break;
 223   4                      case PARAM_MODE_MIN:
 224   4                          timed_watering.start_min = (timed_watering.start_min == 0) ? 59 : (timed_watering.star
             -t_min - 1);
 225   4                          break;
 226   4                      case PARAM_MODE_SEC:
 227   4                          timed_watering.start_sec = (timed_watering.start_sec == 0) ? 59 : (timed_watering.star
             -t_sec - 1);
 228   4                          break;
 229   4                      case PARAM_MODE_VOLUME:
 230   4                          if(timed_watering.water_volume_ml > 50) {
 231   5                              timed_watering.water_volume_ml -= 50;
 232   5                          }
 233   4                          break;
 234   4                  }
 235   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 236   3                  display_update_flag = 1;
 237   3              }
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/27/2025 19:56:24 PAGE 5   

 238   2          }
 239   1          
 240   1          key_prev_state = current_keys;
 241   1      }
 242          
 243          // 启动定时浇水
 244          void TimedWatering_Start(void) {
 245   1          timed_watering.enabled = 1;
 246   1          timed_watering.is_watering = 0;
 247   1          timed_watering.triggered_today = 0;  // 重置触发标志
 248   1          
 249   1          // 启动后立即返回时钟显示模式，而不是显示参数
 250   1          auto_display_mode = DISPLAY_MODE_CLOCK;
 251   1          display_update_flag = 1;  // 设置标志立即更新显示
 252   1          
 253   1          // 强制更新时钟显示
 254   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 255   1      }
 256          
 257          // 停止定时浇水
 258          void TimedWatering_Stop(void) {
 259   1          timed_watering.enabled = 0;
 260   1          timed_watering.triggered_today = 0;
 261   1          
 262   1          // 如果正在浇水，立即停止
 263   1          if(timed_watering.is_watering) {
 264   2              timed_watering.is_watering = 0;
 265   2              Relay_Off();
 266   2              FlowMeter_Stop();
 267   2              FlowMeter_SetMode(FLOW_MODE_OFF);
 268   2          }
 269   1      }
 270          
 271          // 更新定时浇水状态（每秒调用一次）
 272          void TimedWatering_Update(void) {
 273   1          unsigned long current_total_flow;
 274   1          static unsigned long start_total_flow = 0;
 275   1          unsigned long watered_volume;
 276   1          
 277   1          if(!timed_watering.enabled) return;
 278   1          
 279   1          if(timed_watering.is_watering) {
 280   2              // 正在浇水，检查累计流量是否达到目标
 281   2              current_total_flow = FlowMeter_GetTotalFlow();
 282   2              watered_volume = current_total_flow - start_total_flow;
 283   2              
 284   2              if(watered_volume >= timed_watering.water_volume_ml) {
 285   3                  // 达到目标毫升数，停止浇水
 286   3                  timed_watering.is_watering = 0;
 287   3                  timed_watering.triggered_today = 1;  // 标记今天已触发
 288   3                  
 289   3                  Relay_Off();
 290   3                  FlowMeter_Stop();
 291   3                  FlowMeter_SetMode(FLOW_MODE_OFF);
 292   3                  
 293   3                  // 保存累计流量到24C02
 294   3                  AT24C02_WriteTotalFlow(current_total_flow);
 295   3                  
 296   3                  // 浇水完成后返回时钟显示
 297   3                  auto_display_mode = DISPLAY_MODE_CLOCK;
 298   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 299   3                  display_update_flag = 1;
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/27/2025 19:56:24 PAGE 6   

 300   3              } else {
 301   3                  // 更新剩余毫升数显示
 302   3                  timed_watering.watering_volume_left = timed_watering.water_volume_ml - watered_volume;
 303   3                  if(auto_display_mode != DISPLAY_MODE_AUTO) {
 304   4                      auto_display_mode = DISPLAY_MODE_AUTO;
 305   4                      display_update_flag = 1;
 306   4                  }
 307   3              }
 308   2          } else {
 309   2              // 💡 核心逻辑：每天检查是否到达设定时间点
 310   2              if(!timed_watering.triggered_today &&
 311   2                 SysPara1.hour == timed_watering.start_hour &&
 312   2                 SysPara1.min == timed_watering.start_min &&
 313   2                 SysPara1.sec == timed_watering.start_sec) {
 314   3                  
 315   3                  // 开始浇水 - 每天在设定时间自动触发
 316   3                  timed_watering.is_watering = 1;
 317   3                  timed_watering.watering_volume_left = timed_watering.water_volume_ml;
 318   3                  start_total_flow = FlowMeter_GetTotalFlow();
 319   3                  
 320   3                  Relay_On();
 321   3                  FlowMeter_Start();
 322   3                  FlowMeter_SetMode(FLOW_MODE_CURR);
 323   3                  
 324   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 325   3                  display_update_flag = 1;
 326   3              }
 327   2              
 328   2              // 💡 关键机制：午夜重置，确保每天都能触发
 329   2              // 当时钟走到00:00:00时，重置今日触发标志
 330   2              // 这样明天同一时间又可以触发浇水了
 331   2              if(timed_watering.triggered_today && 
 332   2                 SysPara1.hour == 0 && SysPara1.min == 0 && SysPara1.sec == 0) {
 333   3                  timed_watering.triggered_today = 0;  // 重置标志，准备明天的触发
 334   3              }
 335   2          }
 336   1      }
 337          
 338          // 显示自动浇水参数
 339          void DisplayAutoWateringParams(void) {
 340   1          BYTE val1, val2, val3, val4, val5, val6;
 341   1          
 342   1          if(timed_watering.is_watering) {
 343   2              // 显示剩余毫升数
 344   2              val1 = timed_watering.watering_volume_left % 10;
 345   2              val2 = (timed_watering.watering_volume_left / 10) % 10;
 346   2              val3 = (timed_watering.watering_volume_left / 100) % 10;
 347   2              val4 = (timed_watering.watering_volume_left / 1000) % 10;
 348   2              val5 = 0;  // 显示0
 349   2              val6 = 5;  // 显示5（剩余毫升标识）
 350   2          } else {
 351   2              // 移除闪烁显示，直接显示当前参数
 352   2              switch(param_mode) {
 353   3                  case PARAM_MODE_HOUR:
 354   3                      // 显示开始小时 "小时数03"
 355   3                      val1 = timed_watering.start_hour % 10;
 356   3                      val2 = (timed_watering.start_hour / 10) % 10;
 357   3                      val3 = 0;
 358   3                      val4 = 0;
 359   3                      val5 = 0;
 360   3                      val6 = 3;  // 显示3（小时标识）
 361   3                      break;
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/27/2025 19:56:24 PAGE 7   

 362   3                      
 363   3                  case PARAM_MODE_MIN:
 364   3                      // 显示开始分钟 "分钟数02"
 365   3                      val1 = timed_watering.start_min % 10;
 366   3                      val2 = (timed_watering.start_min / 10) % 10;
 367   3                      val3 = 0;
 368   3                      val4 = 0;
 369   3                      val5 = 0;
 370   3                      val6 = 2;  // 显示2（分钟标识）
 371   3                      break;
 372   3                      
 373   3                  case PARAM_MODE_SEC:
 374   3                      // 显示开始秒 "秒数01"
 375   3                      val1 = timed_watering.start_sec % 10;
 376   3                      val2 = (timed_watering.start_sec / 10) % 10;
 377   3                      val3 = 0;
 378   3                      val4 = 0;
 379   3                      val5 = 0;
 380   3                      val6 = 1;  // 显示1（秒标识）
 381   3                      break;
 382   3                      
 383   3                  case PARAM_MODE_VOLUME:
 384   3                      // 显示浇水毫升数 "毫升数05"
 385   3                      val1 = timed_watering.water_volume_ml % 10;
 386   3                      val2 = (timed_watering.water_volume_ml / 10) % 10;
 387   3                      val3 = (timed_watering.water_volume_ml / 100) % 10;
 388   3                      val4 = (timed_watering.water_volume_ml / 1000) % 10;
 389   3                      val5 = 0;
 390   3                      val6 = 5;  // 显示5（毫升标识）
 391   3                      break;
 392   3                      
 393   3                  default:
 394   3                      val1 = val2 = val3 = val4 = val5 = val6 = 0;
 395   3                      break;
 396   3              }
 397   2              
 398   2              // 移除闪烁逻辑，始终显示参数值
 399   2              // if(display_toggle >= 4) {
 400   2              //     val1 = val2 = val3 = val4 = 0;  // 数值部分熄灭
 401   2              // }
 402   2          }
 403   1          
 404   1          FillCustomDispBuf(val1, val2, val3, val4, val5, val6);
 405   1      }
 406          
 407          // 添加缺失的函数：检查并更新自动显示
 408          void CheckAndUpdateAutoDisplay(void) {
 409   1          if(display_update_flag) {
 410   2              display_update_flag = 0;  // 清除标志
 411   2              
 412   2              if(auto_display_mode == DISPLAY_MODE_AUTO) {
 413   3                  DisplayAutoWateringParams();
 414   3              }
 415   2          }
 416   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1017    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/27/2025 19:56:24 PAGE 8   

   DATA SIZE        =      7      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
