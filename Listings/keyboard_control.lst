C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE KEYBOARD_CONTROL
OBJECT MODULE PLACED IN .\Objects\keyboard_control.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE keyboard_control.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\keyboard_control.lst) OBJECT(.\Objects\keyboard_control.obj)

line level    source

   1          #include "keyboard_control.h"
   2          #include "relay.h"
   3          #include "flowmeter.h"
   4          #include "i2c.h"  // æ·»åŠ I2Cå¤´æ–‡ä»¶
   5          
   6          // å®šæ—¶æµ‡æ°´é…ç½® - é»˜è®¤å€¼ï¼š6:00:01å¼€å§‹ï¼Œæµ‡100æ¯«å‡
   7          TimedWatering xdata timed_watering = {0, 6, 0, 1, 100, 0, 0, 0, 0};
   8          
   9          // æ‰‹åŠ¨æµ‡æ°´è®°å½•
  10          WateringRecord xdata manual_watering_record;
  11          
  12          // æ˜¾ç¤ºæ¨¡å¼ï¼š0=æ—¶é’Ÿï¼Œ1=è‡ªåŠ¨æµ‡æ°´å‚æ•°
  13          BYTE auto_display_mode = DISPLAY_MODE_CLOCK;
  14          
  15          // å‚æ•°è®¾ç½®æ¨¡å¼ï¼š0=å¼€å§‹å°æ—¶ï¼Œ1=å¼€å§‹åˆ†é’Ÿï¼Œ2=å¼€å§‹ç§’ï¼Œ3=æµ‡æ°´æ¯«å‡æ•°
  16          BYTE param_mode = PARAM_MODE_HOUR;
  17          
  18          // æ˜¾ç¤ºæ›´æ–°æ ‡å¿—
  19          bit display_update_flag = 0;
  20          
  21          // æŒ‰é”®çŠ¶æ€è®°å½•ï¼ˆç”¨äºæ¶ˆæŠ–ï¼‰
  22          static BYTE xdata key_prev_state = 0;
  23          
  24          // æŒ‰é”®å»¶æ—¶æ¶ˆæŠ–
  25          static void KeyDelay(void) {
  26   1          BYTE i = 30;
  27   1          while(i--);
  28   1      }
  29          
  30          // ä¼˜åŒ–ï¼šå¼€å§‹æ‰‹åŠ¨æµ‡æ°´è®°å½• - é¿å…ä¼ å‚ï¼Œç›´æ¥å†™æ­»ç±»å‹
  31          void StartManualWateringRecord(void) {
  32   1          // è®°å½•å¼€å§‹æ—¶é—´ - ç›´æ¥å†™æ­»æ‰‹åŠ¨ç±»å‹
  33   1          manual_watering_record.type = WATERING_TYPE_MANUAL;
  34   1          manual_watering_record.start_year = PCA_GetYear();
  35   1          manual_watering_record.start_month = PCA_GetMonth();
  36   1          manual_watering_record.start_day = PCA_GetDay();
  37   1          manual_watering_record.start_hour = PCA_GetHour();
  38   1          manual_watering_record.start_min = PCA_GetMin();
  39   1          manual_watering_record.start_sec = PCA_GetSec();
  40   1          
  41   1          // è®°å½•å¼€å§‹æ—¶çš„ç´¯è®¡æµé‡
  42   1          manual_watering_record.total_flow = FlowMeter_GetTotalFlow();
  43   1      }
  44          
  45          // ä¼˜åŒ–ï¼šå¼€å§‹è‡ªåŠ¨æµ‡æ°´è®°å½• - é¿å…ä¼ å‚ï¼Œç›´æ¥å†™æ­»ç±»å‹
  46          void StartAutoWateringRecord(void) {
  47   1          // è®°å½•å¼€å§‹æ—¶é—´ - ç›´æ¥å†™æ­»è‡ªåŠ¨ç±»å‹
  48   1          timed_watering.current_record.type = WATERING_TYPE_AUTO;
  49   1          timed_watering.current_record.start_year = PCA_GetYear();
  50   1          timed_watering.current_record.start_month = PCA_GetMonth();
  51   1          timed_watering.current_record.start_day = PCA_GetDay();
  52   1          timed_watering.current_record.start_hour = PCA_GetHour();
  53   1          timed_watering.current_record.start_min = PCA_GetMin();
  54   1          timed_watering.current_record.start_sec = PCA_GetSec();
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 2   

  55   1          
  56   1          // è®°å½•å¼€å§‹æ—¶çš„ç´¯è®¡æµé‡
  57   1          timed_watering.start_total_flow = FlowMeter_GetTotalFlow();
  58   1      }
  59          
  60          // ä¼˜åŒ–ï¼šè®¡ç®—æ‰‹åŠ¨æµ‡æ°´æŒç»­æ—¶é—´ - å†…è”è®¡ç®—ï¼Œé¿å…ä¼ å‚
  61          static void CalculateManualDuration(void) {
  62   1          unsigned int start_total_sec, end_total_sec, duration;
  63   1          
  64   1          // å°†å¼€å§‹å’Œç»“æŸæ—¶é—´è½¬æ¢ä¸ºæ€»ç§’æ•°
  65   1          start_total_sec = manual_watering_record.start_hour * 3600 + 
  66   1                           manual_watering_record.start_min * 60 + 
  67   1                           manual_watering_record.start_sec;
  68   1          end_total_sec = manual_watering_record.end_hour * 3600 + 
  69   1                         manual_watering_record.end_min * 60 + 
  70   1                         manual_watering_record.end_sec;
  71   1          
  72   1          // å¤„ç†è·¨æ—¥æœŸæƒ…å†µ
  73   1          if(end_total_sec < start_total_sec) {
  74   2              end_total_sec += 24 * 3600;  // åŠ ä¸Šä¸€å¤©çš„ç§’æ•°
  75   2          }
  76   1          
  77   1          duration = end_total_sec - start_total_sec;
  78   1          manual_watering_record.duration_min = duration / 60;
  79   1          manual_watering_record.duration_sec = duration % 60;
  80   1      }
  81          
  82          // ä¼˜åŒ–ï¼šè®¡ç®—è‡ªåŠ¨æµ‡æ°´æŒç»­æ—¶é—´ - å†…è”è®¡ç®—ï¼Œé¿å…ä¼ å‚
  83          static void CalculateAutoDuration(void) {
  84   1          unsigned int start_total_sec, end_total_sec, duration;
  85   1          
  86   1          // å°†å¼€å§‹å’Œç»“æŸæ—¶é—´è½¬æ¢ä¸ºæ€»ç§’æ•°
  87   1          start_total_sec = timed_watering.current_record.start_hour * 3600 + 
  88   1                           timed_watering.current_record.start_min * 60 + 
  89   1                           timed_watering.current_record.start_sec;
  90   1          end_total_sec = timed_watering.current_record.end_hour * 3600 + 
  91   1                         timed_watering.current_record.end_min * 60 + 
  92   1                         timed_watering.current_record.end_sec;
  93   1          
  94   1          // å¤„ç†è·¨æ—¥æœŸæƒ…å†µ
  95   1          if(end_total_sec < start_total_sec) {
  96   2              end_total_sec += 24 * 3600;  // åŠ ä¸Šä¸€å¤©çš„ç§’æ•°
  97   2          }
  98   1          
  99   1          duration = end_total_sec - start_total_sec;
 100   1          timed_watering.current_record.duration_min = duration / 60;
 101   1          timed_watering.current_record.duration_sec = duration % 60;
 102   1      }
 103          
 104          // ä¼˜åŒ–ï¼šç»“æŸæ‰‹åŠ¨æµ‡æ°´è®°å½• - é¿å…ä¼ å‚ï¼Œç›´æ¥è®¿é—®å…¨å±€å˜é‡
 105          void EndManualWateringRecord(void) {
 106   1          unsigned long current_total_flow;
 107   1          
 108   1          // è®°å½•ç»“æŸæ—¶é—´
 109   1          manual_watering_record.end_year = PCA_GetYear();
 110   1          manual_watering_record.end_month = PCA_GetMonth();
 111   1          manual_watering_record.end_day = PCA_GetDay();
 112   1          manual_watering_record.end_hour = PCA_GetHour();
 113   1          manual_watering_record.end_min = PCA_GetMin();
 114   1          manual_watering_record.end_sec = PCA_GetSec();
 115   1          
 116   1          // è®¡ç®—æµ‡æ°´é‡å’Œç´¯è®¡æµé‡
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 3   

 117   1          current_total_flow = FlowMeter_GetTotalFlow();
 118   1          manual_watering_record.water_volume = current_total_flow - manual_watering_record.total_flow;
 119   1          manual_watering_record.total_flow = current_total_flow;
 120   1          
 121   1          // è®¡ç®—æŒç»­æ—¶é—´
 122   1          CalculateManualDuration();
 123   1          
 124   1          // å‘é€æµ‡æ°´è®°å½•åˆ°ä¸²å£
 125   1          UART_SendManualWateringRecord();
 126   1      }
 127          
 128          // ä¼˜åŒ–ï¼šç»“æŸè‡ªåŠ¨æµ‡æ°´è®°å½• - é¿å…ä¼ å‚ï¼Œç›´æ¥è®¿é—®å…¨å±€å˜é‡
 129          void EndAutoWateringRecord(void) {
 130   1          unsigned long current_total_flow;
 131   1          
 132   1          // è®°å½•ç»“æŸæ—¶é—´
 133   1          timed_watering.current_record.end_year = PCA_GetYear();
 134   1          timed_watering.current_record.end_month = PCA_GetMonth();
 135   1          timed_watering.current_record.end_day = PCA_GetDay();
 136   1          timed_watering.current_record.end_hour = PCA_GetHour();
 137   1          timed_watering.current_record.end_min = PCA_GetMin();
 138   1          timed_watering.current_record.end_sec = PCA_GetSec();
 139   1          
 140   1          // è®¡ç®—æµ‡æ°´é‡å’Œç´¯è®¡æµé‡
 141   1          current_total_flow = FlowMeter_GetTotalFlow();
 142   1          timed_watering.current_record.water_volume = current_total_flow - timed_watering.start_total_flow;
 143   1          timed_watering.current_record.total_flow = current_total_flow;
 144   1          
 145   1          // è®¡ç®—æŒç»­æ—¶é—´
 146   1          CalculateAutoDuration();
 147   1          
 148   1          // å‘é€æµ‡æ°´è®°å½•åˆ°ä¸²å£
 149   1          UART_SendAutoWateringRecord();
 150   1      }
 151          
 152          // åˆå§‹åŒ–æŒ‰é”®æ§åˆ¶
 153          void KeyboardControl_Init(void) {
 154   1          // è®¾ç½®æŒ‰é”®å¼•è„šä¸ºè¾“å…¥ï¼ˆä¸Šæ‹‰ï¼‰
 155   1          P1 |= 0xFC;  // P1.2-P1.7è®¾ä¸ºé«˜ç”µå¹³ï¼ˆè¾“å…¥æ¨¡å¼ï¼‰
 156   1          
 157   1          // åˆå§‹åŒ–I2Cå’Œ24C02
 158   1          I2C_Init();
 159   1          
 160   1          // åˆå§‹åŒ–å®šæ—¶æµ‡æ°´å‚æ•°ä¸ºé»˜è®¤å€¼ï¼ˆä¸ä»24C02åŠ è½½ï¼‰
 161   1          timed_watering.enabled = 0;
 162   1          timed_watering.start_hour = 6;      // é»˜è®¤6ç‚¹
 163   1          timed_watering.start_min = 0;       // 0åˆ†
 164   1          timed_watering.start_sec = 1;       // 1ç§’å¼€å§‹æµ‡æ°´
 165   1          timed_watering.water_volume_ml = 100; // æµ‡æ°´100æ¯«å‡
 166   1          timed_watering.is_watering = 0;
 167   1          timed_watering.watering_volume_left = 0;
 168   1          timed_watering.triggered_today = 0;
 169   1          timed_watering.start_total_flow = 0;
 170   1          
 171   1          auto_display_mode = DISPLAY_MODE_CLOCK;
 172   1          param_mode = PARAM_MODE_HOUR;
 173   1      }
 174          
 175          /*
 176           * ========================================
 177           * å®šæ—¶å®šé‡æµ‡èŠ±åŠŸèƒ½è¯¦ç»†ä½¿ç”¨è¯´æ˜
 178           * ========================================
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 4   

 179           * 
 180           * åŠŸèƒ½æ¦‚è¿°ï¼š
 181           * æœ¬ç³»ç»Ÿå¯ä»¥è®¾ç½®åœ¨æŒ‡å®šæ—¶é—´ç‚¹è‡ªåŠ¨å¼€å§‹æµ‡æ°´ï¼Œå¹¶æŒ‰è®¾å®šçš„æ¯«å‡æ•°å®šé‡æµ‡æ°´ã€‚
 182           * ç´¯è®¡æµé‡æ•°æ®ä¿å­˜åœ¨24C02ä¸­ï¼Œæ‰ç”µä¸ä¸¢å¤±ã€‚
 183           * 
 184           * ã€ç¬¬ä¸€æ­¥ï¼šå‚æ•°è®¾ç½®ã€‘
 185           * ==================
 186           * 
 187           * 1. è®¾ç½®å¼€å§‹æµ‡æ°´æ—¶é—´ï¼š
 188           *    æ“ä½œï¼šæŒ‰P1.7 (KEY_MODE) åˆ‡æ¢åˆ°æ—¶é—´è®¾ç½®æ¨¡å¼
 189           *    æ˜¾ç¤ºï¼šæ•°ç ç®¡å³ä¾§æ˜¾ç¤ºæ¨¡å¼æ ‡è¯†ç¬¦
 190           *    
 191           *    a) è®¾ç½®å°æ—¶ï¼š
 192           *       - æ•°ç ç®¡æ˜¾ç¤ºæ ¼å¼ï¼š"HH0003" (ä¾‹å¦‚ï¼š"060003"è¡¨ç¤º6ç‚¹)
 193           *       - æŒ‰P1.3 (KEY_TIME_UP) å¢åŠ å°æ—¶ (0-23)
 194           *       - æŒ‰P1.4 (KEY_TIME_DOWN) å‡å°‘å°æ—¶
 195           *       - å³ä¾§æ˜¾ç¤º"03"è¡¨ç¤ºå½“å‰åœ¨è®¾ç½®å°æ—¶
 196           *    
 197           *    b) è®¾ç½®åˆ†é’Ÿï¼š
 198           *       - å†æŒ‰P1.7åˆ‡æ¢åˆ°åˆ†é’Ÿè®¾ç½®
 199           *       - æ•°ç ç®¡æ˜¾ç¤ºæ ¼å¼ï¼š"MM0002" (ä¾‹å¦‚ï¼š"000002"è¡¨ç¤º0åˆ†)
 200           *       - æŒ‰P1.3/P1.4è°ƒèŠ‚åˆ†é’Ÿæ•° (0-59)
 201           *       - å³ä¾§æ˜¾ç¤º"02"è¡¨ç¤ºå½“å‰åœ¨è®¾ç½®åˆ†é’Ÿ
 202           *    
 203           *    c) è®¾ç½®ç§’ï¼š
 204           *       - å†æŒ‰P1.7åˆ‡æ¢åˆ°ç§’è®¾ç½®
 205           *       - æ•°ç ç®¡æ˜¾ç¤ºæ ¼å¼ï¼š"SS0001" (ä¾‹å¦‚ï¼š"010001"è¡¨ç¤º1ç§’)
 206           *       - æŒ‰P1.3/P1.4è°ƒèŠ‚ç§’æ•° (0-59)
 207           *       - å³ä¾§æ˜¾ç¤º"01"è¡¨ç¤ºå½“å‰åœ¨è®¾ç½®ç§’
 208           * 
 209           * 2. è®¾ç½®æµ‡æ°´é‡ï¼š
 210           *    - å†æŒ‰P1.7åˆ‡æ¢åˆ°æ¯«å‡è®¾ç½®
 211           *    - æ•°ç ç®¡æ˜¾ç¤ºæ ¼å¼ï¼š"MMMM05" (ä¾‹å¦‚ï¼š"010005"è¡¨ç¤º100æ¯«å‡)
 212           *    - æŒ‰P1.3 (KEY_TIME_UP) å¢åŠ æ¯«å‡æ•°ï¼Œæ¯æ¬¡+50ml
 213           *    - æŒ‰P1.4 (KEY_TIME_DOWN) å‡å°‘æ¯«å‡æ•°ï¼Œæ¯æ¬¡-50ml
 214           *    - èŒƒå›´ï¼š50-9999æ¯«å‡
 215           *    - å³ä¾§æ˜¾ç¤º"05"è¡¨ç¤ºå½“å‰åœ¨è®¾ç½®æ¯«å‡æ•°
 216           * 
 217           * ã€ç¬¬äºŒæ­¥ï¼šå¯åŠ¨å®šæ—¶æµ‡æ°´ã€‘
 218           * ====================
 219           * 
 220           * æ“ä½œï¼šæŒ‰P1.2 (KEY_AUTO) å¯åŠ¨å®šæ—¶æµ‡æ°´åŠŸèƒ½
 221           * ç»“æœï¼šç³»ç»Ÿè¿›å…¥å®šæ—¶æµ‡æ°´æ¨¡å¼ï¼Œç­‰å¾…è®¾å®šæ—¶é—´åˆ°è¾¾
 222           * æ˜¾ç¤ºï¼šæ•°ç ç®¡æ˜¾ç¤ºå½“å‰è®¾ç½®çš„å‚æ•°å¹¶é—ªçƒ
 223           * 
 224           * ã€ç¬¬ä¸‰æ­¥ï¼šç³»ç»Ÿè‡ªåŠ¨è¿è¡Œã€‘
 225           * ====================
 226           * 
 227           * 1. ç­‰å¾…é˜¶æ®µï¼š
 228           *    - ç³»ç»ŸæŒç»­ç›‘æ§å½“å‰æ—¶é—´
 229           *    - æ•°ç ç®¡è½®æµæ˜¾ç¤ºè®¾ç½®çš„å‚æ•°
 230           *    - å½“åˆ°è¾¾è®¾å®šæ—¶é—´ç‚¹æ—¶ï¼Œè‡ªåŠ¨å¼€å§‹æµ‡æ°´
 231           * 
 232           * 2. æµ‡æ°´é˜¶æ®µï¼š
 233           *    - ç»§ç”µå™¨è‡ªåŠ¨é—­åˆï¼Œå¼€å§‹æµ‡æ°´
 234           *    - æµé‡è®¡å¼€å§‹è®¡æ•°è„‰å†²
 235           *    - æ•°ç ç®¡æ˜¾ç¤ºå‰©ä½™æ¯«å‡æ•°ï¼š"XXXX05"
 236           *    - æ¯ä¸ªè„‰å†²ä»£è¡¨1æ¯«å‡æ°´æµ
 237           * 
 238           * 3. åœæ­¢é˜¶æ®µï¼š
 239           *    - å½“ç´¯è®¡æµé‡è¾¾åˆ°è®¾å®šæ¯«å‡æ•°æ—¶
 240           *    - ç»§ç”µå™¨è‡ªåŠ¨æ–­å¼€ï¼Œåœæ­¢æµ‡æ°´
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 5   

 241           *    - æ ‡è®°ä»Šå¤©å·²å®Œæˆæµ‡æ°´ï¼Œæ˜å¤©åŒä¸€æ—¶é—´å†æ¬¡è§¦å‘
 242           * 
 243           * ã€ç¬¬å››æ­¥ï¼šæ•°æ®ä¿å­˜ã€‘
 244           * ==================
 245           * 
 246           * - ç´¯è®¡æµé‡æ¯10ç§’è‡ªåŠ¨ä¿å­˜åˆ°24C02
 247           * - æ–­ç”µé‡å¯åç´¯è®¡æµé‡æ•°æ®ä¸ä¸¢å¤±
 248           * - å®šæ—¶è®¾ç½®ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œæ–­ç”µåéœ€é‡æ–°è®¾ç½®
 249           * 
 250           * ã€ä½¿ç”¨ç¤ºä¾‹ã€‘
 251           * ============
 252           * 
 253           * ç›®æ ‡ï¼šè®¾ç½®æ¯å¤©æ—©ä¸Š6:00:01è‡ªåŠ¨æµ‡æ°´100æ¯«å‡
 254           * 
 255           * æ“ä½œæ­¥éª¤ï¼š
 256           * 1. æŒ‰P1.7ï¼Œæ˜¾ç¤º"060003" â†’ ç”¨P1.3/P1.4è®¾ç½®ä¸º6ç‚¹
 257           * 2. æŒ‰P1.7ï¼Œæ˜¾ç¤º"000002" â†’ ç”¨P1.3/P1.4è®¾ç½®ä¸º0åˆ†
 258           * 3. æŒ‰P1.7ï¼Œæ˜¾ç¤º"010001" â†’ ç”¨P1.3/P1.4è®¾ç½®ä¸º1ç§’
 259           * 4. æŒ‰P1.7ï¼Œæ˜¾ç¤º"010005" â†’ ç”¨P1.3/P1.4è®¾ç½®ä¸º100æ¯«å‡
 260           * 5. æŒ‰P1.2å¯åŠ¨å®šæ—¶æµ‡æ°´
 261           * 6. ç³»ç»Ÿå°†åœ¨æ¯å¤©6:00:01è‡ªåŠ¨æµ‡æ°´100æ¯«å‡
 262           * 
 263           * ã€åœæ­¢å®šæ—¶æµ‡æ°´ã€‘
 264           * ==============
 265           * 
 266           * æ“ä½œï¼šå†æ¬¡æŒ‰P1.2 (KEY_AUTO)
 267           * ç»“æœï¼šåœæ­¢å®šæ—¶æµ‡æ°´åŠŸèƒ½ï¼Œè¿”å›æ—¶é’Ÿæ˜¾ç¤ºæ¨¡å¼
 268           * 
 269           * ã€æ³¨æ„äº‹é¡¹ã€‘
 270           * ============
 271           * 
 272           * 1. æ¯å¤©åªè§¦å‘ä¸€æ¬¡ï¼Œé¿å…é‡å¤æµ‡æ°´
 273           * 2. å¦‚æœå½“å¤©å·²ç»æµ‡è¿‡æ°´ï¼Œä¸ä¼šå†æ¬¡è§¦å‘
 274           * 3. è¿‡äº†åˆå¤œ(00:00:00)ä¼šé‡ç½®è§¦å‘æ ‡å¿—
 275           * 4. æ‰‹åŠ¨æµ‡æ°´ä¸å½±å“å®šæ—¶æµ‡æ°´åŠŸèƒ½
 276           * 5. å®šæ—¶æµ‡æ°´è¿›è¡Œä¸­æ—¶ï¼Œæ‰‹åŠ¨æŒ‰é”®æ— æ•ˆ
 277           */
 278          
 279          // æŒ‰é”®æ‰«æ
 280          void KeyboardControl_Scan(void) {
 281   1          BYTE current_keys = 0;
 282   1          BYTE key_pressed;
 283   1          
 284   1          // è¯»å–å½“å‰æŒ‰é”®çŠ¶æ€
 285   1          if(KEY_AUTO == 0) current_keys |= 0x01;
 286   1          if(KEY_TIME_UP == 0) current_keys |= 0x02;
 287   1          if(KEY_TIME_DOWN == 0) current_keys |= 0x04;
 288   1          if(KEY_VOL_UP == 0) current_keys |= 0x08;
 289   1          if(KEY_VOL_DOWN == 0) current_keys |= 0x10;
 290   1          if(KEY_MODE == 0) current_keys |= 0x20;
 291   1          
 292   1          // æ£€æµ‹æŒ‰é”®æŒ‰ä¸‹ï¼ˆä¸‹é™æ²¿ï¼‰
 293   1          key_pressed = (~key_prev_state) & current_keys;
 294   1          
 295   1          if(key_pressed & 0x01) {  // KEY_AUTOæŒ‰ä¸‹
 296   2              KeyDelay();
 297   2              if(KEY_AUTO == 0) {
 298   3                  if(timed_watering.enabled) {
 299   4                      TimedWatering_Stop();
 300   4                      auto_display_mode = DISPLAY_MODE_CLOCK;
 301   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 302   4                      display_update_flag = 1;
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 6   

 303   4                  } else {
 304   4                      TimedWatering_Start();
 305   4                  }
 306   3              }
 307   2          }
 308   1          
 309   1          if(key_pressed & 0x20) {  // KEY_MODEæŒ‰ä¸‹
 310   2              KeyDelay();
 311   2              if(KEY_MODE == 0) {
 312   3                  param_mode = (param_mode + 1) % 4;  // 4ä¸ªå‚æ•°æ¨¡å¼
 313   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 314   3                  display_update_flag = 1;
 315   3              }
 316   2          }
 317   1          
 318   1          if(key_pressed & 0x02) {  // KEY_TIME_UPæŒ‰ä¸‹
 319   2              KeyDelay();
 320   2              if(KEY_TIME_UP == 0) {
 321   3                  switch(param_mode) {
 322   4                      case PARAM_MODE_HOUR:
 323   4                          timed_watering.start_hour = (timed_watering.start_hour + 1) % 24;
 324   4                          break;
 325   4                      case PARAM_MODE_MIN:
 326   4                          timed_watering.start_min = (timed_watering.start_min + 1) % 60;
 327   4                          break;
 328   4                      case PARAM_MODE_SEC:
 329   4                          timed_watering.start_sec = (timed_watering.start_sec + 1) % 60;
 330   4                          break;
 331   4                      case PARAM_MODE_VOLUME:
 332   4                          if(timed_watering.water_volume_ml < 9950) {
 333   5                              timed_watering.water_volume_ml += 50;
 334   5                          }
 335   4                          break;
 336   4                  }
 337   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 338   3                  display_update_flag = 1;
 339   3              }
 340   2          }
 341   1          
 342   1          if(key_pressed & 0x04) {  // KEY_TIME_DOWNæŒ‰ä¸‹
 343   2              KeyDelay();
 344   2              if(KEY_TIME_DOWN == 0) {
 345   3                  switch(param_mode) {
 346   4                      case PARAM_MODE_HOUR:
 347   4                          timed_watering.start_hour = (timed_watering.start_hour == 0) ? 23 : (timed_watering.st
             -art_hour - 1);
 348   4                          break;
 349   4                      case PARAM_MODE_MIN:
 350   4                          timed_watering.start_min = (timed_watering.start_min == 0) ? 59 : (timed_watering.star
             -t_min - 1);
 351   4                          break;
 352   4                      case PARAM_MODE_SEC:
 353   4                          timed_watering.start_sec = (timed_watering.start_sec == 0) ? 59 : (timed_watering.star
             -t_sec - 1);
 354   4                          break;
 355   4                      case PARAM_MODE_VOLUME:
 356   4                          if(timed_watering.water_volume_ml > 50) {
 357   5                              timed_watering.water_volume_ml -= 50;
 358   5                          }
 359   4                          break;
 360   4                  }
 361   3                  auto_display_mode = DISPLAY_MODE_AUTO;
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 7   

 362   3                  display_update_flag = 1;
 363   3              }
 364   2          }
 365   1          
 366   1          key_prev_state = current_keys;
 367   1      }
 368          
 369          // å¯åŠ¨å®šæ—¶æµ‡æ°´
 370          void TimedWatering_Start(void) {
 371   1          timed_watering.enabled = 1;
 372   1          timed_watering.is_watering = 0;
 373   1          timed_watering.triggered_today = 0;  // é‡ç½®è§¦å‘æ ‡å¿—
 374   1          
 375   1          // å¯åŠ¨åç«‹å³è¿”å›æ—¶é’Ÿæ˜¾ç¤ºæ¨¡å¼ï¼Œè€Œä¸æ˜¯æ˜¾ç¤ºå‚æ•°
 376   1          auto_display_mode = DISPLAY_MODE_CLOCK;
 377   1          display_update_flag = 1;  // è®¾ç½®æ ‡å¿—ç«‹å³æ›´æ–°æ˜¾ç¤º
 378   1          
 379   1          // å¼ºåˆ¶æ›´æ–°æ—¶é’Ÿæ˜¾ç¤º
 380   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 381   1      }
 382          
 383          // åœæ­¢å®šæ—¶æµ‡æ°´
 384          void TimedWatering_Stop(void) {
 385   1          timed_watering.enabled = 0;
 386   1          timed_watering.triggered_today = 0;
 387   1          
 388   1          // å¦‚æœæ­£åœ¨æµ‡æ°´ï¼Œç«‹å³åœæ­¢å¹¶è®°å½•
 389   1          if(timed_watering.is_watering) {
 390   2              timed_watering.is_watering = 0;
 391   2              Relay_Off();
 392   2              FlowMeter_Stop();
 393   2              FlowMeter_SetMode(FLOW_MODE_OFF);
 394   2              
 395   2              // è®°å½•è‡ªåŠ¨æµ‡æ°´ç»“æŸ
 396   2              EndAutoWateringRecord();
 397   2          }
 398   1      }
 399          
 400          // æ›´æ–°å®šæ—¶æµ‡æ°´çŠ¶æ€ï¼ˆæ¯ç§’è°ƒç”¨ä¸€æ¬¡ï¼‰
 401          void TimedWatering_Update(void) {
 402   1          unsigned long current_total_flow;
 403   1          unsigned long watered_volume;
 404   1          
 405   1          if(!timed_watering.enabled) return;
 406   1          
 407   1          if(timed_watering.is_watering) {
 408   2              // æ­£åœ¨æµ‡æ°´ï¼Œæ£€æŸ¥ç´¯è®¡æµé‡æ˜¯å¦è¾¾åˆ°ç›®æ ‡
 409   2              current_total_flow = FlowMeter_GetTotalFlow();
 410   2              watered_volume = current_total_flow - timed_watering.start_total_flow;
 411   2              
 412   2              if(watered_volume >= timed_watering.water_volume_ml) {
 413   3                  // è¾¾åˆ°ç›®æ ‡æ¯«å‡æ•°ï¼Œåœæ­¢æµ‡æ°´
 414   3                  timed_watering.is_watering = 0;
 415   3                  timed_watering.triggered_today = 1;  // æ ‡è®°ä»Šå¤©å·²è§¦å‘
 416   3                  
 417   3                  Relay_Off();
 418   3                  FlowMeter_Stop();
 419   3                  FlowMeter_SetMode(FLOW_MODE_OFF);
 420   3                  
 421   3                  // ä¿å­˜ç´¯è®¡æµé‡åˆ°24C02
 422   3                  AT24C02_WriteTotalFlow(current_total_flow);
 423   3                  
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 8   

 424   3                  // è®°å½•è‡ªåŠ¨æµ‡æ°´ç»“æŸ
 425   3                  EndAutoWateringRecord();
 426   3                  
 427   3                  // æµ‡æ°´å®Œæˆåè¿”å›æ—¶é’Ÿæ˜¾ç¤º
 428   3                  auto_display_mode = DISPLAY_MODE_CLOCK;
 429   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 430   3                  display_update_flag = 1;
 431   3              } else {
 432   3                  // æ›´æ–°å‰©ä½™æ¯«å‡æ•°æ˜¾ç¤º
 433   3                  timed_watering.watering_volume_left = timed_watering.water_volume_ml - watered_volume;
 434   3                  if(auto_display_mode != DISPLAY_MODE_AUTO) {
 435   4                      auto_display_mode = DISPLAY_MODE_AUTO;
 436   4                      display_update_flag = 1;
 437   4                  }
 438   3              }
 439   2          } else {
 440   2              // æ¯å¤©æ£€æŸ¥æ˜¯å¦åˆ°è¾¾è®¾å®šæ—¶é—´ç‚¹
 441   2              if(!timed_watering.triggered_today &&
 442   2                 SysPara1.hour == timed_watering.start_hour &&
 443   2                 SysPara1.min == timed_watering.start_min &&
 444   2                 SysPara1.sec == timed_watering.start_sec) {
 445   3                  
 446   3                  // å¼€å§‹æµ‡æ°´ - æ¯å¤©åœ¨è®¾å®šæ—¶é—´è‡ªåŠ¨è§¦å‘
 447   3                  timed_watering.is_watering = 1;
 448   3                  timed_watering.watering_volume_left = timed_watering.water_volume_ml;
 449   3                  timed_watering.start_total_flow = FlowMeter_GetTotalFlow();
 450   3                  
 451   3                  // è®°å½•è‡ªåŠ¨æµ‡æ°´å¼€å§‹
 452   3                  StartAutoWateringRecord();
 453   3                  
 454   3                  Relay_On();
 455   3                  FlowMeter_Start();
 456   3                  FlowMeter_SetMode(FLOW_MODE_CURR);
 457   3                  
 458   3                  auto_display_mode = DISPLAY_MODE_AUTO;
 459   3                  display_update_flag = 1;
 460   3              }
 461   2              
 462   2              // åˆå¤œé‡ç½®ï¼Œç¡®ä¿æ¯å¤©éƒ½èƒ½è§¦å‘
 463   2              if(timed_watering.triggered_today && 
 464   2                 SysPara1.hour == 0 && SysPara1.min == 0 && SysPara1.sec == 0) {
 465   3                  timed_watering.triggered_today = 0;  // é‡ç½®æ ‡å¿—ï¼Œå‡†å¤‡æ˜å¤©çš„è§¦å‘
 466   3              }
 467   2          }
 468   1      }
 469          
 470          // æ˜¾ç¤ºè‡ªåŠ¨æµ‡æ°´å‚æ•° - æ‰©å±•åˆ°8ä½æ•°ç ç®¡
 471          void DisplayAutoWateringParams(void) {
 472   1          BYTE val1, val2, val3, val4, val5, val6, val7, val8;
 473   1          
 474   1          if(timed_watering.is_watering) {
 475   2              // æ˜¾ç¤ºå‰©ä½™æ¯«å‡æ•° - æ ¼å¼ï¼šXXXXXXXdï¼ˆå‰7ä½å‰©ä½™é‡ï¼Œæœ€å1ä½æ ‡è¯†dï¼‰
 476   2              unsigned int remaining = timed_watering.watering_volume_left;
 477   2              val1 = 12;  // æ¨¡å¼æ ‡è¯†æ”¹ä¸º "d" (ä½¿ç”¨LEDæ•°ç»„ç´¢å¼•12)
 478   2              val2 = remaining % 10;
 479   2              val3 = (remaining / 10) % 10;
 480   2              val4 = (remaining / 100) % 10;
 481   2              val5 = (remaining / 1000) % 10;
 482   2              val6 = (remaining / 10000) % 10;
 483   2              val7 = 0;  // åä¸‡ä½é€šå¸¸ä¸º0
 484   2              val8 = 0;  // ç™¾ä¸‡ä½é€šå¸¸ä¸º0
 485   2          } else {
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 9   

 486   2              // æ˜¾ç¤ºå½“å‰å‚æ•°è®¾ç½®
 487   2              switch(param_mode) {
 488   3                  case PARAM_MODE_HOUR:
 489   3                      // æ˜¾ç¤ºå¼€å§‹å°æ—¶ - æ ¼å¼ï¼š000000Hcï¼ˆå‰6ä½å¡«é›¶ï¼ŒHä¸ºå°æ—¶å€¼ï¼Œæœ€å1ä½æ ‡è
             -¯†cï¼‰
 490   3                      val1 = 15;  // æ¨¡å¼æ ‡è¯†æ”¹ä¸º "c" (ä½¿ç”¨LEDæ•°ç»„ç´¢å¼•15)
 491   3                      val2 = timed_watering.start_hour % 10;           // å°æ—¶ä¸ªä½
 492   3                      val3 = (timed_watering.start_hour / 10) % 10;    // å°æ—¶åä½
 493   3                      val4 = val5 = val6 = val7 = val8 = 0;           // å…¶ä½™ä½å¡«é›¶
 494   3                      break;
 495   3                      
 496   3                  case PARAM_MODE_MIN:
 497   3                      // æ˜¾ç¤ºå¼€å§‹åˆ†é’Ÿ - æ ¼å¼ï¼š000000MBï¼ˆå‰6ä½å¡«é›¶ï¼ŒMä¸ºåˆ†é’Ÿå€¼ï¼Œæœ€å1ä½æ ‡è
             -¯†Bï¼‰
 498   3                      val1 = 14;  // æ¨¡å¼æ ‡è¯†æ”¹ä¸º "B" (ä½¿ç”¨LEDæ•°ç»„ç´¢å¼•14)
 499   3                      val2 = timed_watering.start_min % 10;           // åˆ†é’Ÿä¸ªä½
 500   3                      val3 = (timed_watering.start_min / 10) % 10;    // åˆ†é’Ÿåä½
 501   3                      val4 = val5 = val6 = val7 = val8 = 0;          // å…¶ä½™ä½å¡«é›¶
 502   3                      break;
 503   3                      
 504   3                  case PARAM_MODE_SEC:
 505   3                      // æ˜¾ç¤ºå¼€å§‹ç§’ - æ ¼å¼ï¼š000000SAï¼ˆå‰6ä½å¡«é›¶ï¼ŒSä¸ºç§’å€¼ï¼Œæœ€å1ä½æ ‡è¯†Aï¼‰
 506   3                      val1 = 13;  // æ¨¡å¼æ ‡è¯†æ”¹ä¸º "A" (ä½¿ç”¨LEDæ•°ç»„ç´¢å¼•13)
 507   3                      val2 = timed_watering.start_sec % 10;           // ç§’ä¸ªä½
 508   3                      val3 = (timed_watering.start_sec / 10) % 10;    // ç§’åä½
 509   3                      val4 = val5 = val6 = val7 = val8 = 0;          // å…¶ä½™ä½å¡«é›¶
 510   3                      break;
 511   3                      
 512   3                  case PARAM_MODE_VOLUME:
 513   3                      {  // æ·»åŠ å¤§æ‹¬å·åˆ›å»ºæ–°ä½œç”¨åŸŸ
 514   4                          // æ˜¾ç¤ºæµ‡æ°´æ¯«å‡æ•° - æ ¼å¼ï¼šXXXXXXXdï¼ˆå‰7ä½æ¯«å‡æ•°ï¼Œæœ€å1ä½æ ‡è¯†dï¼‰
 515   4                          unsigned int volume = timed_watering.water_volume_ml;
 516   4                          val1 = 12;  // æ¨¡å¼æ ‡è¯†æ”¹ä¸º "d" (ä½¿ç”¨LEDæ•°ç»„ç´¢å¼•12)
 517   4                          val2 = volume % 10;
 518   4                          val3 = (volume / 10) % 10;
 519   4                          val4 = (volume / 100) % 10;
 520   4                          val5 = (volume / 1000) % 10;
 521   4                          val6 = (volume / 10000) % 10;
 522   4                          val7 = 0;  // åä¸‡ä½é€šå¸¸ä¸º0
 523   4                          val8 = 0;  // ç™¾ä¸‡ä½é€šå¸¸ä¸º0
 524   4                      }  // ç»“æŸå¤§æ‹¬å·
 525   3                      break;
 526   3                      
 527   3                  default:
 528   3                      val1 = val2 = val3 = val4 = val5 = val6 = val7 = val8 = 0;
 529   3                      break;
 530   3              }
 531   2          }
 532   1          
 533   1          // ä½¿ç”¨8ä½æ˜¾ç¤ºç¼“å†²åŒº
 534   1          FillCustomDispBuf8(val1, val2, val3, val4, val5, val6, val7, val8);
 535   1      }
 536          
 537          // æ£€æŸ¥å¹¶æ›´æ–°è‡ªåŠ¨æ˜¾ç¤º
 538          void CheckAndUpdateAutoDisplay(void) {
 539   1          if(display_update_flag) {
 540   2              display_update_flag = 0;  // æ¸…é™¤æ ‡å¿—
 541   2              
 542   2              if(auto_display_mode == DISPLAY_MODE_AUTO) {
 543   3                  DisplayAutoWateringParams();
 544   3              }
 545   2          }
C51 COMPILER V9.54   KEYBOARD_CONTROL                                                      05/28/2025 16:35:39 PAGE 10  

 546   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1618    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     65    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      28
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
