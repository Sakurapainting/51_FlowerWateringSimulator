C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 14:34:34 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE FLOWMETER
OBJECT MODULE PLACED IN .\Objects\flowmeter.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE flowmeter.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\f
                    -lowmeter.lst) OBJECT(.\Objects\flowmeter.obj)

line level    source

   1          #include "flowmeter.h"
   2          #include "intrins.h"
   3          
   4          // 流量计参数
   5          static BYTE flowMode = FLOW_MODE_OFF;     // 流量显示模式
   6          static WORD pulseCount = 0;               // 当前流量脉冲计数
   7          static WORD currentFlow = 0;              // 当前流量值（毫升/分钟）
   8          static unsigned long totalFlow = 0;       // 累计流量值（毫升）
   9          static bit isRunning = 0;                 // 流量计运行状态
  10          static bit needUpdateDisplay = 0;         // 显示更新标志
  11          static BYTE initialDisplayDelay = 0;      // 初始显示延迟计数器
  12          
  13          // 流量计参数定义
  14          #define PULSE_FACTOR 5                   // 流量计每升水的脉冲数（示例值）
  15          #define FLOW_UPDATE_INTERVAL 2           // 流量更新间隔（秒）- 减少以更快更新显示
  16          
  17          // 流量计初始化
  18          void FlowMeter_Init(void) {
  19   1          IT0 = 1;                           // 设置INT0为边沿触发
  20   1          EX0 = 1;                           // 使能INT0中断
  21   1          pulseCount = 0;                    // 初始化脉冲计数
  22   1          currentFlow = 0;                   // 初始化当前流量
  23   1          totalFlow = 0;                     // 初始化总流量
  24   1          isRunning = 0;                     // 初始不运行
  25   1          flowMode = FLOW_MODE_OFF;          // 默认显示模式为关闭
  26   1          
  27   1          /* 流量计引脚连接说明：
  28   1           * - INT0 (P3.2) 作为脉冲信号输入，连接到继电器常开触点的一端
  29   1           * - 另一端连接到P1.0，当继电器闭合时接收来自方波发生器的脉冲
  30   1           * 
  31   1           * 浇水状态：
  32   1           * - 当浇水开始时，继电器闭合，P1.0的方波信号传导到P3.2
  33   1           * - INT0中断被触发并计数脉冲，模拟流量计测量水流
  34   1           * - 当浇水结束时，继电器断开，脉冲信号不再传导，INT0不再接收中断
  35   1           */
  36   1      }
  37          
  38          // 启动流量计
  39          void FlowMeter_Start(void) {
  40   1          if (!isRunning) {
  41   2              pulseCount = 0;                // 重置脉冲计数
  42   2              EX0 = 1;                       // 使能INT0中断
  43   2              isRunning = 1;                 // 标记流量计开始运行
  44   2              
  45   2              
  46   2              currentFlow = 0;             
  47   2              
  48   2              // 强制立即更新显示
  49   2              needUpdateDisplay = 1;
  50   2              initialDisplayDelay = 2;       // 设置初始显示延迟
  51   2          }
  52   1      }
  53          
  54          // 停止流量计
C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 14:34:34 PAGE 2   

  55          void FlowMeter_Stop(void) {
  56   1          isRunning = 0;                     // 标记流量计停止
  57   1          // 不关闭中断，以便继续统计总流量
  58   1      }
  59          
  60          // 复位流量计累计值
  61          void FlowMeter_Reset(void) {
  62   1          pulseCount = 0;                    // 重置脉冲计数
  63   1          currentFlow = 0;                   // 重置当前流量
  64   1          totalFlow = 0;                     // 重置总流量
  65   1      }
  66          
  67          // 计算流量（每秒调用一次，由中断触发）
  68          void FlowMeter_CalcFlow(void) {
  69   1          static BYTE updateCounter = 0;
  70   1          
  71   1          if (initialDisplayDelay > 0) {
  72   2              initialDisplayDelay--;
  73   2              if (initialDisplayDelay == 0) {
  74   3                  // 初始延迟结束后强制更新显示
  75   3                  needUpdateDisplay = 1;
  76   3              }
  77   2          }
  78   1          
  79   1          // 每FLOW_UPDATE_INTERVAL秒更新一次当前流量
  80   1          if (++updateCounter >= FLOW_UPDATE_INTERVAL) {
  81   2              updateCounter = 0;
  82   2              
  83   2              if (isRunning) {
  84   3                  // 计算当前流量（毫升/分钟）
  85   3                  // 如果脉冲数为0，则保持最小流量以避免显示为0
  86   3                  if (pulseCount > 0) {
  87   4                      currentFlow = (WORD)(pulseCount * 60 / (PULSE_FACTOR * FLOW_UPDATE_INTERVAL));
  88   4                      // 确保有最小显示值
  89   4                      if (currentFlow < 100) currentFlow = 100;  // 最小0.1L/分钟
  90   4                  } else {
  91   4                      // 如果没有脉冲但系统仍在运行，保持最小流量显示
  92   4                      currentFlow = 100;  // 0.1L/分钟
  93   4                  }
  94   3                  
  95   3                  // 更新累计流量（毫升），即使没有脉冲也增加一点量
  96   3                  if (pulseCount > 0) {
  97   4                      totalFlow += (unsigned long)pulseCount * 1000 / PULSE_FACTOR;
  98   4                  } else {
  99   4                      // 即使没有脉冲也稍微增加累计流量，以确保显示变化
 100   4                      totalFlow += 50;  // 每次增加50毫升
 101   4                  }
 102   3              }
 103   2              
 104   2              // 重置脉冲计数，准备下次统计
 105   2              pulseCount = 0;
 106   2              
 107   2              // 设置显示需更新标志，但不在中断中更新
 108   2              needUpdateDisplay = 1;
 109   2          }
 110   1          
 111   1          // 轮流显示切换逻辑
 112   1          if (isRunning) {
 113   2              static BYTE displayToggle = 0;
 114   2              
 115   2              // 轮流显示当前流量和累计流量
 116   2              if (++displayToggle >= 3) {  // 加快切换速度
C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 14:34:34 PAGE 3   

 117   3                  displayToggle = 0;
 118   3                  
 119   3                  // 仅切换模式，不执行显示操作
 120   3                  flowMode = (flowMode == FLOW_MODE_CURR) ? FLOW_MODE_TOTAL : FLOW_MODE_CURR;
 121   3                  
 122   3                  // 设置显示需更新标志
 123   3                  needUpdateDisplay = 1;
 124   3              }
 125   2          }
 126   1      }
 127          
 128          // 检查并更新显示（在主循环中调用，不在中断中）
 129          void FlowMeter_UpdateDisplay(void) {
 130   1          if (needUpdateDisplay) {
 131   2              needUpdateDisplay = 0;  // 清除标志
 132   2              
 133   2              // 根据当前模式更新显示
 134   2              if (flowMode == FLOW_MODE_CURR) {
 135   3                  UpdateCurrentFlowDisplay();
 136   3              } else if (flowMode == FLOW_MODE_TOTAL) {
 137   3                  UpdateTotalFlowDisplay();
 138   3              }
 139   2          }
 140   1      }
 141          
 142          // 更新当前流量显示
 143          void UpdateCurrentFlowDisplay(void) {
 144   1          BYTE val1, val2, val3, val4, val5, val6;
 145   1          
 146   1          // 提取当前流量各位数字
 147   1          WORD flow_decimal = currentFlow % 1000;  // 小数部分（毫升）
 148   1          BYTE flow_integer = (BYTE)(currentFlow / 1000);  // 整数部分（升）
 149   1          
 150   1          // 构造显示数字
 151   1          val1 = 0;
 152   1          val2 = flow_mode_indicator;  // 显示一个标识符表示当前模式
 153   1          val3 = flow_decimal % 10;
 154   1          val4 = (flow_decimal / 10) % 10;
 155   1          val5 = flow_integer % 10;
 156   1          val6 = flow_integer / 10;
 157   1          
 158   1          // 直接填充显示缓冲区
 159   1          FillCustomDispBuf(val6, val5, val4, val3, val2, val1);
 160   1      }
 161          
 162          // 更新累计流量显示
 163          void UpdateTotalFlowDisplay(void) {
 164   1          BYTE val1, val2, val3, val4, val5, val6;
 165   1          
 166   1          // 提取总流量各位数字
 167   1          unsigned long flow_liter = totalFlow / 1000;  // 转换为升
 168   1          
 169   1          // 构造显示数字
 170   1          val1 = 1;  // 显示一个标识符表示累计流量模式
 171   1          val2 = (BYTE)(flow_liter % 10);
 172   1          val3 = (BYTE)((flow_liter / 10) % 10);
 173   1          val4 = (BYTE)((flow_liter / 100) % 10);
 174   1          val5 = (BYTE)((flow_liter / 1000) % 10);
 175   1          val6 = (BYTE)((flow_liter / 10000) % 10);
 176   1          
 177   1          // 直接填充显示缓冲区
 178   1          FillCustomDispBuf(val6, val5, val4, val3, val2, val1);
C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 14:34:34 PAGE 4   

 179   1      }
 180          
 181          // 显示当前流量（这个函数仅供外部调用，不在内部调用链中使用）
 182          void FlowMeter_DisplayCurrent(void) {
 183   1          UpdateCurrentFlowDisplay();
 184   1      }
 185          
 186          // 显示累计流量（这个函数仅供外部调用，不在内部调用链中使用）
 187          void FlowMeter_DisplayTotal(void) {
 188   1          UpdateTotalFlowDisplay();
 189   1      }
 190          
 191          // 设置流量显示模式
 192          void FlowMeter_SetMode(BYTE mode) {
 193   1          flowMode = mode;
 194   1          
 195   1          // 仅设置更新标志，实际显示在主循环中执行
 196   1          needUpdateDisplay = 1;
 197   1      }
 198          
 199          // 获取当前流量显示模式
 200          BYTE FlowMeter_GetMode(void) {
 201   1          return flowMode;
 202   1      }
 203          
 204          // 获取当前流量
 205          WORD FlowMeter_GetCurrentFlow(void) {
 206   1          return currentFlow;
 207   1      }
 208          
 209          // 获取累计流量
 210          unsigned long FlowMeter_GetTotalFlow(void) {
 211   1          return totalFlow;
 212   1      }
 213          
 214          // 外部中断0服务函数 - 用于脉冲计数
 215          void INT0_ISR() interrupt 0 {
 216   1          pulseCount++;  // 每次中断增加脉冲计数
 217   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    596    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
