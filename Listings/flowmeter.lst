C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 17:00:45 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE FLOWMETER
OBJECT MODULE PLACED IN .\Objects\flowmeter.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE flowmeter.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\f
                    -lowmeter.lst) OBJECT(.\Objects\flowmeter.obj)

line level    source

   1          #include "flowmeter.h"
   2          #include "intrins.h"
   3          
   4          // æµé‡è®¡å‚æ•°
   5          static BYTE flowMode = FLOW_MODE_OFF;     // æµé‡æ˜¾ç¤ºæ¨¡å¼
   6          static WORD pulseCount = 0;               // å½“å‰æµé‡è„‰å†²è®¡æ•°
   7          static WORD currentFlow = 0;              // å½“å‰æµé‡å€¼ï¼ˆæ¯«å‡/ç§’ï¼‰- ä¿®æ”¹å•ä½ä¸ºæ¯«å‡/ç§’
   8          static unsigned long totalFlow = 0;       // ç´¯è®¡æµé‡å€¼ï¼ˆæ¯«å‡ï¼‰
   9          static bit isRunning = 0;                 // æµé‡è®¡è¿è¡ŒçŠ¶æ€
  10          static bit needUpdateDisplay = 0;         // æ˜¾ç¤ºæ›´æ–°æ ‡å¿—
  11          static BYTE initialDisplayDelay = 0;      // åˆå§‹æ˜¾ç¤ºå»¶è¿Ÿè®¡æ•°å™¨
  12          
  13          // æµé‡è®¡å‚æ•°å®šä¹‰
  14          #define PULSE_FACTOR 1                   // é™ä½è„‰å†²å› å­ï¼Œä½¿æ¯ä¸ªè„‰å†²ä»£è¡¨æ›´å¤šæ°´é‡ï¼ˆåŸä¸
             -º5ï¼‰
  15          #define FLOW_UPDATE_INTERVAL 1           // æ›´å¿«åœ°æ›´æ–°æµé‡å€¼ï¼ˆæ¯ç§’æ›´æ–°ï¼‰
  16          #define FLOW_SPEED_MULTIPLIER 1          // æµé‡å€å¢å› å­
*** WARNING C317 IN LINE 16 OF flowmeter.c: attempt to redefine macro 'FLOW_SPEED_MULTIPLIER'
  17          
  18          // æµé‡è®¡åˆå§‹åŒ–
  19          void FlowMeter_Init(void) {
  20   1          IT0 = 1;                           // è®¾ç½®INT0ä¸ºè¾¹æ²¿è§¦å‘
  21   1          EX0 = 1;                           // ä½¿èƒ½INT0ä¸­æ–­
  22   1          pulseCount = 0;                    // åˆå§‹åŒ–è„‰å†²è®¡æ•°
  23   1          currentFlow = 0;                   // åˆå§‹åŒ–å½“å‰æµé‡
  24   1          totalFlow = 0;                     // åˆå§‹åŒ–æ€»æµé‡
  25   1          isRunning = 0;                     // åˆå§‹ä¸è¿è¡Œ
  26   1          flowMode = FLOW_MODE_OFF;          // é»˜è®¤æ˜¾ç¤ºæ¨¡å¼ä¸ºå…³é—­
  27   1          
  28   1          /* æµé‡è®¡å¼•è„šè¿æ¥è¯´æ˜ï¼š
  29   1           * - INT0 (P3.2) ä½œä¸ºè„‰å†²ä¿¡å·è¾“å…¥ï¼Œè¿æ¥åˆ°ç»§ç”µå™¨å¸¸å¼€è§¦ç‚¹çš„ä¸€ç«¯
  30   1           * - å¦ä¸€ç«¯è¿æ¥åˆ°P1.0ï¼Œå½“ç»§ç”µå™¨é—­åˆæ—¶æ¥æ”¶æ¥è‡ªæ–¹æ³¢å‘ç”Ÿå™¨çš„è„‰å†²
  31   1           * 
  32   1           * æµ‡æ°´çŠ¶æ€ï¼š
  33   1           * - å½“æµ‡æ°´å¼€å§‹æ—¶ï¼Œç»§ç”µå™¨é—­åˆï¼ŒP1.0çš„æ–¹æ³¢ä¿¡å·ä¼ å¯¼åˆ°P3.2
  34   1           * - INT0ä¸­æ–­è¢«è§¦å‘å¹¶è®¡æ•°è„‰å†²ï¼Œæ¨¡æ‹Ÿæµé‡è®¡æµ‹é‡æ°´æµ
  35   1           * - å½“æµ‡æ°´ç»“æŸæ—¶ï¼Œç»§ç”µå™¨æ–­å¼€ï¼Œè„‰å†²ä¿¡å·ä¸å†ä¼ å¯¼ï¼ŒINT0ä¸å†æ¥æ”¶ä¸­æ–­
  36   1           */
  37   1      }
  38          
  39          // å¯åŠ¨æµé‡è®¡
  40          void FlowMeter_Start(void) {
  41   1          if (!isRunning) {
  42   2              pulseCount = 0;                // é‡ç½®è„‰å†²è®¡æ•°
  43   2              EX0 = 1;                       // ä½¿èƒ½INT0ä¸­æ–­
  44   2              isRunning = 1;                 // æ ‡è®°æµé‡è®¡å¼€å§‹è¿è¡Œ
  45   2              
  46   2              // è®¾ç½®åˆå§‹éé›¶æµé‡å€¼
  47   2              currentFlow = 0; 
  48   2              
  49   2              // å¼ºåˆ¶ç«‹å³æ›´æ–°æ˜¾ç¤º
  50   2              needUpdateDisplay = 1;
  51   2              initialDisplayDelay = 2;       // è®¾ç½®åˆå§‹æ˜¾ç¤ºå»¶è¿Ÿ
  52   2          }
C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 17:00:45 PAGE 2   

  53   1      }
  54          
  55          // åœæ­¢æµé‡è®¡
  56          void FlowMeter_Stop(void) {
  57   1          isRunning = 0;                     // æ ‡è®°æµé‡è®¡åœæ­¢
  58   1          // ä¸å…³é—­ä¸­æ–­ï¼Œä»¥ä¾¿ç»§ç»­ç»Ÿè®¡æ€»æµé‡
  59   1      }
  60          
  61          // å¤ä½æµé‡è®¡ç´¯è®¡å€¼
  62          void FlowMeter_Reset(void) {
  63   1          pulseCount = 0;                    // é‡ç½®è„‰å†²è®¡æ•°
  64   1          currentFlow = 0;                   // é‡ç½®å½“å‰æµé‡
  65   1          totalFlow = 0;                     // é‡ç½®æ€»æµé‡
  66   1      }
  67          
  68          /*
  69           * æ•°ç ç®¡æ˜¾ç¤ºè¯´æ˜ï¼š
  70           * æµ‡æ°´è¿‡ç¨‹ä¸­æ•°ç ç®¡ä¼šè½®æµæ˜¾ç¤ºä¸¤ç§æ¨¡å¼ï¼šå½“å‰æµé‡å’Œç´¯è®¡æµé‡
  71           * 
  72           * 1. å½“å‰æµé‡æ˜¾ç¤ºæ¨¡å¼ï¼ˆFLOW_MODE_CURRï¼‰:
  73           *    - æ•°ç ç®¡ä»å³åˆ°å·¦ä¾æ¬¡ä¸ºï¼šä½1-ä½6
  74           *    - ä½1: ä¸æ˜¾ç¤º
  75           *    - ä½2: æ˜¾ç¤ºæ•°å­—"5"ï¼Œè¡¨ç¤ºå½“å‰ä¸ºæµé‡æ˜¾ç¤ºæ¨¡å¼
  76           *    - ä½3: ä¸æ˜¾ç¤º
  77           *    - ä½4-ä½6: æ˜¾ç¤ºå½“å‰æµé‡æ•°å€¼ï¼Œå•ä½ä¸ºæ¯«å‡/ç§’
  78           *      ä¾‹å¦‚ï¼šæ˜¾ç¤º"047 5 "è¡¨ç¤ºå½“å‰æµé‡ä¸º47æ¯«å‡/ç§’
  79           * 
  80           * 2. ç´¯è®¡æµé‡æ˜¾ç¤ºæ¨¡å¼ï¼ˆFLOW_MODE_TOTALï¼‰:
  81           *    - æ•°ç ç®¡ä»å³åˆ°å·¦ä¾æ¬¡ä¸ºï¼šä½1-ä½6
  82           *    - ä½1: æ˜¾ç¤ºæ•°å­—"1"ï¼Œè¡¨ç¤ºå½“å‰ä¸ºç´¯è®¡æµé‡æ˜¾ç¤ºæ¨¡å¼
  83           *    - ä½2-ä½6: æ˜¾ç¤ºç´¯è®¡æµé‡æ•°å€¼ï¼Œå•ä½ä¸ºå‡
  84           *      ä¾‹å¦‚ï¼šæ˜¾ç¤º"00231"è¡¨ç¤ºç´¯è®¡æµé‡ä¸º23.1å‡
  85           * 
  86           * æ³¨ï¼šç³»ç»Ÿä¼šæ¯3ç§’åœ¨è¿™ä¸¤ç§æ˜¾ç¤ºæ¨¡å¼é—´è‡ªåŠ¨åˆ‡æ¢
  87           */
  88          
  89          // è®¡ç®—æµé‡ï¼ˆæ¯ç§’è°ƒç”¨ä¸€æ¬¡ï¼Œç”±ä¸­æ–­è§¦å‘ï¼‰
  90          void FlowMeter_CalcFlow(void) {
  91   1          static BYTE updateCounter = 0;
  92   1          
  93   1          if (initialDisplayDelay > 0) {
  94   2              initialDisplayDelay--;
  95   2              if (initialDisplayDelay == 0) {
  96   3                  // åˆå§‹å»¶è¿Ÿç»“æŸåå¼ºåˆ¶æ›´æ–°æ˜¾ç¤º
  97   3                  needUpdateDisplay = 1;
  98   3              }
  99   2          }
 100   1          
 101   1          // æ¯FLOW_UPDATE_INTERVALç§’æ›´æ–°ä¸€æ¬¡å½“å‰æµé‡
 102   1          if (++updateCounter >= FLOW_UPDATE_INTERVAL) {
 103   2              updateCounter = 0;
 104   2              
 105   2              if (isRunning) {
 106   3                  // è®¡ç®—å½“å‰æµé‡ï¼ˆæ¯«å‡/ç§’ï¼‰- æ·»åŠ ä¹˜æ•°ä»¥å¢åŠ æµé‡
 107   3                  if (pulseCount > 0) {
 108   4                      // å°†è„‰å†²æ•°è½¬æ¢ä¸ºæ¯«å‡/ç§’ï¼Œæ·»åŠ FLOW_SPEED_MULTIPLIERå¢åŠ æµé‡
 109   4                      currentFlow = (WORD)(pulseCount * 1000 * FLOW_SPEED_MULTIPLIER / (PULSE_FACTOR * FLOW_UPDA
             -TE_INTERVAL));
 110   4                      
 111   4                      // ç¡®ä¿æœ‰æœ€å°æ˜¾ç¤ºå€¼
 112   4                      if (currentFlow < 25) currentFlow = 25;  // æœ€å°25æ¯«å‡/ç§’
 113   4                  } else {
C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 17:00:45 PAGE 3   

 114   4                      // å¦‚æœæ²¡æœ‰è„‰å†²ä½†ç³»ç»Ÿä»åœ¨è¿è¡Œï¼Œä¿æŒæœ€å°æµé‡æ˜¾ç¤º
 115   4                      currentFlow = 25;  // æ˜¾ç¤º25æ¯«å‡/ç§’
 116   4                  }
 117   3                  
 118   3                  // æ›´æ–°ç´¯è®¡æµé‡ï¼ˆæ¯«å‡ï¼‰ï¼Œå¢åŠ ç´¯ç§¯é€Ÿåº¦
 119   3                  if (pulseCount > 0) {
 120   4                      totalFlow += (unsigned long)pulseCount * 1000 * FLOW_SPEED_MULTIPLIER / PULSE_FACTOR;
 121   4                  } else {
 122   4                      totalFlow += 100;  // æ¯æ¬¡å¢åŠ 100æ¯«å‡
 123   4                  }
 124   3              }
 125   2              
 126   2              // é‡ç½®è„‰å†²è®¡æ•°ï¼Œå‡†å¤‡ä¸‹æ¬¡ç»Ÿè®¡
 127   2              pulseCount = 0;
 128   2              
 129   2              // è®¾ç½®æ˜¾ç¤ºéœ€æ›´æ–°æ ‡å¿—ï¼Œä½†ä¸åœ¨ä¸­æ–­ä¸­æ›´æ–°
 130   2              needUpdateDisplay = 1;
 131   2          }
 132   1          
 133   1          // è½®æµæ˜¾ç¤ºåˆ‡æ¢é€»è¾‘
 134   1          if (isRunning) {
 135   2              static BYTE displayToggle = 0;
 136   2              
 137   2              // è½®æµæ˜¾ç¤ºå½“å‰æµé‡å’Œç´¯è®¡æµé‡
 138   2              if (++displayToggle >= 3) {  
 139   3                  displayToggle = 0;
 140   3                  
 141   3                  // ä»…åˆ‡æ¢æ¨¡å¼ï¼Œä¸æ‰§è¡Œæ˜¾ç¤ºæ“ä½œ
 142   3                  flowMode = (flowMode == FLOW_MODE_CURR) ? FLOW_MODE_TOTAL : FLOW_MODE_CURR;
 143   3                  
 144   3                  // è®¾ç½®æ˜¾ç¤ºéœ€æ›´æ–°æ ‡å¿—
 145   3                  needUpdateDisplay = 1;
 146   3              }
 147   2          }
 148   1      }
 149          
 150          // æ£€æŸ¥å¹¶æ›´æ–°æ˜¾ç¤ºï¼ˆåœ¨ä¸»å¾ªç¯ä¸­è°ƒç”¨ï¼Œä¸åœ¨ä¸­æ–­ä¸­ï¼‰
 151          void FlowMeter_UpdateDisplay(void) {
 152   1          if (needUpdateDisplay) {
 153   2              needUpdateDisplay = 0;  // æ¸…é™¤æ ‡å¿—
 154   2              
 155   2              // æ ¹æ®å½“å‰æ¨¡å¼æ›´æ–°æ˜¾ç¤º
 156   2              if (flowMode == FLOW_MODE_CURR) {
 157   3                  UpdateCurrentFlowDisplay();
 158   3              } else if (flowMode == FLOW_MODE_TOTAL) {
 159   3                  UpdateTotalFlowDisplay();
 160   3              }
 161   2          }
 162   1      }
 163          
 164          // æ›´æ–°å½“å‰æµé‡æ˜¾ç¤º
 165          void UpdateCurrentFlowDisplay(void) {
 166   1          BYTE val1, val2, val3, val4, val5, val6;
 167   1          
 168   1          // æå–å½“å‰æµé‡å„ä½æ•°å­—ï¼ˆæ¯«å‡/ç§’ï¼‰
 169   1          
 170   1          // æ„é€ æ˜¾ç¤ºæ•°å­—
 171   1          val1 = 10;  // 10ï¼Œè¡¨ç¤ºå½“å‰æµé‡æ˜¾ç¤ºæ¨¡å¼
 172   1          val2 = (currentFlow / 10000) % 10; // ä¸‡ä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 173   1          val3 = (currentFlow / 1000) % 10; // åƒä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 174   1          val4 = (currentFlow / 100) % 10;  // ç™¾ä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 175   1          val5 = (currentFlow / 10) % 10;  // åä½ï¼ˆæ¯«å‡/ç§’ï¼‰
C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 17:00:45 PAGE 4   

 176   1          val6 = currentFlow % 10;     // ä¸ªä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 177   1          
 178   1          // ç›´æ¥å¡«å……æ˜¾ç¤ºç¼“å†²åŒº
 179   1          FillCustomDispBuf(val6, val5, val4, val3, val2, val1);
 180   1      }
 181          
 182          // æ›´æ–°ç´¯è®¡æµé‡æ˜¾ç¤º
 183          void UpdateTotalFlowDisplay(void) {
 184   1          BYTE val1, val2, val3, val4, val5, val6;
 185   1          
 186   1          // æå–æ€»æµé‡å„ä½æ•°å­—
 187   1          unsigned long flow_liter = totalFlow / 1000;  // è½¬æ¢ä¸ºå‡
 188   1          
 189   1          // æ„é€ æ˜¾ç¤ºæ•°å­—
 190   1          val1 = 11;  // 11,ç´¯è®¡æµé‡æ˜¾ç¤ºæ¨¡å¼
 191   1          val2 = (BYTE)((flow_liter / 10000) % 10); // ä¸‡ä½ï¼ˆå‡ï¼‰
 192   1          val3 = (BYTE)((flow_liter / 1000) % 10); // åƒä½ï¼ˆå‡ï¼‰
 193   1          val4 = (BYTE)((flow_liter / 100) % 10);  // ç™¾ä½ï¼ˆå‡ï¼‰
 194   1          val5 = (BYTE)((flow_liter / 10) % 10);   // åä½ï¼ˆå‡ï¼‰
 195   1          val6 = (BYTE)(flow_liter % 10);        // ä¸ªä½ï¼ˆå‡ï¼‰
 196   1          
 197   1          // ç›´æ¥å¡«å……æ˜¾ç¤ºç¼“å†²åŒº
 198   1          FillCustomDispBuf(val6, val5, val4, val3, val2, val1);
 199   1      }
 200          
 201          // æ˜¾ç¤ºå½“å‰æµé‡ï¼ˆè¿™ä¸ªå‡½æ•°ä»…ä¾›å¤–éƒ¨è°ƒç”¨ï¼Œä¸åœ¨å†…éƒ¨è°ƒç”¨é“¾ä¸­ä½¿ç”¨ï¼‰
 202          void FlowMeter_DisplayCurrent(void) {
 203   1          UpdateCurrentFlowDisplay();
 204   1      }
 205          
 206          // æ˜¾ç¤ºç´¯è®¡æµé‡ï¼ˆè¿™ä¸ªå‡½æ•°ä»…ä¾›å¤–éƒ¨è°ƒç”¨ï¼Œä¸åœ¨å†…éƒ¨è°ƒç”¨é“¾ä¸­ä½¿ç”¨ï¼‰
 207          void FlowMeter_DisplayTotal(void) {
 208   1          UpdateTotalFlowDisplay();
 209   1      }
 210          
 211          // è®¾ç½®æµé‡æ˜¾ç¤ºæ¨¡å¼
 212          void FlowMeter_SetMode(BYTE mode) {
 213   1          flowMode = mode;
 214   1          
 215   1          // ä»…è®¾ç½®æ›´æ–°æ ‡å¿—ï¼Œå®é™…æ˜¾ç¤ºåœ¨ä¸»å¾ªç¯ä¸­æ‰§è¡Œ
 216   1          needUpdateDisplay = 1;
 217   1      }
 218          
 219          // è·å–å½“å‰æµé‡æ˜¾ç¤ºæ¨¡å¼
 220          BYTE FlowMeter_GetMode(void) {
 221   1          return flowMode;
 222   1      }
 223          
 224          // è·å–å½“å‰æµé‡
 225          WORD FlowMeter_GetCurrentFlow(void) {
 226   1          return currentFlow;
 227   1      }
 228          
 229          // è·å–ç´¯è®¡æµé‡
 230          unsigned long FlowMeter_GetTotalFlow(void) {
 231   1          return totalFlow;
 232   1      }
 233          
 234          // å¤–éƒ¨ä¸­æ–­0æœåŠ¡å‡½æ•° - ç”¨äºè„‰å†²è®¡æ•°
 235          void INT0_ISR() interrupt 0 {
 236   1          pulseCount++;  // æ¯æ¬¡ä¸­æ–­å¢åŠ è„‰å†²è®¡æ•°
 237   1      }
C51 COMPILER V9.54   FLOWMETER                                                             05/25/2025 17:00:45 PAGE 5   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    595    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
