C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE FLOWMETER
OBJECT MODULE PLACED IN .\Objects\flowmeter.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE flowmeter.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\f
                    -lowmeter.lst) OBJECT(.\Objects\flowmeter.obj)

line level    source

   1          #include "flowmeter.h"
   2          #include "intrins.h"
   3          #include "i2c.h"  
   4          #include "uart.h"
   5          
   6          /*
   7           * ========================================
   8           * æµé‡è®¡ç³»ç»Ÿ - ç¡¬ä»¶è¿æ¥è¯´æ˜
   9           * ========================================
  10           * 
  11           * ã€å¼•è„šè¿æ¥å›¾ã€‘
  12           * ==============
  13           * 
  14           * 51å•ç‰‡æœº                   å¤–è®¾è¿æ¥
  15           * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
             -”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  16           * â”‚                                                 â”‚
  17           * â”‚  P1.0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
  18           * â”‚                  â”‚                            â”‚
  19           * â”‚                  â”œâ”€â”€> ç»§ç”µå™¨å¸¸å¼€è§¦ç‚¹1          â”‚
  20           * â”‚                  â”‚                            â”‚
  21           * â”‚  P1.1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€> ç»§ç”µå™¨æ§åˆ¶çº¿(ä½ç”µå¹³å¸åˆ) â”‚
  22           * â”‚                  â”‚                            â”‚
  23           * â”‚  P3.2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€> ç»§ç”µå™¨å¸¸å¼€è§¦ç‚¹2          â”‚
  24           * â”‚  (INT0)                                        â”‚
  25           * â”‚                                                â”‚
  26           * â”‚  P2.0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> 24C02-SDA (æ•°æ®çº¿)   â”‚
  27           * â”‚  P2.1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> 24C02-SCL (æ—¶é’Ÿçº¿)   â”‚
  28           * â”‚                                                â”‚
  29           * â”‚  P2.3~P2.7 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> æ•°ç ç®¡æ˜¾ç¤ºæ§åˆ¶         â”‚
  30           * â”‚                                                â”‚
  31           * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
             -”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  32           */
  33          
  34          // æµé‡è®¡å‚æ•°
  35          static BYTE flowMode = FLOW_MODE_OFF;     // æµé‡æ˜¾ç¤ºæ¨¡å¼
  36          static WORD pulseCount = 0;               // å½“å‰æµé‡è„‰å†²è®¡æ•°
  37          static WORD currentFlow = 0;              // å½“å‰æµé‡å€¼ï¼ˆæ¯«å‡/ç§’ï¼‰
  38          // ç§»é™¤æœ¬åœ°totalFlowå£°æ˜ï¼Œä½¿ç”¨i2c.cä¸­çš„å…¨å±€å˜é‡
  39          // extern unsigned long totalFlow;          // ç´¯è®¡æµé‡å€¼ï¼ˆæ¯«å‡ï¼‰- ä½¿ç”¨i2c.cä¸­çš„å…¨å±€å˜é‡
  40          static bit isRunning = 0;                 // æµé‡è®¡è¿è¡ŒçŠ¶æ€
  41          static bit needUpdateDisplay = 0;         // æ˜¾ç¤ºæ›´æ–°æ ‡å¿—
  42          static BYTE initialDisplayDelay = 0;      // åˆå§‹æ˜¾ç¤ºå»¶è¿Ÿè®¡æ•°å™¨
  43          
  44          // 24C02å­˜å‚¨æ§åˆ¶å˜é‡
  45          static BYTE saveCounter = 0;              // å®šæœŸä¿å­˜è®¡æ•°å™¨
  46          static bit totalFlowChanged = 0;          // ç´¯è®¡æµé‡å˜åŒ–æ ‡å¿—
  47          static unsigned long xdata lastSavedFlow = 0;   // ä¸Šæ¬¡ä¿å­˜çš„ç´¯è®¡æµé‡ - ç§»åˆ°xdata
  48          
  49          // æµé‡è®¡å‚æ•°å®šä¹‰
  50          #define PULSE_FACTOR 1                   // æ¯ä¸ªè„‰å†²ä»£è¡¨1æ¯«å‡
  51          #define FLOW_UPDATE_INTERVAL 1           // æ¯ç§’æ›´æ–°ä¸€æ¬¡æµé‡å€¼
  52          #define SAVE_INTERVAL 10                 // æ¯10ç§’ä¿å­˜ä¸€æ¬¡åˆ°24C02
C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 2   

  53          #define IMMEDIATE_SAVE_THRESHOLD 50      // ç´¯è®¡å·®å€¼è¶…è¿‡50mlç«‹å³ä¿å­˜
  54          
  55          // æµé‡è®¡åˆå§‹åŒ–
  56          void FlowMeter_Init(void) {
  57   1          /*
  58   1           * ç¡¬ä»¶åˆå§‹åŒ–è¯´æ˜ï¼š
  59   1           * - INT0 (P3.2): è®¾ç½®ä¸ºè¾¹æ²¿è§¦å‘ï¼Œæ£€æµ‹æµé‡è„‰å†²
  60   1           * - P1.0: æ–¹æ³¢å‘ç”Ÿå™¨è¾“å‡ºï¼Œæ¨¡æ‹Ÿæ°´æµä¼ æ„Ÿå™¨
  61   1           * - P1.1: ç»§ç”µå™¨æ§åˆ¶ï¼Œæ§åˆ¶æ°´é˜€å¼€å…³
  62   1           * - P2.0/P2.1: I2Cæ¥å£ï¼Œè¿æ¥24C02å­˜å‚¨èŠ¯ç‰‡
  63   1           */
  64   1          
  65   1      
  66   1          char flowStr[12];
  67   1          char temp[12];
  68   1          BYTE i = 0, j = 0;
  69   1          unsigned long tempFlow;
  70   1      
  71   1          IT0 = 1;                           // è®¾ç½®INT0ä¸ºè¾¹æ²¿è§¦å‘ï¼ˆä¸‹é™æ²¿è§¦å‘ï¼‰
  72   1          EX0 = 1;                           // ä½¿èƒ½INT0ä¸­æ–­
  73   1          pulseCount = 0;                    // åˆå§‹åŒ–è„‰å†²è®¡æ•°
  74   1          currentFlow = 0;                   // åˆå§‹åŒ–å½“å‰æµé‡
  75   1          
  76   1      
  77   1          
  78   1          // ä»24C02è¯»å–ç´¯è®¡æµé‡æ•°æ®
  79   1          totalFlow = AT24C02_ReadTotalFlow();
  80   1      
  81   1          lastSavedFlow = totalFlow;         // ç«‹å³ä¿å­˜åŸå§‹å€¼
  82   1          
  83   1          // å‘é€ç´¯è®¡æµé‡åˆ°ä¸²å£è¿›è¡Œè°ƒè¯•
  84   1          UART_SendString("Total Flow: ");
  85   1          
  86   1          if(totalFlow == 0) {
  87   2              UART_SendString("0");
  88   2          } else {
  89   2              tempFlow = totalFlow;
  90   2              i = 0;  // é‡ç½®ç´¢å¼•
  91   2              
  92   2              // ä»ä½ä½åˆ°é«˜ä½æå–æ•°å­—
  93   2              while(tempFlow > 0 && i < 10) {  // æ·»åŠ è¾¹ç•Œæ£€æŸ¥
  94   3                  temp[i++] = '0' + (tempFlow % 10);
  95   3                  tempFlow /= 10;
  96   3              }
  97   2              
  98   2              // ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªæ•°å­—
  99   2              if(i == 0) {
 100   3                  temp[i++] = '0';
 101   3              }
 102   2              
 103   2              // åè½¬å­—ç¬¦ä¸²
 104   2              j = 0;
 105   2              while(i > 0 && j < 10) {  // æ·»åŠ è¾¹ç•Œæ£€æŸ¥
 106   3                  flowStr[j++] = temp[--i];
 107   3              }
 108   2              flowStr[j] = '\0';
 109   2              
 110   2              UART_SendString(flowStr);
 111   2          }
 112   1          
 113   1          UART_SendString(" ml\r\n");
 114   1          
C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 3   

 115   1          isRunning = 0;                     // åˆå§‹ä¸è¿è¡Œ
 116   1          flowMode = FLOW_MODE_OFF;          // é»˜è®¤æ˜¾ç¤ºæ¨¡å¼ä¸ºå…³é—­
 117   1          saveCounter = 0;                   // é‡ç½®ä¿å­˜è®¡æ•°å™¨
 118   1          totalFlowChanged = 0;              // é‡ç½®å˜åŒ–æ ‡å¿—
 119   1      }
 120          
 121          // å¯åŠ¨æµé‡è®¡
 122          void FlowMeter_Start(void) {
 123   1          if (!isRunning) {
 124   2              pulseCount = 0;                // é‡ç½®è„‰å†²è®¡æ•°
 125   2              EX0 = 1;                       // ä½¿èƒ½INT0ä¸­æ–­
 126   2              isRunning = 1;                 // æ ‡è®°æµé‡è®¡å¼€å§‹è¿è¡Œ
 127   2              
 128   2              // è®¾ç½®åˆå§‹éé›¶æµé‡å€¼
 129   2              currentFlow = 0; 
 130   2              
 131   2              // å¼ºåˆ¶ç«‹å³æ›´æ–°æ˜¾ç¤º
 132   2              needUpdateDisplay = 1;
 133   2              initialDisplayDelay = 2;       // è®¾ç½®åˆå§‹æ˜¾ç¤ºå»¶è¿Ÿ
 134   2          }
 135   1      }
 136          
 137          // åœæ­¢æµé‡è®¡
 138          void FlowMeter_Stop(void) {
 139   1          isRunning = 0;                     // æ ‡è®°æµé‡è®¡åœæ­¢
 140   1          // ä¸å…³é—­ä¸­æ–­ï¼Œä»¥ä¾¿ç»§ç»­ç»Ÿè®¡æ€»æµé‡
 141   1      }
 142          
 143          // å¤ä½æµé‡è®¡ç´¯è®¡å€¼
 144          void FlowMeter_Reset(void) {
 145   1          pulseCount = 0;                    // é‡ç½®è„‰å†²è®¡æ•°
 146   1          currentFlow = 0;                   // é‡ç½®å½“å‰æµé‡
 147   1          // æ³¨æ„ï¼šè¿™é‡Œä¸é‡ç½®totalFlowï¼Œå› ä¸ºç´¯è®¡æµé‡åº”è¯¥æ˜¯æ°¸ä¹…ç´¯è®¡çš„
 148   1          // å¦‚æœéœ€è¦é‡ç½®ç´¯è®¡æµé‡ï¼Œåº”è¯¥æä¾›å•ç‹¬çš„å‡½æ•°
 149   1      }
 150          
 151          // æ–°å¢ï¼šé‡ç½®ç´¯è®¡æµé‡ï¼ˆåŒæ—¶æ¸…é™¤24C02ä¸­çš„æ•°æ®ï¼‰
 152          void FlowMeter_ResetTotal(void) {
 153   1          totalFlow = 0;
 154   1          AT24C02_WriteTotalFlow(0);
 155   1      }
 156          
 157          /*
 158           * ========================================
 159           * æµé‡è®¡æ˜¾ç¤ºåŠŸèƒ½è¯¦ç»†è¯´æ˜
 160           * ========================================
 161           * 
 162           * ã€æ•°ç ç®¡æ˜¾ç¤ºæ¨¡å¼ã€‘
 163           * ==================
 164           * 
 165           * æµ‡æ°´è¿‡ç¨‹ä¸­ï¼Œæ•°ç ç®¡ä¼šåœ¨ä¸¤ç§æ¨¡å¼é—´è‡ªåŠ¨åˆ‡æ¢æ˜¾ç¤ºï¼š
 166           * 
 167           * 1. å½“å‰æµé‡æ˜¾ç¤ºæ¨¡å¼ (FLOW_MODE_CURR)ï¼š
 168           *    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
             -”€â”€â”€â”€â”€â”
 169           *    â”‚ æ˜¾ç¤ºæ ¼å¼ï¼šXXXXX10                   â”‚
 170           *    â”‚ å«ä¹‰ï¼šå½“å‰ç¬æ—¶æµé‡ï¼Œå•ä½æ¯«å‡/ç§’      â”‚
 171           *    â”‚ ç¤ºä¾‹ï¼š"000510" = 5æ¯«å‡/ç§’           â”‚
 172           *    â”‚ å³ä¾§"10"æ ‡è¯†å½“å‰æµé‡æ¨¡å¼            â”‚
 173           *    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
             -”€â”€â”€â”€â”€â”˜
 174           * 
C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 4   

 175           * 2. ç´¯è®¡æµé‡æ˜¾ç¤ºæ¨¡å¼ (FLOW_MODE_TOTAL)ï¼š
 176           *    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
             -”€â”€â”€â”€â”€â”
 177           *    â”‚ æ˜¾ç¤ºæ ¼å¼ï¼šXXXXX11                   â”‚
 178           *    â”‚ å«ä¹‰ï¼šç´¯è®¡æ€»æµé‡ï¼Œå•ä½æ¯«å‡           â”‚
 179           *    â”‚ ç¤ºä¾‹ï¼š"012311" = 123æ¯«å‡æ€»æµé‡      â”‚
 180           *    â”‚ å³ä¾§"11"æ ‡è¯†ç´¯è®¡æµé‡æ¨¡å¼            â”‚
 181           *    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
             -”€â”€â”€â”€â”€â”˜
 182           * 
 183           * ã€åˆ‡æ¢é¢‘ç‡ã€‘
 184           * ============
 185           * - æ¯3ç§’è‡ªåŠ¨åˆ‡æ¢ä¸€æ¬¡æ˜¾ç¤ºæ¨¡å¼
 186           * - æµ‡æ°´æœŸé—´æŒç»­è½®æµæ˜¾ç¤º
 187           * - åœæ­¢æµ‡æ°´åå…³é—­æµé‡æ˜¾ç¤º
 188           * 
 189           * ã€å®šæ—¶æµ‡æ°´æœŸé—´çš„æ˜¾ç¤ºã€‘
 190           * ======================
 191           * 
 192           * æ­£åœ¨æµ‡æ°´æ—¶ï¼š
 193           * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
             -”€â”€â”€â”€â”
 194           * â”‚ æ˜¾ç¤ºï¼šå‰©ä½™æ¯«å‡æ•° "XXXX05"            â”‚
 195           * â”‚ ç¤ºä¾‹ï¼š"007505" = è¿˜éœ€æµ‡75æ¯«å‡       â”‚
 196           * â”‚ å®æ—¶å‡å°‘ï¼Œç›´åˆ°å˜ä¸º"000005"           â”‚
 197           * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
             -”€â”€â”€â”€â”˜
 198           * 
 199           * ã€æµé‡è®¡ç®—åŸç†ã€‘
 200           * ================
 201           * 
 202           * è„‰å†²è®¡æ•°ï¼š
 203           * - INT0ä¸‹é™æ²¿è§¦å‘ä¸­æ–­
 204           * - æ¯ä¸ªä¸‹é™æ²¿ä»£è¡¨1æ¯«å‡æ°´æµ
 205           * - 5Hzé¢‘ç‡ = æ¯ç§’5ä¸ªè„‰å†² = 5æ¯«å‡/ç§’
 206           * 
 207           * ç´¯è®¡æµé‡ï¼š
 208           * - æ¯ç§’ç´¯åŠ å½“å‰æµé‡å€¼
 209           * - æ•°æ®æ¯10ç§’ä¿å­˜åˆ°24C02
 210           * - æ–­ç”µåä»24C02æ¢å¤æ•°æ®
 211           * 
 212           * ã€ä½¿ç”¨è¯´æ˜ã€‘
 213           * ============
 214           * 
 215           * æ‰‹åŠ¨æµ‡æ°´æ—¶æŸ¥çœ‹æµé‡ï¼š
 216           * 1. æŒ‰P3.3å¼€å§‹æ‰‹åŠ¨æµ‡æ°´
 217           * 2. è§‚å¯Ÿæ•°ç ç®¡æ˜¾ç¤ºçš„å½“å‰æµé‡å’Œç´¯è®¡æµé‡
 218           * 3. å†æŒ‰P3.3åœæ­¢æµ‡æ°´
 219           * 
 220           * å®šæ—¶æµ‡æ°´æ—¶æŸ¥çœ‹è¿›åº¦ï¼š
 221           * 1. è®¾ç½®å®šæ—¶æµ‡æ°´å¹¶å¯åŠ¨
 222           * 2. æµ‡æ°´å¼€å§‹æ—¶è§‚å¯Ÿå‰©ä½™æ¯«å‡æ•°
 223           * 3. æ•°å€¼é€æ¸å‡å°‘åˆ°0æ—¶è‡ªåŠ¨åœæ­¢
 224           */
 225          
 226          /*
 227           * æ•°ç ç®¡æ˜¾ç¤ºè¯´æ˜ï¼š
 228           * æµ‡æ°´è¿‡ç¨‹ä¸­æ•°ç ç®¡ä¼šè½®æµæ˜¾ç¤ºä¸¤ç§æ¨¡å¼ï¼šå½“å‰æµé‡å’Œç´¯è®¡æµé‡
 229           * 
 230           * 1. å½“å‰æµé‡æ˜¾ç¤ºæ¨¡å¼ï¼ˆFLOW_MODE_CURRï¼‰:
 231           *    - æ•°ç ç®¡ä»å³åˆ°å·¦ä¾æ¬¡ä¸ºï¼šä½1-ä½6
 232           *    - ä½1: ä¸æ˜¾ç¤º
C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 5   

 233           *    - ä½2: æ˜¾ç¤ºæ•°å­—"5"ï¼Œè¡¨ç¤ºå½“å‰ä¸ºæµé‡æ˜¾ç¤ºæ¨¡å¼
 234           *    - ä½3: ä¸æ˜¾ç¤º
 235           *    - ä½4-ä½6: æ˜¾ç¤ºå½“å‰æµé‡æ•°å€¼ï¼Œå•ä½ä¸ºæ¯«å‡/ç§’
 236           *      ä¾‹å¦‚ï¼šæ˜¾ç¤º"250 5 "è¡¨ç¤ºå½“å‰æµé‡ä¸º250æ¯«å‡/ç§’
 237           * 
 238           * 2. ç´¯è®¡æµé‡æ˜¾ç¤ºæ¨¡å¼ï¼ˆFLOW_MODE_TOTALï¼‰:
 239           *    - æ•°ç ç®¡ä»å³åˆ°å·¦ä¾æ¬¡ä¸ºï¼šä½1-ä½6
 240           *    - ä½1: æ˜¾ç¤ºæ•°å­—"1"ï¼Œè¡¨ç¤ºå½“å‰ä¸ºç´¯è®¡æµé‡æ˜¾ç¤ºæ¨¡å¼
 241           *    - ä½2-ä½6: æ˜¾ç¤ºç´¯è®¡æµé‡æ•°å€¼ï¼Œå•ä½ä¸ºæ¯«å‡
 242           *      ä¾‹å¦‚ï¼šæ˜¾ç¤º"23501"è¡¨ç¤ºç´¯è®¡æµé‡ä¸º2350æ¯«å‡
 243           * 
 244           * æ³¨ï¼šç³»ç»Ÿä¼šæ¯3ç§’åœ¨è¿™ä¸¤ç§æ˜¾ç¤ºæ¨¡å¼é—´è‡ªåŠ¨åˆ‡æ¢
 245           */
 246          
 247          // è®¡ç®—æµé‡ï¼ˆæ¯ç§’è°ƒç”¨ä¸€æ¬¡ï¼Œç”±ä¸­æ–­è§¦å‘ï¼‰
 248          void FlowMeter_CalcFlow(void) {
 249   1          static BYTE updateCounter = 0;
 250   1          
 251   1          if (initialDisplayDelay > 0) {
 252   2              initialDisplayDelay--;
 253   2              if (initialDisplayDelay == 0) {
 254   3                  needUpdateDisplay = 1;
 255   3              }
 256   2          }
 257   1          
 258   1          // æ¯FLOW_UPDATE_INTERVALç§’æ›´æ–°ä¸€æ¬¡å½“å‰æµé‡
 259   1          if (++updateCounter >= FLOW_UPDATE_INTERVAL) {
 260   2              updateCounter = 0;
 261   2              
 262   2              if (isRunning) {
 263   3                  currentFlow = pulseCount;
 264   3                  
 265   3                  // æ›´æ–°ç´¯è®¡æµé‡ï¼ˆæ¯«å‡ï¼‰
 266   3                  if (currentFlow > 0) {
 267   4                      unsigned long oldTotalFlow = totalFlow;
 268   4                      totalFlow += currentFlow;
 269   4                      
 270   4                      // æ ‡è®°ç´¯è®¡æµé‡å·²æ”¹å˜
 271   4                      if (totalFlow != oldTotalFlow) {
 272   5                          totalFlowChanged = 1;
 273   5                      }
 274   4                      
 275   4                      // æ£€æŸ¥æ˜¯å¦éœ€è¦ç«‹å³ä¿å­˜ï¼ˆé˜²æ­¢å¤§é‡æ•°æ®ä¸¢å¤±ï¼‰
 276   4                      if (totalFlow - lastSavedFlow >= IMMEDIATE_SAVE_THRESHOLD) {
 277   5                          SaveTotalFlowToEEPROM();
 278   5                      }
 279   4                  }
 280   3              }
 281   2              
 282   2              // å®šæœŸä¿å­˜ç´¯è®¡æµé‡åˆ°24C02
 283   2              if (++saveCounter >= SAVE_INTERVAL) {
 284   3                  saveCounter = 0;
 285   3                  
 286   3                  // åªæœ‰å½“ç´¯è®¡æµé‡å‘ç”Ÿå˜åŒ–æ—¶æ‰ä¿å­˜
 287   3                  if (totalFlowChanged) {
 288   4                      SaveTotalFlowToEEPROM();
 289   4                  }
 290   3              }
 291   2              
 292   2              // é‡ç½®è„‰å†²è®¡æ•°ï¼Œå‡†å¤‡ä¸‹æ¬¡ç»Ÿè®¡
 293   2              pulseCount = 0;
 294   2              needUpdateDisplay = 1;
C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 6   

 295   2          }
 296   1          
 297   1          // è½®æµæ˜¾ç¤ºåˆ‡æ¢é€»è¾‘
 298   1          if (isRunning) {
 299   2              static BYTE displayToggle = 0;
 300   2              
 301   2              if (++displayToggle >= 3) {  
 302   3                  displayToggle = 0;
 303   3                  flowMode = (flowMode == FLOW_MODE_CURR) ? FLOW_MODE_TOTAL : FLOW_MODE_CURR;
 304   3                  needUpdateDisplay = 1;
 305   3              }
 306   2          }
 307   1      }
 308          
 309          /*
 310           * ========================================
 311           * 24C02ç´¯è®¡æµé‡å­˜å‚¨åŠŸèƒ½
 312           * ========================================
 313           * 
 314           * ã€å­˜å‚¨ç­–ç•¥ã€‘
 315           * ============
 316           * 1. å®šæœŸä¿å­˜ï¼šæ¯10ç§’è‡ªåŠ¨ä¿å­˜ä¸€æ¬¡ç´¯è®¡æµé‡
 317           * 2. å³æ—¶ä¿å­˜ï¼šç´¯è®¡æµé‡å¢åŠ è¶…è¿‡50mlæ—¶ç«‹å³ä¿å­˜
 318           * 3. æ™ºèƒ½ä¿å­˜ï¼šåªæœ‰æ•°æ®å˜åŒ–æ—¶æ‰æ‰§è¡Œå†™å…¥æ“ä½œ
 319           * 4. æ‰ç”µä¿æŠ¤ï¼šæ–­ç”µé‡å¯åè‡ªåŠ¨æ¢å¤ç´¯è®¡æµé‡æ•°æ®
 320           * 
 321           * ã€24C02åœ°å€åˆ†é…ã€‘
 322           * ==================
 323           * åœ°å€0x00-0x03: ç´¯è®¡æµé‡æ•°æ® (4å­—èŠ‚unsigned long)
 324           * åœ°å€0x10-0x16: å®šæ—¶æµ‡æ°´å‚æ•° (7å­—èŠ‚)
 325           * 
 326           * ã€æ•°æ®æ ¼å¼ã€‘
 327           * ============
 328           * ç´¯è®¡æµé‡æŒ‰å°ç«¯åºå­˜å‚¨ï¼š
 329           * - 0x00: ç´¯è®¡æµé‡ä½å­—èŠ‚  (totalFlow & 0xFF)
 330           * - 0x01: ç´¯è®¡æµé‡ç¬¬2å­—èŠ‚ ((totalFlow >> 8) & 0xFF)  
 331           * - 0x02: ç´¯è®¡æµé‡ç¬¬3å­—èŠ‚ ((totalFlow >> 16) & 0xFF)
 332           * - 0x03: ç´¯è®¡æµé‡é«˜å­—èŠ‚  ((totalFlow >> 24) & 0xFF)
 333           */
 334          
 335          // ä¿å­˜ç´¯è®¡æµé‡åˆ°24C02
 336          void SaveTotalFlowToEEPROM(void) {
 337   1          // å†™å…¥4å­—èŠ‚ç´¯è®¡æµé‡æ•°æ®åˆ°24C02
 338   1          AT24C02_WriteTotalFlow(totalFlow);
 339   1          
 340   1          // æ›´æ–°ä¿å­˜çŠ¶æ€
 341   1          lastSavedFlow = totalFlow;
 342   1          totalFlowChanged = 0;
 343   1          
 344   1          // é€šè¿‡ä¸²å£è¾“å‡ºä¿å­˜ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼Œå¯é€‰ï¼‰
 345   1          #ifdef DEBUG_FLOW_SAVE
                  UART_SendString("ç´¯è®¡æµé‡å·²ä¿å­˜: ");
                  // è¿™é‡Œå¯ä»¥æ·»åŠ æ•°å€¼è½¬æ¢å’Œè¾“å‡ºä»£ç 
                  UART_SendString("æ¯«å‡\r\n");
                  #endif
 350   1      }
 351          
 352          // ä»24C02è¯»å–ç´¯è®¡æµé‡
 353          unsigned long LoadTotalFlowFromEEPROM(void) {
 354   1          unsigned long loadedFlow = AT24C02_ReadTotalFlow();
 355   1          
 356   1          // æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥ï¼ˆé˜²æ­¢è¯»å–åˆ°æ— æ•ˆæ•°æ®ï¼‰
C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 7   

 357   1          if (loadedFlow > 999999) {  // å¦‚æœç´¯è®¡æµé‡è¶…è¿‡999å‡ï¼Œè®¤ä¸ºæ•°æ®å¼‚å¸¸
 358   2              loadedFlow = 0;         // é‡ç½®ä¸º0
 359   2              AT24C02_WriteTotalFlow(0); // æ¸…é›¶24C02ä¸­çš„æ•°æ®
 360   2          }
 361   1          
 362   1          return loadedFlow;
 363   1      }
 364          
 365          // å¼ºåˆ¶ä¿å­˜å½“å‰ç´¯è®¡æµé‡ï¼ˆå¤–éƒ¨è°ƒç”¨ï¼‰
 366          void FlowMeter_ForceSave(void) {
 367   1          SaveTotalFlowToEEPROM();
 368   1      }
 369          
 370          // è·å–ä¸Šæ¬¡ä¿å­˜æ—¶é—´ç‚¹çš„ç´¯è®¡æµé‡
 371          unsigned long FlowMeter_GetLastSavedFlow(void) {
 372   1          return lastSavedFlow;
 373   1      }
 374          
 375          // æ£€æŸ¥ç´¯è®¡æµé‡æ˜¯å¦æœ‰æœªä¿å­˜çš„å˜åŒ–
 376          bit FlowMeter_HasUnsavedChanges(void) {
 377   1          return totalFlowChanged;
 378   1      }
 379          
 380          // æ£€æŸ¥å¹¶æ›´æ–°æ˜¾ç¤ºï¼ˆåœ¨ä¸»å¾ªç¯ä¸­è°ƒç”¨ï¼Œä¸åœ¨ä¸­æ–­ä¸­ï¼‰
 381          void FlowMeter_UpdateDisplay(void) {
 382   1          if (needUpdateDisplay) {
 383   2              needUpdateDisplay = 0;  // æ¸…é™¤æ ‡å¿—
 384   2              
 385   2              // æ ¹æ®å½“å‰æ¨¡å¼æ›´æ–°æ˜¾ç¤º
 386   2              if (flowMode == FLOW_MODE_CURR) {
 387   3                  UpdateCurrentFlowDisplay();
 388   3              } else if (flowMode == FLOW_MODE_TOTAL) {
 389   3                  UpdateTotalFlowDisplay();
 390   3              }
 391   2          }
 392   1      }
 393          
 394          // æ›´æ–°å½“å‰æµé‡æ˜¾ç¤º
 395          void UpdateCurrentFlowDisplay(void) {
 396   1          BYTE val1, val2, val3, val4, val5, val6;
 397   1          
 398   1          // æå–å½“å‰æµé‡å„ä½æ•°å­—ï¼ˆæ¯«å‡/ç§’ï¼‰
 399   1          WORD flow_display = currentFlow;  // currentFlowå·²ç»æ˜¯æ¯«å‡/ç§’çš„å€¼
 400   1          
 401   1          // æ„é€ æ˜¾ç¤ºæ•°å­— - æ ¼å¼ï¼šXXXXæ¯«å‡/ç§’
 402   1          val1 = 10;  // 10ï¼Œè¡¨ç¤ºå½“å‰æµé‡æ˜¾ç¤ºæ¨¡å¼
 403   1          val2 = (flow_display / 10000) % 10; // ä¸‡ä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 404   1          val3 = (flow_display / 1000) % 10;  // åƒä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 405   1          val4 = (flow_display / 100) % 10;   // ç™¾ä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 406   1          val5 = (flow_display / 10) % 10;    // åä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 407   1          val6 = flow_display % 10;           // ä¸ªä½ï¼ˆæ¯«å‡/ç§’ï¼‰
 408   1          
 409   1          // ç›´æ¥å¡«å……æ˜¾ç¤ºç¼“å†²åŒº - æ˜¾ç¤ºæ ¼å¼å¦‚ï¼š250æ¯«å‡/ç§’æ˜¾ç¤ºä¸º"25010"
 410   1          FillCustomDispBuf(val6, val5, val4, val3, val2, val1);
 411   1      }
 412          
 413          // æ›´æ–°ç´¯è®¡æµé‡æ˜¾ç¤º
 414          void UpdateTotalFlowDisplay(void) {
 415   1          BYTE val1, val2, val3, val4, val5, val6;
 416   1          
 417   1          // æå–æ€»æµé‡å„ä½æ•°å­—ï¼ˆæ¯«å‡ï¼‰
 418   1          unsigned long flow_ml = totalFlow;  // ç›´æ¥ä½¿ç”¨æ¯«å‡å€¼
C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 8   

 419   1          
 420   1          // æ„é€ æ˜¾ç¤ºæ•°å­—
 421   1          val1 = 11;  // 11,ç´¯è®¡æµé‡æ˜¾ç¤ºæ¨¡å¼
 422   1          val2 = (BYTE)((flow_ml / 10000) % 10); // ä¸‡ä½ï¼ˆæ¯«å‡ï¼‰
 423   1          val3 = (BYTE)((flow_ml / 1000) % 10);  // åƒä½ï¼ˆæ¯«å‡ï¼‰
 424   1          val4 = (BYTE)((flow_ml / 100) % 10);   // ç™¾ä½ï¼ˆæ¯«å‡ï¼‰
 425   1          val5 = (BYTE)((flow_ml / 10) % 10);    // åä½ï¼ˆæ¯«å‡ï¼‰
 426   1          val6 = (BYTE)(flow_ml % 10);           // ä¸ªä½ï¼ˆæ¯«å‡ï¼‰
 427   1          
 428   1          // ç›´æ¥å¡«å……æ˜¾ç¤ºç¼“å†²åŒº
 429   1          FillCustomDispBuf(val6, val5, val4, val3, val2, val1);
 430   1      }
 431          
 432          // æ˜¾ç¤ºå½“å‰æµé‡ï¼ˆè¿™ä¸ªå‡½æ•°ä»…ä¾›å¤–éƒ¨è°ƒç”¨ï¼Œä¸åœ¨å†…éƒ¨è°ƒç”¨é“¾ä¸­ä½¿ç”¨ï¼‰
 433          void FlowMeter_DisplayCurrent(void) {
 434   1          UpdateCurrentFlowDisplay();
 435   1      }
 436          
 437          // æ˜¾ç¤ºç´¯è®¡æµé‡ï¼ˆè¿™ä¸ªå‡½æ•°ä»…ä¾›å¤–éƒ¨è°ƒç”¨ï¼Œä¸åœ¨å†…éƒ¨è°ƒç”¨é“¾ä¸­ä½¿ç”¨ï¼‰
 438          void FlowMeter_DisplayTotal(void) {
 439   1          UpdateTotalFlowDisplay();
 440   1      }
 441          
 442          // è®¾ç½®æµé‡æ˜¾ç¤ºæ¨¡å¼
 443          void FlowMeter_SetMode(BYTE mode) {
 444   1          flowMode = mode;
 445   1          
 446   1          // ä»…è®¾ç½®æ›´æ–°æ ‡å¿—ï¼Œå®é™…æ˜¾ç¤ºåœ¨ä¸»å¾ªç¯ä¸­æ‰§è¡Œ
 447   1          needUpdateDisplay = 1;
 448   1      }
 449          
 450          // è·å–å½“å‰æµé‡æ˜¾ç¤ºæ¨¡å¼
 451          BYTE FlowMeter_GetMode(void) {
 452   1          return flowMode;
 453   1      }
 454          
 455          // è·å–å½“å‰æµé‡
 456          WORD FlowMeter_GetCurrentFlow(void) {
 457   1          // è¿”å›å®é™…çš„æ¯«å‡/ç§’å€¼ï¼Œç”¨äºå®šæ—¶æµ‡æ°´è®¡ç®—
 458   1          return currentFlow;  // ç›´æ¥è¿”å›æ¯«å‡/ç§’å€¼
 459   1      }
 460          
 461          // è·å–ç´¯è®¡æµé‡
 462          unsigned long FlowMeter_GetTotalFlow(void) {
 463   1          return totalFlow;
 464   1      }
 465          
 466          // å¤–éƒ¨ä¸­æ–­0æœåŠ¡å‡½æ•° - ç”¨äºè„‰å†²è®¡æ•°
 467          void INT0_ISR() interrupt 0 {
 468   1          // ç®€å•è®¡æ•°ï¼Œæ¯æ¬¡ä¸‹é™æ²¿ä¸­æ–­å¢åŠ è®¡æ•°
 469   1          // å¦‚æœè¿™é‡Œè¢«è°ƒç”¨å¤ªé¢‘ç¹ï¼Œå¯èƒ½æ˜¯ï¼š
 470   1          // 1. T0é¢‘ç‡è¿‡é«˜
 471   1          // 2. ç»§ç”µå™¨è§¦ç‚¹æŠ–åŠ¨
 472   1          // 3. ä¿¡å·å™ªå£°
 473   1          pulseCount++;  // æ¯æ¬¡ä¸­æ–­å¢åŠ è„‰å†²è®¡æ•°
 474   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1073    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =      4    ----
C51 COMPILER V9.54   FLOWMETER                                                             05/27/2025 22:28:42 PAGE 9   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9      52
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
