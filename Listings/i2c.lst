C51 COMPILER V9.54   I2C                                                                   05/27/2025 20:54:43 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Objects\i2c.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE i2c.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\i2c.lst
                    -) OBJECT(.\Objects\i2c.obj)

line level    source

   1          #include "i2c.h"
   2          #include "intrins.h"
   3          
   4          // 全局变量定义
   5          unsigned long totalFlow = 0;  // 从flowmeter.c移至此处
   6          
   7          // 外部变量声明（如果需要访问闹钟时间）
   8          // extern AlarmTime alarmTime;  // 如果项目中有闹钟功能，取消注释
   9          
  10          /**
  11           * @brief I2C起始信号
  12           */
  13          void I2C_Start() {
  14   1          SDA = 1; _nop_();
  15   1          SCL = 1; _nop_();
  16   1          SDA = 0; _nop_();
  17   1          SCL = 0; _nop_();
  18   1      }
  19          
  20          /**
  21           * @brief I2C停止信号
  22           */
  23          void I2C_Stop() {
  24   1          SDA = 0; _nop_();
  25   1          SCL = 1; _nop_();
  26   1          SDA = 1; _nop_();
  27   1      }
  28          
  29          /**
  30           * @brief 发送应答信号
  31           * @param ack 0:应答 1:非应答
  32           */
  33          void I2C_SendAck(bit ack) {
  34   1          SDA = ack; _nop_();
  35   1          SCL = 1; _nop_();
  36   1          SCL = 0; _nop_();
  37   1          SDA = 1; _nop_();
  38   1      }
  39          
  40          /**
  41           * @brief 等待应答信号
  42           * @return 0:应答成功 1:应答失败
  43           */
  44          bit I2C_WaitAck() {
  45   1          SDA = 1; _nop_();
  46   1          SCL = 1; _nop_();
  47   1          if(SDA) { // 应答失败
  48   2              SCL = 0; _nop_();
  49   2              return 1;
  50   2          }
  51   1          SCL = 0; _nop_();
  52   1          return 0;
  53   1      }
  54          
C51 COMPILER V9.54   I2C                                                                   05/27/2025 20:54:43 PAGE 2   

  55          /**
  56           * @brief 写一个字节
  57           * @param dat 要写入的字节
  58           */
  59          void I2C_WriteByte(unsigned char dat) {
  60   1          unsigned char i;
  61   1          for(i=0; i<8; i++) {
  62   2              SDA = (dat & 0x80) ? 1 : 0;
  63   2              SCL = 1; _nop_();
  64   2              SCL = 0; _nop_();
  65   2              dat <<= 1;
  66   2          }
  67   1          I2C_WaitAck();
  68   1      }
  69          
  70          /**
  71           * @brief 读一个字节
  72           * @param ack 是否发送应答信号 0:应答 1:非应答
  73           * @return 读取的字节
  74           */
  75          unsigned char I2C_ReadByte(bit ack) {
  76   1          unsigned char i, dat = 0;
  77   1          SDA = 1;
  78   1          for(i=0; i<8; i++) {
  79   2              SCL = 1; _nop_();
  80   2              dat <<= 1;
  81   2              dat |= SDA;
  82   2              SCL = 0; _nop_();
  83   2          }
  84   1          I2C_SendAck(ack);
  85   1          return dat;
  86   1      }
  87          
  88          /**
  89           * @brief 向24C02写数据
  90           * @param addr 要写入数据的地址
  91           * @param dat 要写入的数据
  92           */
  93          void EEPROM_Write(unsigned char addr, unsigned char dat) {
  94   1          I2C_Start();
  95   1          I2C_WriteByte(EEPROM_ADDR);    // 器件地址+写
  96   1          I2C_WriteByte(addr);           // 存储地址
  97   1          I2C_WriteByte(dat);            // 要写入的数据
  98   1          I2C_Stop();
  99   1          delay_ms(10);                  // 等待写入完成
 100   1      }
 101          
 102          /**
 103           * @brief 从24C02读数据
 104           * @param addr 要从EEPROM读取的数据的地址
 105           * @return 读取的数据
 106           */
 107          unsigned char EEPROM_Read(unsigned char addr) {
 108   1          unsigned char dat;
 109   1          I2C_Start();
 110   1          I2C_WriteByte(EEPROM_ADDR);    // 器件地址+写
 111   1          I2C_WriteByte(addr);           // 存储地址
 112   1      
 113   1          I2C_Start();
 114   1          I2C_WriteByte(EEPROM_ADDR|1);  // 器件地址+读
 115   1          dat = I2C_ReadByte(1);         // 读取数据(发送非应答)
 116   1          I2C_Stop();
C51 COMPILER V9.54   I2C                                                                   05/27/2025 20:54:43 PAGE 3   

 117   1          return dat;
 118   1      }
 119          
 120          /**
 121           * @brief 向EEPROM写入unsigned long数据(4字节)
 122           * @param addr 起始地址
 123           * @param dat 要写入的数据
 124           */
 125          void EEPROM_WriteULong(unsigned char addr, unsigned long dat) {
 126   1          I2C_Start();
 127   1          I2C_WriteByte(EEPROM_ADDR);    // 器件地址+写
 128   1          I2C_WriteByte(addr);           // 存储地址
 129   1          
 130   1          // 分4次写入，从低字节到高字节
 131   1          I2C_WriteByte((unsigned char)(dat & 0xFF));
 132   1          I2C_WriteByte((unsigned char)((dat >> 8) & 0xFF));
 133   1          I2C_WriteByte((unsigned char)((dat >> 16) & 0xFF));
 134   1          I2C_WriteByte((unsigned char)((dat >> 24) & 0xFF));
 135   1          
 136   1          I2C_Stop();
 137   1          delay_ms(20);                  // 写入时间稍长
 138   1      }
 139          
 140          /**
 141           * @brief 从EEPROM读取unsigned long数据(4字节)
 142           * @param addr 起始地址
 143           * @return 读取的数据
 144           */
 145          unsigned long EEPROM_ReadULong(unsigned char addr) {
 146   1          unsigned long dat = 0;
 147   1          I2C_Start();
 148   1          I2C_WriteByte(EEPROM_ADDR);    // 器件地址+写
 149   1          I2C_WriteByte(addr);           // 存储地址
 150   1      
 151   1          I2C_Start();
 152   1          I2C_WriteByte(EEPROM_ADDR|1);  // 器件地址+读
 153   1          
 154   1          // 分4次读取，从低字节到高字节
 155   1          dat = I2C_ReadByte(0);         // 读取低字节(发送应答)
 156   1          dat |= (unsigned long)I2C_ReadByte(0) << 8;
 157   1          dat |= (unsigned long)I2C_ReadByte(0) << 16;
 158   1          dat |= (unsigned long)I2C_ReadByte(1) << 24; // 最后一个字节发送非应答
 159   1          
 160   1          I2C_Stop();
 161   1          return dat;
 162   1      }
 163          
 164          /**
 165           * @brief 检测是否为第一次上电
 166           * @return 是否是第一次上电
 167           */
 168          bit IsFirstPowerOn() {
 169   1          return (EEPROM_Read(INIT_FLAG_ADDR) != INIT_FLAG_VALUE);
 170   1      }
 171          
 172          /**
 173           * @brief 标记已初始化
 174           */
 175          void SetInitializedFlag() {
 176   1          EEPROM_Write(INIT_FLAG_ADDR, INIT_FLAG_VALUE);
 177   1      }
 178          
C51 COMPILER V9.54   I2C                                                                   05/27/2025 20:54:43 PAGE 4   

 179          /**
 180           * @brief 将闹钟时间写入24C02，保证掉电不丢失
 181           */
 182          void SaveAlarmToEEPROM() {
 183   1          // 如果项目中有闹钟功能，取消下面的注释并确保alarmTime变量可用
 184   1          /*
 185   1          EEPROM_Write(EEPROM_HOUR_ADR, alarmTime.hour);
 186   1          EEPROM_Write(EEPROM_MIN_ADR, alarmTime.min);
 187   1          EEPROM_Write(EEPROM_SEC_ADR, alarmTime.sec);
 188   1          */
 189   1      }
 190          
 191          /**
 192           * @brief 从24C02读取闹钟时间
 193           */
 194          void ReadAlarmFromEEPROM(){
 195   1          // 如果项目中有闹钟功能，取消下面的注释并确保alarmTime变量可用
 196   1          /*
 197   1          alarmTime.hour = EEPROM_Read(EEPROM_HOUR_ADR);
 198   1          delay_ms(10);
 199   1          alarmTime.min = EEPROM_Read(EEPROM_MIN_ADR);
 200   1          delay_ms(10);
 201   1          alarmTime.sec = EEPROM_Read(EEPROM_SEC_ADR);
 202   1          delay_ms(10);
 203   1          alarmTime.alarmTriggered = 0;
 204   1          */
 205   1      }
 206          
 207          /**
 208           * @brief 保存浇水量上限到EEPROM
 209           */
 210          void SaveWateringToEEPROM() {
 211   1          EEPROM_WriteULong(EEPROM_WATER_ADR, totalFlow);
 212   1      }
 213          
 214          /**
 215           * @brief 从EEPROM读取浇水量上限
 216           */
 217          void ReadWateringFromEEPROM() {
 218   1          totalFlow = EEPROM_ReadULong(EEPROM_WATER_ADR);
 219   1      }
 220          
 221          // ===== 兼容原有接口的函数实现 =====
 222          
 223          // I2C初始化
 224          void I2C_Init(void) {
 225   1          SDA = 1;
 226   1          SCL = 1;
 227   1      }
 228          
 229          // 兼容原有的发送字节接口（返回ACK状态）
 230          bit I2C_SendByte(BYTE dat) {
 231   1          I2C_WriteByte(dat);
 232   1          return 0;  // 假设总是成功，实际状态已在I2C_WriteByte中处理
 233   1      }
 234          
 235          // 兼容原有的接收字节接口
 236          BYTE I2C_ReceiveByte(bit ack) {
 237   1          return I2C_ReadByte(ack);
 238   1      }
 239          
 240          // 写一个字节到24C02（兼容接口）
C51 COMPILER V9.54   I2C                                                                   05/27/2025 20:54:43 PAGE 5   

 241          void AT24C02_WriteByte(BYTE addr, BYTE dat) {
 242   1          EEPROM_Write(addr, dat);
 243   1      }
 244          
 245          // 从24C02读一个字节（兼容接口）
 246          BYTE AT24C02_ReadByte(BYTE addr) {
 247   1          return EEPROM_Read(addr);
 248   1      }
 249          
 250          // 写累计流量到24C02（兼容接口）
 251          void AT24C02_WriteTotalFlow(unsigned long flow) {
 252   1          EEPROM_WriteULong(TOTAL_FLOW_ADDR_0, flow);
 253   1      }
 254          
 255          // 从24C02读累计流量（兼容接口）
 256          unsigned long AT24C02_ReadTotalFlow(void) {
 257   1          return EEPROM_ReadULong(TOTAL_FLOW_ADDR_0);
 258   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    516    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
