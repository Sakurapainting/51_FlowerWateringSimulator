C51 COMPILER V9.54   I2C                                                                   05/26/2025 21:55:48 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Objects\i2c.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE i2c.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\i2c.lst
                    -) OBJECT(.\Objects\i2c.obj)

line level    source

   1          #include "i2c.h"
   2          #include "intrins.h"
   3          #include "keyboard_control.h"  // 添加这个包含以获取TimedWatering结构体定义
   4          
   5          // I2C延时函数
   6          static void I2C_Delay(void) {
   7   1          _nop_();
   8   1          _nop_();
   9   1          _nop_();
  10   1          _nop_();
  11   1      }
  12          
  13          // I2C初始化
  14          void I2C_Init(void) {
  15   1          SDA = 1;
  16   1          SCL = 1;
  17   1      }
  18          
  19          // 发送起始信号
  20          void I2C_Start(void) {
  21   1          SDA = 1;
  22   1          SCL = 1;
  23   1          I2C_Delay();
  24   1          SDA = 0;
  25   1          I2C_Delay();
  26   1          SCL = 0;
  27   1      }
  28          
  29          // 发送停止信号
  30          void I2C_Stop(void) {
  31   1          SDA = 0;
  32   1          SCL = 0;
  33   1          I2C_Delay();
  34   1          SCL = 1;
  35   1          I2C_Delay();
  36   1          SDA = 1;
  37   1          I2C_Delay();
  38   1      }
  39          
  40          // 发送一个字节，返回ACK状态
  41          bit I2C_SendByte(BYTE dat) {
  42   1          BYTE i;
  43   1          
  44   1          for(i = 0; i < 8; i++) {
  45   2              SCL = 0;
  46   2              I2C_Delay();
  47   2              SDA = (dat & 0x80) ? 1 : 0;
  48   2              dat <<= 1;
  49   2              I2C_Delay();
  50   2              SCL = 1;
  51   2              I2C_Delay();
  52   2          }
  53   1          
  54   1          SCL = 0;
C51 COMPILER V9.54   I2C                                                                   05/26/2025 21:55:48 PAGE 2   

  55   1          I2C_Delay();
  56   1          SDA = 1;
  57   1          I2C_Delay();
  58   1          SCL = 1;
  59   1          I2C_Delay();
  60   1          
  61   1          return SDA;  // 返回ACK状态，0表示ACK，1表示NACK
  62   1      }
  63          
  64          // 接收一个字节
  65          BYTE I2C_ReceiveByte(bit ack) {
  66   1          BYTE i, dat = 0;
  67   1          
  68   1          SDA = 1;
  69   1          for(i = 0; i < 8; i++) {
  70   2              SCL = 0;
  71   2              I2C_Delay();
  72   2              SCL = 1;
  73   2              I2C_Delay();
  74   2              dat <<= 1;
  75   2              if(SDA) dat |= 0x01;
  76   2          }
  77   1          
  78   1          SCL = 0;
  79   1          I2C_Delay();
  80   1          SDA = ack ? 0 : 1;  // 发送ACK或NACK
  81   1          I2C_Delay();
  82   1          SCL = 1;
  83   1          I2C_Delay();
  84   1          SCL = 0;
  85   1          I2C_Delay();
  86   1          
  87   1          return dat;
  88   1      }
  89          
  90          // 写一个字节到24C02
  91          void AT24C02_WriteByte(BYTE addr, BYTE dat) {
  92   1          I2C_Start();
  93   1          I2C_SendByte(AT24C02_ADDR);      // 发送器件地址+写命令
  94   1          I2C_SendByte(addr);              // 发送存储地址
  95   1          I2C_SendByte(dat);               // 发送数据
  96   1          I2C_Stop();
  97   1          
  98   1          // 等待写入完成
  99   1          delay_ms(10);
 100   1      }
 101          
 102          // 从24C02读一个字节
 103          BYTE AT24C02_ReadByte(BYTE addr) {
 104   1          BYTE dat;
 105   1          
 106   1          I2C_Start();
 107   1          I2C_SendByte(AT24C02_ADDR);      // 发送器件地址+写命令
 108   1          I2C_SendByte(addr);              // 发送存储地址
 109   1          
 110   1          I2C_Start();                     // 重新开始
 111   1          I2C_SendByte(AT24C02_ADDR | 0x01); // 发送器件地址+读命令
 112   1          dat = I2C_ReceiveByte(0);        // 读取数据，发送NACK
 113   1          I2C_Stop();
 114   1          
 115   1          return dat;
 116   1      }
C51 COMPILER V9.54   I2C                                                                   05/26/2025 21:55:48 PAGE 3   

 117          
 118          // 写累计流量到24C02（4字节）
 119          void AT24C02_WriteTotalFlow(unsigned long flow) {
 120   1          AT24C02_WriteByte(TOTAL_FLOW_ADDR_0, (BYTE)(flow & 0xFF));
 121   1          AT24C02_WriteByte(TOTAL_FLOW_ADDR_1, (BYTE)((flow >> 8) & 0xFF));
 122   1          AT24C02_WriteByte(TOTAL_FLOW_ADDR_2, (BYTE)((flow >> 16) & 0xFF));
 123   1          AT24C02_WriteByte(TOTAL_FLOW_ADDR_3, (BYTE)((flow >> 24) & 0xFF));
 124   1      }
 125          
 126          // 从24C02读累计流量（4字节）
 127          unsigned long AT24C02_ReadTotalFlow(void) {
 128   1          unsigned long flow = 0;
 129   1          
 130   1          flow  = (unsigned long)AT24C02_ReadByte(TOTAL_FLOW_ADDR_0);
 131   1          flow |= (unsigned long)AT24C02_ReadByte(TOTAL_FLOW_ADDR_1) << 8;
 132   1          flow |= (unsigned long)AT24C02_ReadByte(TOTAL_FLOW_ADDR_2) << 16;
 133   1          flow |= (unsigned long)AT24C02_ReadByte(TOTAL_FLOW_ADDR_3) << 24;
 134   1          
 135   1          return flow;
 136   1      }
 137          
 138          // 写定时浇水参数到24C02
 139          void AT24C02_WriteTimedWateringParams(TimedWatering *params) {
 140   1          AT24C02_WriteByte(TIMED_WATERING_ADDR_0, params->enabled);
 141   1          AT24C02_WriteByte(TIMED_WATERING_ADDR_1, params->start_hour);
 142   1          AT24C02_WriteByte(TIMED_WATERING_ADDR_2, params->start_min);
 143   1          AT24C02_WriteByte(TIMED_WATERING_ADDR_3, params->start_sec);
 144   1          AT24C02_WriteByte(TIMED_WATERING_ADDR_4, (BYTE)(params->water_volume_ml & 0xFF));
 145   1          AT24C02_WriteByte(TIMED_WATERING_ADDR_5, (BYTE)((params->water_volume_ml >> 8) & 0xFF));
 146   1          AT24C02_WriteByte(TIMED_WATERING_ADDR_6, params->triggered_today);
 147   1      }
 148          
 149          // 从24C02读定时浇水参数
 150          void AT24C02_ReadTimedWateringParams(TimedWatering *params) {
 151   1          params->enabled = AT24C02_ReadByte(TIMED_WATERING_ADDR_0);
 152   1          params->start_hour = AT24C02_ReadByte(TIMED_WATERING_ADDR_1);
 153   1          params->start_min = AT24C02_ReadByte(TIMED_WATERING_ADDR_2);
 154   1          params->start_sec = AT24C02_ReadByte(TIMED_WATERING_ADDR_3);
 155   1          params->water_volume_ml = AT24C02_ReadByte(TIMED_WATERING_ADDR_4);
 156   1          params->water_volume_ml |= ((unsigned int)AT24C02_ReadByte(TIMED_WATERING_ADDR_5)) << 8;
 157   1          params->triggered_today = AT24C02_ReadByte(TIMED_WATERING_ADDR_6);
 158   1          
 159   1          // 设置运行时参数为默认值
 160   1          params->is_watering = 0;
 161   1          params->watering_volume_left = 0;
 162   1          
 163   1          // 参数有效性检查
 164   1          if(params->start_hour > 23) params->start_hour = 6;
 165   1          if(params->start_min > 59) params->start_min = 0;
 166   1          if(params->start_sec > 59) params->start_sec = 1;
 167   1          if(params->water_volume_ml < 50 || params->water_volume_ml > 9999) {
 168   2              params->water_volume_ml = 100;
 169   2          }
 170   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    792    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      14
C51 COMPILER V9.54   I2C                                                                   05/26/2025 21:55:48 PAGE 4   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
