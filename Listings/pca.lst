C51 COMPILER V9.54   PCA                                                                   05/25/2025 20:50:47 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PCA
OBJECT MODULE PLACED IN .\Objects\pca.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE pca.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\pca.lst
                    -) OBJECT(.\Objects\pca.obj)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          #include "pca.h"     // åŒ…å«å¤´æ–‡ä»¶
   4          #include "flowmeter.h" // æ·»åŠ flowmeter.hä»¥è·å–FLOW_MODE_OFFå®šä¹‰
   5          
   6          #define FOSC    11059200L
   7          #define T100Hz  (FOSC / 12 / 100)
   8          #define T1000Hz (FOSC / 12 / 1000)
   9          
  10          // typedef unsigned char BYTE;
  11          // typedef unsigned int WORD;
  12          
  13          /*Declare SFR associated with the PCA */
  14          sfr CCON        =   0xD8;           //PCA control register
  15          sbit CCF0       =   CCON^0;         //PCA module-0 interrupt flag
  16          sbit CCF1       =   CCON^1;         //PCA module-1 interrupt flag
  17          sbit CR         =   CCON^6;         //PCA timer run control bit
  18          sbit CF         =   CCON^7;         //PCA timer overflow flag
  19          sfr CMOD        =   0xD9;           //PCA mode register
  20          sfr CL          =   0xE9;           //PCA base timer LOW
  21          sfr CH          =   0xF9;           //PCA base timer HIGH
  22          sfr CCAPM0      =   0xDA;           //PCA module-0 mode register
  23          sfr CCAP0L      =   0xEA;           //PCA module-0 capture register LOW
  24          sfr CCAP0H      =   0xFA;           //PCA module-0 capture register HIGH
  25          sfr CCAPM1      =   0xDB;           //PCA module-1 mode registers
  26          sfr CCAP1L      =   0xEB;           //PCA module-1 capture register LOW
  27          sfr CCAP1H      =   0xFB;           //PCA module-1 capture register HIGH
  28          sfr PCAPWM0     =   0xf2;
  29          sfr PCAPWM1     =   0xf3;
  30          
  31          sbit PCA_LED    =   P1^0;           //PCA test LED
  32          
  33          BYTE cnt;
  34          WORD value;
  35          WORD value1;
  36          
  37          
  38          
  39          SYS_PARAMS SysPara1 = {0, 0, 0};    // åˆå§‹åŒ–ç³»ç»Ÿå‚æ•°
  40          
  41          // æ˜¾ç¤ºç›¸å…³å¼•è„šå®šä¹‰
  42          sbit DATA = DISP_PORT^0;  // ä¸²è¡Œæ•°æ®è¾“å…¥
  43          sbit SCK  = DISP_PORT^1;  // ç§»ä½æ—¶é’Ÿ
  44          sbit RCK  = DISP_PORT^2;  // å­˜å‚¨æ—¶é’Ÿ
  45          sbit OE   = DISP_PORT^3;  // è¾“å‡ºä½¿èƒ½(ä½æœ‰æ•ˆ)
  46          
  47          #define CURRENTFLOW_MODE 0x39 // å½“å‰æµé‡æ¨¡å¼
  48          #define TOTALFLOW_MODE 0X71   // ç´¯è®¡æµé‡æ¨¡å¼
  49          
  50          /* å…±é˜´ææ•°ç ç®¡æ®µç å®šä¹‰ */
  51          static code const unsigned char LED[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,CURRENTFLOW_MOD
             -E,TOTALFLOW_MODE};
  52          
  53          // æ˜¾ç¤ºç¼“å†²åŒº
C51 COMPILER V9.54   PCA                                                                   05/25/2025 20:50:47 PAGE 2   

  54          unsigned char dispbuff[8] = {SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF};
  55          
  56          // å®ç°æ˜¾ç¤ºç›¸å…³å‡½æ•°
  57          void delay_ms(unsigned int ms) {
  58   1          unsigned int i, j;
  59   1          for (i = 0; i < ms; i++)
  60   1              for (j = 0; j < 120; j++);
  61   1      }
  62          
  63          // void SendTo595(unsigned char data_seg, unsigned char data_bit) {
  64          //     unsigned char i;
  65          //     OE = 1;
  66              
  67          //     for(i = 0; i < 8; i++) {
  68          //         DATA = (data_bit & 0x80) ? 1 : 0;
  69          //         SCK = 0; SCK = 1;
  70          //         data_bit <<= 1;
  71          //     }
  72              
  73          //     for(i = 0; i < 8; i++) {
  74          //         DATA = (data_seg & 0x80) ? 1 : 0;
  75          //         SCK = 0; SCK = 1;
  76          //         data_seg <<= 1;
  77          //     }
  78              
  79          //     RCK = 0; RCK = 1;
  80          //     OE = 0;
  81          //     delay_ms(1);
  82          // }
  83          
  84          void Resetdispbuff() {
  85   1          unsigned char i;
  86   1          for(i = 0; i < 8; i++) dispbuff[i] = SEG_OFF;
  87   1      }
  88          
  89          void FillDispBuf(BYTE hour, BYTE min, BYTE sec) {
  90   1          Resetdispbuff();
  91   1          // ç§’éƒ¨åˆ†ï¼ˆå³èµ·0-1ä½ï¼‰
  92   1          dispbuff[0] = LED[sec % 10]; // ç§’ä¸ªä½
  93   1          dispbuff[1] = LED[sec / 10]; // ç§’åä½
  94   1          
  95   1          // åˆ†é’Ÿéƒ¨åˆ†ï¼ˆå³èµ·2-3ä½ï¼‰
  96   1          dispbuff[2] = LED[min % 10];
  97   1          dispbuff[3] = LED[min / 10];
  98   1          
  99   1          // å°æ—¶éƒ¨åˆ†ï¼ˆå³èµ·4-5ä½ï¼‰
 100   1          dispbuff[4] = LED[hour % 10];
 101   1          dispbuff[5] = LED[hour / 10];
 102   1      }
 103          
 104          // è‡ªå®šä¹‰æ˜¾ç¤ºç¼“å†²åŒºå¡«å……å‡½æ•°
 105          void FillCustomDispBuf(BYTE val1, BYTE val2, BYTE val3, BYTE val4, BYTE val5, BYTE val6) {
 106   1          Resetdispbuff();
 107   1          
 108   1          // å¡«å……6ä¸ªæ•°å­—ä½
 109   1          dispbuff[0] = LED[val1];
 110   1          dispbuff[1] = LED[val2];
 111   1          dispbuff[2] = LED[val3];
 112   1          dispbuff[3] = LED[val4];
 113   1          dispbuff[4] = LED[val5];
 114   1          dispbuff[5] = LED[val6];
 115   1      }
C51 COMPILER V9.54   PCA                                                                   05/25/2025 20:50:47 PAGE 3   

 116          
 117          void disp(void) {
 118   1          unsigned char i;
 119   1          static unsigned char pos = 0;  // å½“å‰æ‰«æçš„ä½ç½®
 120   1          static unsigned char mark = 0x01;  // ä½é€‰æ©ç 
 121   1          unsigned char tmpdata;
 122   1          
 123   1          // è®¾ç½®è¾“å‡ºä½¿èƒ½ä¸ºé«˜ï¼Œå‡†å¤‡æ•°æ®ä¼ è¾“
 124   1          OE = 1;
 125   1          
 126   1          // å‡†å¤‡ä½é€‰æ•°æ®ï¼ˆä½ç”µå¹³æœ‰æ•ˆï¼‰
 127   1          tmpdata = ~mark;
 128   1          
 129   1          // å‘é€ä½é€‰æ•°æ®åˆ°74HC595
 130   1          for(i = 0; i < 8; i++) {
 131   2              // ä»æœ€é«˜ä½å¼€å§‹å‘é€
 132   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 133   2              SCK = 0;
 134   2              SCK = 1;
 135   2              tmpdata <<= 1;
 136   2          }
 137   1          
 138   1          // å‘é€æ®µç æ•°æ®åˆ°74HC595
 139   1          tmpdata = dispbuff[pos];
 140   1          for(i = 0; i < 8; i++) {
 141   2              // ä»æœ€é«˜ä½å¼€å§‹å‘é€
 142   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 143   2              SCK = 0;
 144   2              SCK = 1;
 145   2              tmpdata <<= 1;
 146   2          }
 147   1          
 148   1          // é”å­˜æ•°æ®å¹¶è¾“å‡º
 149   1          RCK = 0;
 150   1          RCK = 1;
 151   1          
 152   1          // ä½¿èƒ½è¾“å‡º
 153   1          OE = 0;
 154   1          
 155   1          // ç§»åŠ¨åˆ°ä¸‹ä¸€ä½
 156   1          pos = (pos + 1) % 8;
 157   1          mark = (mark << 1) | (mark >> 7);  // å¾ªç¯å·¦ç§»
 158   1          if(mark == 0) mark = 0x01;  // ç¡®ä¿éé›¶
 159   1      }
 160          
 161          // æ—¶é—´ç¼–è¾‘ç›¸å…³å˜é‡
 162          static BYTE timeEditMode = 0;  // 0: æ­£å¸¸æ˜¾ç¤º, 1: ç¼–è¾‘å°æ—¶, 2: ç¼–è¾‘åˆ†é’Ÿ, 3: ç¼–è¾‘ç§’
 163          static BYTE blinkState = 0;    // é—ªçƒçŠ¶æ€: 0 æ˜¾ç¤º, 1 ä¸æ˜¾ç¤º
 164          
 165          // è®¾ç½®æ—¶é—´ç¼–è¾‘æ¨¡å¼
 166          void PCA_SetTimeEditMode(BYTE position) {
 167   1          timeEditMode = position;
 168   1          blinkState = 0;  // å¼€å§‹æ—¶å¤„äºæ˜¾ç¤ºçŠ¶æ€
 169   1      }
 170          
 171          // é€€å‡ºæ—¶é—´ç¼–è¾‘æ¨¡å¼
 172          void PCA_ExitTimeEditMode(void) {
 173   1          timeEditMode = 0;
 174   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 175   1      }
 176          
 177          // å¢åŠ æ—¶é—´å€¼
C51 COMPILER V9.54   PCA                                                                   05/25/2025 20:50:47 PAGE 4   

 178          void PCA_IncreaseTimeValue(BYTE position) {
 179   1          switch (position) {
 180   2              case HOUR_POS:
 181   2                  SysPara1.hour = (SysPara1.hour + 1) % 24;
 182   2                  break;
 183   2              case MIN_POS:
 184   2                  SysPara1.min = (SysPara1.min + 1) % 60;
 185   2                  break;
 186   2              case SEC_POS:
 187   2                  SysPara1.sec = (SysPara1.sec + 1) % 60;
 188   2                  break;
 189   2          }
 190   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 191   1      }
 192          
 193          // ç›´æ¥è®¾ç½®æ—¶é—´å‡½æ•°
 194          void PCA_SetTime(BYTE hour, BYTE min, BYTE sec) {
 195   1          // éªŒè¯è¾“å…¥æ—¶é—´æ˜¯å¦æœ‰æ•ˆ
 196   1          if(hour < 24 && min < 60 && sec < 60) {
 197   2              SysPara1.hour = hour;
 198   2              SysPara1.min = min;
 199   2              SysPara1.sec = sec;
 200   2              
 201   2              // å¦‚æœå½“å‰æ˜¯æ—¶é’Ÿæ˜¾ç¤ºæ¨¡å¼ï¼Œæ›´æ–°æ˜¾ç¤º
 202   2              if(FlowMeter_GetMode() == FLOW_MODE_OFF && timeEditMode == 0) {
 203   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 204   3              }
 205   2          }
 206   1      }
 207          
 208          // ä¿®æ”¹PCAä¸­æ–­æœåŠ¡å‡½æ•°ï¼ŒåŠ å…¥é—ªçƒå¤„ç†é€»è¾‘
 209          void PCA_isr() interrupt 7
 210          {
 211   1          if(CCF1){
 212   2              CCF1 = 0;                       // Clear interrupt flag
 213   2              CCAP1L = value1;
 214   2              CCAP1H = value1 >> 8;           // Update compare value
 215   2              value1 += T1000Hz;
 216   2              disp();                         // åˆ·æ–°æ˜¾ç¤º
 217   2          }
 218   1      
 219   1          if(CCF0){
 220   2              CCF0 = 0;                       // Clear interrupt flag
 221   2              CCAP0L = value;
 222   2              CCAP0H = value >> 8;            // Update compare value
 223   2              value += T100Hz;
 224   2              cnt++;
 225   2              
 226   2              if(cnt >= 100) {                // Count 100 times
 227   3                  cnt = 0;                    // 1ç§’è®¡æ—¶
 228   3                  PCA_LED = !PCA_LED;         // é—ªçƒLEDæŒ‡ç¤ºç¯
 229   3                  
 230   3                  // è°ƒç”¨æµé‡è®¡è®¡ç®—å‡½æ•°ï¼ˆä¸æ›´æ–°æ˜¾ç¤ºï¼‰ï¼Œæ”¹ä¸ºæ›´é¢‘ç¹è°ƒç”¨
 231   3                  FlowMeter_CalcFlow();
 232   3                  
 233   3                  // æ›´æ–°æ—¶é’Ÿï¼Œä½†ä¸ç›´æ¥æ›´æ–°æ˜¾ç¤º
 234   3                  SysPara1.sec++;
 235   3                  if(SysPara1.sec >= 60) {
 236   4                      SysPara1.sec = 0;
 237   4                      SysPara1.min++;
 238   4                      if(SysPara1.min >= 60) {
 239   5                          SysPara1.min = 0;
C51 COMPILER V9.54   PCA                                                                   05/25/2025 20:50:47 PAGE 5   

 240   5                          SysPara1.hour++;
 241   5                          if(SysPara1.hour >= 24)
 242   5                              SysPara1.hour = 0;
 243   5                      }
 244   4                  }
 245   3                  
 246   3                  // æ—¶é—´ç¼–è¾‘æ¨¡å¼é—ªçƒæ§åˆ¶ (æ¯ç§’åˆ‡æ¢ä¸€æ¬¡)
 247   3                  if (timeEditMode > 0) {
 248   4                      blinkState = !blinkState;
 249   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 250   4                      
 251   4                      // æ ¹æ®ç¼–è¾‘æ¨¡å¼å’Œé—ªçƒçŠ¶æ€ï¼Œè®¾ç½®ç›¸åº”ä½ä¸ºä¸æ˜¾ç¤º
 252   4                      if (blinkState) {
 253   5                          switch (timeEditMode) {
 254   6                              case HOUR_POS:  // ç¼–è¾‘å°æ—¶
 255   6                                  dispbuff[4] = SEG_OFF;
 256   6                                  dispbuff[5] = SEG_OFF;
 257   6                                  break;
 258   6                              case MIN_POS:  // ç¼–è¾‘åˆ†é’Ÿ
 259   6                                  dispbuff[2] = SEG_OFF;
 260   6                                  dispbuff[3] = SEG_OFF;
 261   6                                  break;
 262   6                              case SEC_POS:  // ç¼–è¾‘ç§’
 263   6                                  dispbuff[0] = SEG_OFF;
 264   6                                  dispbuff[1] = SEG_OFF;
 265   6                                  break;
 266   6                          }
 267   5                      }
 268   4                  }
 269   3                  
 270   3                  // åªæœ‰åœ¨æµé‡è®¡æ¨¡å¼ä¸ºå…³é—­ä¸”ä¸åœ¨æ—¶é—´ç¼–è¾‘æ¨¡å¼æ—¶æ‰æ›´æ–°æ—¶é’Ÿæ˜¾ç¤ºçš„ç¼“å
             -†²åŒº
 271   3                  else if (FlowMeter_GetMode() == FLOW_MODE_OFF) {
 272   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 273   4                  }
 274   3              }
 275   2              else if(cnt % 20 == 0 && FlowMeter_GetMode() != FLOW_MODE_OFF) {
 276   3                  // æ¯0.2ç§’ä¹Ÿè°ƒç”¨ä¸€æ¬¡æµé‡è®¡ç®—ï¼Œä»¥å‡å°‘åˆ·æ–°å»¶è¿Ÿ
 277   3                  FlowMeter_CalcFlow();
 278   3              }
 279   2              else if(cnt % 50 == 0 && timeEditMode > 0) {
 280   3                  // åœ¨æ—¶é—´ç¼–è¾‘æ¨¡å¼ä¸‹ï¼Œæ¯0.5ç§’åˆ‡æ¢ä¸€æ¬¡é—ªçƒçŠ¶æ€
 281   3                  blinkState = !blinkState;
 282   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 283   3                  
 284   3                  // æ ¹æ®ç¼–è¾‘æ¨¡å¼å’Œé—ªçƒçŠ¶æ€ï¼Œè®¾ç½®ç›¸åº”ä½ä¸ºä¸æ˜¾ç¤º
 285   3                  if (blinkState) {
 286   4                      switch (timeEditMode) {
 287   5                          case HOUR_POS:  // ç¼–è¾‘å°æ—¶
 288   5                              dispbuff[4] = SEG_OFF;
 289   5                              dispbuff[5] = SEG_OFF;
 290   5                              break;
 291   5                          case MIN_POS:  // ç¼–è¾‘åˆ†é’Ÿ
 292   5                              dispbuff[2] = SEG_OFF;
 293   5                              dispbuff[3] = SEG_OFF;
 294   5                              break;
 295   5                          case SEC_POS:  // ç¼–è¾‘ç§’
 296   5                              dispbuff[0] = SEG_OFF;
 297   5                              dispbuff[1] = SEG_OFF;
 298   5                              break;
 299   5                      }
 300   4                  }
C51 COMPILER V9.54   PCA                                                                   05/25/2025 20:50:47 PAGE 6   

 301   3              }
 302   2          }
 303   1      }
 304          
 305          void PCA_Init(void)
 306          {
 307   1          CCON = 0;                       // Initial PCA control register
 308   1                                          // PCA timer stop running
 309   1                                          // Clear CF flag
 310   1                                          // Clear all module interrupt flag
 311   1          CL = 0;                         // Reset PCA base timer
 312   1          CH = 0;
 313   1          CMOD = 0x00;                    // Set PCA timer clock source as Fosc/12
 314   1                                          // Disable PCA timer overflow interrupt
 315   1          
 316   1          // åˆå§‹åŒ–PCAæ¨¡å—1 (1000Hz)
 317   1          value1 = T1000Hz;
 318   1          CCAP1L = value1;
 319   1          CCAP1H = value1 >> 8;           // Initial PCA module-1
 320   1          value1 += T1000Hz;
 321   1          CCAPM1 = 0x49;                  // PCA module-1 work in 16-bit timer mode
 322   1                                          // and enable PCA interrupt
 323   1          
 324   1          // åˆå§‹åŒ–PCAæ¨¡å—0 (100Hz)
 325   1          value = T100Hz;
 326   1          CCAP0L = value;
 327   1          CCAP0H = value >> 8;            // Initial PCA module-0
 328   1          value += T100Hz;
 329   1          CCAPM0 = 0x49;                  // PCA module-0 work in 16-bit timer mode
 330   1                                          // and enable PCA interrupt
 331   1          
 332   1          CR = 1;                         // PCA timer start run
 333   1          EA = 1;                         // Enable global interrupt
 334   1          cnt = 0;
 335   1      
 336   1          // åˆå§‹åŒ–æ—¶é’Ÿæ˜¾ç¤º
 337   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 338   1      }
 339          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    761    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
