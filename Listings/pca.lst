C51 COMPILER V9.54   PCA                                                                   05/25/2025 15:11:47 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PCA
OBJECT MODULE PLACED IN .\Objects\pca.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE pca.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\pca.lst
                    -) OBJECT(.\Objects\pca.obj)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          #include "pca.h"     // 包含头文件
   4          #include "flowmeter.h" // 添加flowmeter.h以获取FLOW_MODE_OFF定义
   5          
   6          #define FOSC    11059200L
   7          #define T100Hz  (FOSC / 12 / 100)
   8          #define T1000Hz (FOSC / 12 / 1000)
   9          
  10          // typedef unsigned char BYTE;
  11          // typedef unsigned int WORD;
  12          
  13          /*Declare SFR associated with the PCA */
  14          sfr CCON        =   0xD8;           //PCA control register
  15          sbit CCF0       =   CCON^0;         //PCA module-0 interrupt flag
  16          sbit CCF1       =   CCON^1;         //PCA module-1 interrupt flag
  17          sbit CR         =   CCON^6;         //PCA timer run control bit
  18          sbit CF         =   CCON^7;         //PCA timer overflow flag
  19          sfr CMOD        =   0xD9;           //PCA mode register
  20          sfr CL          =   0xE9;           //PCA base timer LOW
  21          sfr CH          =   0xF9;           //PCA base timer HIGH
  22          sfr CCAPM0      =   0xDA;           //PCA module-0 mode register
  23          sfr CCAP0L      =   0xEA;           //PCA module-0 capture register LOW
  24          sfr CCAP0H      =   0xFA;           //PCA module-0 capture register HIGH
  25          sfr CCAPM1      =   0xDB;           //PCA module-1 mode registers
  26          sfr CCAP1L      =   0xEB;           //PCA module-1 capture register LOW
  27          sfr CCAP1H      =   0xFB;           //PCA module-1 capture register HIGH
  28          sfr PCAPWM0     =   0xf2;
  29          sfr PCAPWM1     =   0xf3;
  30          
  31          sbit PCA_LED    =   P1^0;           //PCA test LED
  32          
  33          BYTE cnt;
  34          WORD value;
  35          WORD value1;
  36          
  37          
  38          
  39          SYS_PARAMS SysPara1 = {0, 0, 0};    // 初始化系统参数
  40          
  41          // 显示相关引脚定义
  42          sbit DATA = DISP_PORT^0;  // 串行数据输入
  43          sbit SCK  = DISP_PORT^1;  // 移位时钟
  44          sbit RCK  = DISP_PORT^2;  // 存储时钟
  45          sbit OE   = DISP_PORT^3;  // 输出使能(低有效)
  46          
  47          #define CURRENTFLOW_MODE 0x39 // 当前流量模式
  48          #define TOTALFLOW_MODE 0X71   // 累计流量模式
  49          
  50          /* 共阴极数码管段码定义 */
  51          static code const unsigned char LED[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,CURRENTFLOW_MOD
             -E,TOTALFLOW_MODE};
  52          
  53          // 显示缓冲区
C51 COMPILER V9.54   PCA                                                                   05/25/2025 15:11:47 PAGE 2   

  54          unsigned char dispbuff[8] = {SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF};
  55          
  56          // 实现显示相关函数
  57          void delay_ms(unsigned int ms) {
  58   1          unsigned int i, j;
  59   1          for (i = 0; i < ms; i++)
  60   1              for (j = 0; j < 120; j++);
  61   1      }
  62          
  63          // void SendTo595(unsigned char data_seg, unsigned char data_bit) {
  64          //     unsigned char i;
  65          //     OE = 1;
  66              
  67          //     for(i = 0; i < 8; i++) {
  68          //         DATA = (data_bit & 0x80) ? 1 : 0;
  69          //         SCK = 0; SCK = 1;
  70          //         data_bit <<= 1;
  71          //     }
  72              
  73          //     for(i = 0; i < 8; i++) {
  74          //         DATA = (data_seg & 0x80) ? 1 : 0;
  75          //         SCK = 0; SCK = 1;
  76          //         data_seg <<= 1;
  77          //     }
  78              
  79          //     RCK = 0; RCK = 1;
  80          //     OE = 0;
  81          //     delay_ms(1);
  82          // }
  83          
  84          void Resetdispbuff() {
  85   1          unsigned char i;
  86   1          for(i = 0; i < 8; i++) dispbuff[i] = SEG_OFF;
  87   1      }
  88          
  89          void FillDispBuf(BYTE hour, BYTE min, BYTE sec) {
  90   1          Resetdispbuff();
  91   1          // 秒部分（右起0-1位）
  92   1          dispbuff[0] = LED[sec % 10]; // 秒个位
  93   1          dispbuff[1] = LED[sec / 10]; // 秒十位
  94   1          
  95   1          // 分钟部分（右起2-3位）
  96   1          dispbuff[2] = LED[min % 10];
  97   1          dispbuff[3] = LED[min / 10];
  98   1          
  99   1          // 小时部分（右起4-5位）
 100   1          dispbuff[4] = LED[hour % 10];
 101   1          dispbuff[5] = LED[hour / 10];
 102   1      }
 103          
 104          // 自定义显示缓冲区填充函数
 105          void FillCustomDispBuf(BYTE val1, BYTE val2, BYTE val3, BYTE val4, BYTE val5, BYTE val6) {
 106   1          Resetdispbuff();
 107   1          
 108   1          // 填充6个数字位
 109   1          dispbuff[0] = LED[val1];
 110   1          dispbuff[1] = LED[val2];
 111   1          dispbuff[2] = LED[val3];
 112   1          dispbuff[3] = LED[val4];
 113   1          dispbuff[4] = LED[val5];
 114   1          dispbuff[5] = LED[val6];
 115   1      }
C51 COMPILER V9.54   PCA                                                                   05/25/2025 15:11:47 PAGE 3   

 116          
 117          void disp(void) {
 118   1          unsigned char i;
 119   1          static unsigned char pos = 0;  // 当前扫描的位置
 120   1          static unsigned char mark = 0x01;  // 位选掩码
 121   1          unsigned char tmpdata;
 122   1          
 123   1          // 设置输出使能为高，准备数据传输
 124   1          OE = 1;
 125   1          
 126   1          // 准备位选数据（低电平有效）
 127   1          tmpdata = ~mark;
 128   1          
 129   1          // 发送位选数据到74HC595
 130   1          for(i = 0; i < 8; i++) {
 131   2              // 从最高位开始发送
 132   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 133   2              SCK = 0;
 134   2              SCK = 1;
 135   2              tmpdata <<= 1;
 136   2          }
 137   1          
 138   1          // 发送段码数据到74HC595
 139   1          tmpdata = dispbuff[pos];
 140   1          for(i = 0; i < 8; i++) {
 141   2              // 从最高位开始发送
 142   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 143   2              SCK = 0;
 144   2              SCK = 1;
 145   2              tmpdata <<= 1;
 146   2          }
 147   1          
 148   1          // 锁存数据并输出
 149   1          RCK = 0;
 150   1          RCK = 1;
 151   1          
 152   1          // 使能输出
 153   1          OE = 0;
 154   1          
 155   1          // 移动到下一位
 156   1          pos = (pos + 1) % 8;
 157   1          mark = (mark << 1) | (mark >> 7);  // 循环左移
 158   1          if(mark == 0) mark = 0x01;  // 确保非零
 159   1      }
 160          
 161          void PCA_isr() interrupt 7
 162          {
 163   1          if(CCF1){
 164   2              CCF1 = 0;                       // Clear interrupt flag
 165   2              CCAP1L = value1;
 166   2              CCAP1H = value1 >> 8;           // Update compare value
 167   2              value1 += T1000Hz;
 168   2              disp();                         // 刷新显示
 169   2          }
 170   1      
 171   1          if(CCF0){
 172   2              CCF0 = 0;                       // Clear interrupt flag
 173   2              CCAP0L = value;
 174   2              CCAP0H = value >> 8;            // Update compare value
 175   2              value += T100Hz;
 176   2              cnt++;
 177   2              
C51 COMPILER V9.54   PCA                                                                   05/25/2025 15:11:47 PAGE 4   

 178   2              if(cnt >= 100) {                // Count 100 times
 179   3                  cnt = 0;                    // 1秒计时
 180   3                  PCA_LED = !PCA_LED;         // 闪烁LED指示灯
 181   3                  
 182   3                  // 调用流量计计算函数（不更新显示），改为更频繁调用
 183   3                  FlowMeter_CalcFlow();
 184   3                  
 185   3                  // 更新时钟，但不直接更新显示
 186   3                  SysPara1.sec++;
 187   3                  if(SysPara1.sec >= 60) {
 188   4                      SysPara1.sec = 0;
 189   4                      SysPara1.min++;
 190   4                      if(SysPara1.min >= 60) {
 191   5                          SysPara1.min = 0;
 192   5                          SysPara1.hour++;
 193   5                          if(SysPara1.hour >= 24)
 194   5                              SysPara1.hour = 0;
 195   5                      }
 196   4                  }
 197   3                  
 198   3                  // 只有在流量计模式为关闭时才更新时钟显示的缓冲区
 199   3                  if (FlowMeter_GetMode() == FLOW_MODE_OFF) {
 200   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 201   4                  }
 202   3              }
 203   2              else if(cnt % 20 == 0 && FlowMeter_GetMode() != FLOW_MODE_OFF) {
 204   3                  // 每0.2秒也调用一次流量计算，以减少刷新延迟
 205   3                  FlowMeter_CalcFlow();
 206   3              }
 207   2          }
 208   1      }
 209          
 210          void PCA_Init(void)
 211          {
 212   1          CCON = 0;                       // Initial PCA control register
 213   1                                          // PCA timer stop running
 214   1                                          // Clear CF flag
 215   1                                          // Clear all module interrupt flag
 216   1          CL = 0;                         // Reset PCA base timer
 217   1          CH = 0;
 218   1          CMOD = 0x00;                    // Set PCA timer clock source as Fosc/12
 219   1                                          // Disable PCA timer overflow interrupt
 220   1          
 221   1          // 初始化PCA模块1 (1000Hz)
 222   1          value1 = T1000Hz;
 223   1          CCAP1L = value1;
 224   1          CCAP1H = value1 >> 8;           // Initial PCA module-1
 225   1          value1 += T1000Hz;
 226   1          CCAPM1 = 0x49;                  // PCA module-1 work in 16-bit timer mode
 227   1                                          // and enable PCA interrupt
 228   1          
 229   1          // 初始化PCA模块0 (100Hz)
 230   1          value = T100Hz;
 231   1          CCAP0L = value;
 232   1          CCAP0H = value >> 8;            // Initial PCA module-0
 233   1          value += T100Hz;
 234   1          CCAPM0 = 0x49;                  // PCA module-0 work in 16-bit timer mode
 235   1                                          // and enable PCA interrupt
 236   1          
 237   1          CR = 1;                         // PCA timer start run
 238   1          EA = 1;                         // Enable global interrupt
 239   1          cnt = 0;
C51 COMPILER V9.54   PCA                                                                   05/25/2025 15:11:47 PAGE 5   

 240   1      
 241   1          // 初始化时钟显示
 242   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 243   1      }
 244          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    510    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
