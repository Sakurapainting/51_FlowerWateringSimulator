C51 COMPILER V9.54   PCA                                                                   05/25/2025 14:34:34 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PCA
OBJECT MODULE PLACED IN .\Objects\pca.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE pca.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\pca.lst
                    -) OBJECT(.\Objects\pca.obj)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          #include "pca.h"     // 包含头文件
   4          #include "flowmeter.h" // 添加flowmeter.h以获取FLOW_MODE_OFF定义
   5          
   6          #define FOSC    11059200L
   7          #define T100Hz  (FOSC / 12 / 100)
   8          #define T1000Hz (FOSC / 12 / 1000)
   9          
  10          // typedef unsigned char BYTE;
  11          // typedef unsigned int WORD;
  12          
  13          /*Declare SFR associated with the PCA */
  14          sfr CCON        =   0xD8;           //PCA control register
  15          sbit CCF0       =   CCON^0;         //PCA module-0 interrupt flag
  16          sbit CCF1       =   CCON^1;         //PCA module-1 interrupt flag
  17          sbit CR         =   CCON^6;         //PCA timer run control bit
  18          sbit CF         =   CCON^7;         //PCA timer overflow flag
  19          sfr CMOD        =   0xD9;           //PCA mode register
  20          sfr CL          =   0xE9;           //PCA base timer LOW
  21          sfr CH          =   0xF9;           //PCA base timer HIGH
  22          sfr CCAPM0      =   0xDA;           //PCA module-0 mode register
  23          sfr CCAP0L      =   0xEA;           //PCA module-0 capture register LOW
  24          sfr CCAP0H      =   0xFA;           //PCA module-0 capture register HIGH
  25          sfr CCAPM1      =   0xDB;           //PCA module-1 mode registers
  26          sfr CCAP1L      =   0xEB;           //PCA module-1 capture register LOW
  27          sfr CCAP1H      =   0xFB;           //PCA module-1 capture register HIGH
  28          sfr PCAPWM0     =   0xf2;
  29          sfr PCAPWM1     =   0xf3;
  30          
  31          sbit PCA_LED    =   P1^0;           //PCA test LED
  32          
  33          BYTE cnt;
  34          WORD value;
  35          WORD value1;
  36          
  37          
  38          
  39          SYS_PARAMS SysPara1 = {0, 0, 0};    // 初始化系统参数
  40          
  41          // 显示相关引脚定义
  42          sbit DATA = DISP_PORT^0;  // 串行数据输入
  43          sbit SCK  = DISP_PORT^1;  // 移位时钟
  44          sbit RCK  = DISP_PORT^2;  // 存储时钟
  45          sbit OE   = DISP_PORT^3;  // 输出使能(低有效)
  46          
  47          /* 共阴极数码管段码定义 */
  48          static code const unsigned char LED[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
  49          
  50          // 显示缓冲区
  51          unsigned char dispbuff[8] = {SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF};
  52          
  53          // 实现显示相关函数
  54          void delay_ms(unsigned int ms) {
C51 COMPILER V9.54   PCA                                                                   05/25/2025 14:34:34 PAGE 2   

  55   1          unsigned int i, j;
  56   1          for (i = 0; i < ms; i++)
  57   1              for (j = 0; j < 120; j++);
  58   1      }
  59          
  60          // void SendTo595(unsigned char data_seg, unsigned char data_bit) {
  61          //     unsigned char i;
  62          //     OE = 1;
  63              
  64          //     for(i = 0; i < 8; i++) {
  65          //         DATA = (data_bit & 0x80) ? 1 : 0;
  66          //         SCK = 0; SCK = 1;
  67          //         data_bit <<= 1;
  68          //     }
  69              
  70          //     for(i = 0; i < 8; i++) {
  71          //         DATA = (data_seg & 0x80) ? 1 : 0;
  72          //         SCK = 0; SCK = 1;
  73          //         data_seg <<= 1;
  74          //     }
  75              
  76          //     RCK = 0; RCK = 1;
  77          //     OE = 0;
  78          //     delay_ms(1);
  79          // }
  80          
  81          void Resetdispbuff() {
  82   1          unsigned char i;
  83   1          for(i = 0; i < 8; i++) dispbuff[i] = SEG_OFF;
  84   1      }
  85          
  86          void FillDispBuf(BYTE hour, BYTE min, BYTE sec) {
  87   1          Resetdispbuff();
  88   1          // 秒部分（右起0-1位）
  89   1          dispbuff[0] = LED[sec % 10]; // 秒个位
  90   1          dispbuff[1] = LED[sec / 10]; // 秒十位
  91   1          
  92   1          // 分钟部分（右起2-3位）
  93   1          dispbuff[2] = LED[min % 10];
  94   1          dispbuff[3] = LED[min / 10];
  95   1          
  96   1          // 小时部分（右起4-5位）
  97   1          dispbuff[4] = LED[hour % 10];
  98   1          dispbuff[5] = LED[hour / 10];
  99   1      }
 100          
 101          // 自定义显示缓冲区填充函数
 102          void FillCustomDispBuf(BYTE val1, BYTE val2, BYTE val3, BYTE val4, BYTE val5, BYTE val6) {
 103   1          Resetdispbuff();
 104   1          
 105   1          // 填充6个数字位
 106   1          dispbuff[0] = LED[val1];
 107   1          dispbuff[1] = LED[val2];
 108   1          dispbuff[2] = LED[val3];
 109   1          dispbuff[3] = LED[val4];
 110   1          dispbuff[4] = LED[val5];
 111   1          dispbuff[5] = LED[val6];
 112   1      }
 113          
 114          void disp(void) {
 115   1          unsigned char i;
 116   1          static unsigned char pos = 0;  // 当前扫描的位置
C51 COMPILER V9.54   PCA                                                                   05/25/2025 14:34:34 PAGE 3   

 117   1          static unsigned char mark = 0x01;  // 位选掩码
 118   1          unsigned char tmpdata;
 119   1          
 120   1          // 设置输出使能为高，准备数据传输
 121   1          OE = 1;
 122   1          
 123   1          // 准备位选数据（低电平有效）
 124   1          tmpdata = ~mark;
 125   1          
 126   1          // 发送位选数据到74HC595
 127   1          for(i = 0; i < 8; i++) {
 128   2              // 从最高位开始发送
 129   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 130   2              SCK = 0;
 131   2              SCK = 1;
 132   2              tmpdata <<= 1;
 133   2          }
 134   1          
 135   1          // 发送段码数据到74HC595
 136   1          tmpdata = dispbuff[pos];
 137   1          for(i = 0; i < 8; i++) {
 138   2              // 从最高位开始发送
 139   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 140   2              SCK = 0;
 141   2              SCK = 1;
 142   2              tmpdata <<= 1;
 143   2          }
 144   1          
 145   1          // 锁存数据并输出
 146   1          RCK = 0;
 147   1          RCK = 1;
 148   1          
 149   1          // 使能输出
 150   1          OE = 0;
 151   1          
 152   1          // 移动到下一位
 153   1          pos = (pos + 1) % 8;
 154   1          mark = (mark << 1) | (mark >> 7);  // 循环左移
 155   1          if(mark == 0) mark = 0x01;  // 确保非零
 156   1      }
 157          
 158          void PCA_isr() interrupt 7
 159          {
 160   1          if(CCF1){
 161   2              CCF1 = 0;                       // Clear interrupt flag
 162   2              CCAP1L = value1;
 163   2              CCAP1H = value1 >> 8;           // Update compare value
 164   2              value1 += T1000Hz;
 165   2              disp();                         // 刷新显示
 166   2          }
 167   1      
 168   1          if(CCF0){
 169   2              CCF0 = 0;                       // Clear interrupt flag
 170   2              CCAP0L = value;
 171   2              CCAP0H = value >> 8;            // Update compare value
 172   2              value += T100Hz;
 173   2              cnt++;
 174   2              
 175   2              if(cnt >= 100) {                // Count 100 times
 176   3                  cnt = 0;                    // 1秒计时
 177   3                  PCA_LED = !PCA_LED;         // 闪烁LED指示灯
 178   3                  
C51 COMPILER V9.54   PCA                                                                   05/25/2025 14:34:34 PAGE 4   

 179   3                  // 调用流量计计算函数（不更新显示），改为更频繁调用
 180   3                  FlowMeter_CalcFlow();
 181   3                  
 182   3                  // 更新时钟，但不直接更新显示
 183   3                  SysPara1.sec++;
 184   3                  if(SysPara1.sec >= 60) {
 185   4                      SysPara1.sec = 0;
 186   4                      SysPara1.min++;
 187   4                      if(SysPara1.min >= 60) {
 188   5                          SysPara1.min = 0;
 189   5                          SysPara1.hour++;
 190   5                          if(SysPara1.hour >= 24)
 191   5                              SysPara1.hour = 0;
 192   5                      }
 193   4                  }
 194   3                  
 195   3                  // 只有在流量计模式为关闭时才更新时钟显示的缓冲区
 196   3                  if (FlowMeter_GetMode() == FLOW_MODE_OFF) {
 197   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 198   4                  }
 199   3              }
 200   2              else if(cnt % 20 == 0 && FlowMeter_GetMode() != FLOW_MODE_OFF) {
 201   3                  // 每0.2秒也调用一次流量计算，以减少刷新延迟
 202   3                  FlowMeter_CalcFlow();
 203   3              }
 204   2          }
 205   1      }
 206          
 207          void PCA_Init(void)
 208          {
 209   1          CCON = 0;                       // Initial PCA control register
 210   1                                          // PCA timer stop running
 211   1                                          // Clear CF flag
 212   1                                          // Clear all module interrupt flag
 213   1          CL = 0;                         // Reset PCA base timer
 214   1          CH = 0;
 215   1          CMOD = 0x00;                    // Set PCA timer clock source as Fosc/12
 216   1                                          // Disable PCA timer overflow interrupt
 217   1          
 218   1          // 初始化PCA模块1 (1000Hz)
 219   1          value1 = T1000Hz;
 220   1          CCAP1L = value1;
 221   1          CCAP1H = value1 >> 8;           // Initial PCA module-1
 222   1          value1 += T1000Hz;
 223   1          CCAPM1 = 0x49;                  // PCA module-1 work in 16-bit timer mode
 224   1                                          // and enable PCA interrupt
 225   1          
 226   1          // 初始化PCA模块0 (100Hz)
 227   1          value = T100Hz;
 228   1          CCAP0L = value;
 229   1          CCAP0H = value >> 8;            // Initial PCA module-0
 230   1          value += T100Hz;
 231   1          CCAPM0 = 0x49;                  // PCA module-0 work in 16-bit timer mode
 232   1                                          // and enable PCA interrupt
 233   1          
 234   1          CR = 1;                         // PCA timer start run
 235   1          EA = 1;                         // Enable global interrupt
 236   1          cnt = 0;
 237   1      
 238   1          // 初始化时钟显示
 239   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 240   1      }
C51 COMPILER V9.54   PCA                                                                   05/25/2025 14:34:34 PAGE 5   

 241          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    510    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
