C51 COMPILER V9.54   PCA                                                                   05/25/2025 13:39:53 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PCA
OBJECT MODULE PLACED IN .\Objects\pca.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE pca.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\pca.lst
                    -) OBJECT(.\Objects\pca.obj)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          #include "pca.h" // 包含头文件
   4          
   5          #define FOSC    11059200L
   6          #define T100Hz  (FOSC / 12 / 100)
   7          #define T1000Hz (FOSC / 12 / 1000)
   8          
   9          // typedef unsigned char BYTE;
  10          // typedef unsigned int WORD;
  11          
  12          /*Declare SFR associated with the PCA */
  13          sfr CCON        =   0xD8;           //PCA control register
  14          sbit CCF0       =   CCON^0;         //PCA module-0 interrupt flag
  15          sbit CCF1       =   CCON^1;         //PCA module-1 interrupt flag
  16          sbit CR         =   CCON^6;         //PCA timer run control bit
  17          sbit CF         =   CCON^7;         //PCA timer overflow flag
  18          sfr CMOD        =   0xD9;           //PCA mode register
  19          sfr CL          =   0xE9;           //PCA base timer LOW
  20          sfr CH          =   0xF9;           //PCA base timer HIGH
  21          sfr CCAPM0      =   0xDA;           //PCA module-0 mode register
  22          sfr CCAP0L      =   0xEA;           //PCA module-0 capture register LOW
  23          sfr CCAP0H      =   0xFA;           //PCA module-0 capture register HIGH
  24          sfr CCAPM1      =   0xDB;           //PCA module-1 mode registers
  25          sfr CCAP1L      =   0xEB;           //PCA module-1 capture register LOW
  26          sfr CCAP1H      =   0xFB;           //PCA module-1 capture register HIGH
  27          sfr PCAPWM0     =   0xf2;
  28          sfr PCAPWM1     =   0xf3;
  29          
  30          sbit PCA_LED    =   P1^0;           //PCA test LED
  31          
  32          BYTE cnt;
  33          WORD value;
  34          WORD value1;
  35          
  36          
  37          
  38          SYS_PARAMS SysPara1 = {0, 0, 0};    // 初始化系统参数
  39          
  40          // 显示相关引脚定义
  41          sbit DATA = DISP_PORT^0;  // 串行数据输入
  42          sbit SCK  = DISP_PORT^1;  // 移位时钟
  43          sbit RCK  = DISP_PORT^2;  // 存储时钟
  44          sbit OE   = DISP_PORT^3;  // 输出使能(低有效)
  45          
  46          /* 共阴极数码管段码定义 */
  47          static code const unsigned char LED[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
  48          
  49          // 显示缓冲区
  50          unsigned char dispbuff[8] = {SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF};
  51          
  52          // 实现显示相关函数
  53          void delay_ms(unsigned int ms) {
  54   1          unsigned int i, j;
C51 COMPILER V9.54   PCA                                                                   05/25/2025 13:39:53 PAGE 2   

  55   1          for (i = 0; i < ms; i++)
  56   1              for (j = 0; j < 120; j++);
  57   1      }
  58          
  59          // void SendTo595(unsigned char data_seg, unsigned char data_bit) {
  60          //     unsigned char i;
  61          //     OE = 1;
  62              
  63          //     for(i = 0; i < 8; i++) {
  64          //         DATA = (data_bit & 0x80) ? 1 : 0;
  65          //         SCK = 0; SCK = 1;
  66          //         data_bit <<= 1;
  67          //     }
  68              
  69          //     for(i = 0; i < 8; i++) {
  70          //         DATA = (data_seg & 0x80) ? 1 : 0;
  71          //         SCK = 0; SCK = 1;
  72          //         data_seg <<= 1;
  73          //     }
  74              
  75          //     RCK = 0; RCK = 1;
  76          //     OE = 0;
  77          //     delay_ms(1);
  78          // }
  79          
  80          void Resetdispbuff() {
  81   1          unsigned char i;
  82   1          for(i = 0; i < 8; i++) dispbuff[i] = SEG_OFF;
  83   1      }
  84          
  85          void FillDispBuf(BYTE hour, BYTE min, BYTE sec) {
  86   1          Resetdispbuff();
  87   1          // 秒部分（右起0-1位）
  88   1          dispbuff[0] = LED[sec % 10]; // 秒个位
  89   1          dispbuff[1] = LED[sec / 10]; // 秒十位
  90   1          
  91   1          // 分钟部分（右起2-3位）
  92   1          dispbuff[2] = LED[min % 10];
  93   1          dispbuff[3] = LED[min / 10];
  94   1          
  95   1          // 小时部分（右起4-5位）
  96   1          dispbuff[4] = LED[hour % 10];
  97   1          dispbuff[5] = LED[hour / 10];
  98   1      }
  99          
 100          void disp(void) {
 101   1          unsigned char i;
 102   1          static unsigned char pos = 0;  // 当前扫描的位置
 103   1          static unsigned char mark = 0x01;  // 位选掩码
 104   1          unsigned char tmpdata;
 105   1          
 106   1          // 设置输出使能为高，准备数据传输
 107   1          OE = 1;
 108   1          
 109   1          // 准备位选数据（低电平有效）
 110   1          tmpdata = ~mark;
 111   1          
 112   1          // 发送位选数据到74HC595
 113   1          for(i = 0; i < 8; i++) {
 114   2              // 从最高位开始发送
 115   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 116   2              SCK = 0;
C51 COMPILER V9.54   PCA                                                                   05/25/2025 13:39:53 PAGE 3   

 117   2              SCK = 1;
 118   2              tmpdata <<= 1;
 119   2          }
 120   1          
 121   1          // 发送段码数据到74HC595
 122   1          tmpdata = dispbuff[pos];
 123   1          for(i = 0; i < 8; i++) {
 124   2              // 从最高位开始发送
 125   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 126   2              SCK = 0;
 127   2              SCK = 1;
 128   2              tmpdata <<= 1;
 129   2          }
 130   1          
 131   1          // 锁存数据并输出
 132   1          RCK = 0;
 133   1          RCK = 1;
 134   1          
 135   1          // 使能输出
 136   1          OE = 0;
 137   1          
 138   1          // 移动到下一位
 139   1          pos = (pos + 1) % 8;
 140   1          mark = (mark << 1) | (mark >> 7);  // 循环左移
 141   1          if(mark == 0) mark = 0x01;  // 确保非零
 142   1      }
 143          
 144          void PCA_isr() interrupt 7
 145          {
 146   1          if(CCF1){
 147   2              CCF1 = 0;                       // Clear interrupt flag
 148   2              CCAP1L = value1;
 149   2              CCAP1H = value1 >> 8;           // Update compare value
 150   2              value1 += T1000Hz;
 151   2              disp();                         // 刷新显示
 152   2          }
 153   1      
 154   1          if(CCF0){
 155   2              CCF0 = 0;                       // Clear interrupt flag
 156   2              CCAP0L = value;
 157   2              CCAP0H = value >> 8;            // Update compare value
 158   2              value += T100Hz;
 159   2              cnt++;
 160   2              
 161   2              if(cnt >= 100) {                // Count 100 times
 162   3                  cnt = 0;                    // 1秒计时
 163   3                  PCA_LED = !PCA_LED;         // 闪烁LED指示灯
 164   3                  
 165   3                  SysPara1.sec++;
 166   3                  if(SysPara1.sec >= 60) {
 167   4                      SysPara1.sec = 0;
 168   4                      SysPara1.min++;
 169   4                      if(SysPara1.min >= 60) {
 170   5                          SysPara1.min = 0;
 171   5                          SysPara1.hour++;
 172   5                          if(SysPara1.hour >= 24)
 173   5                              SysPara1.hour = 0;
 174   5                      }
 175   4                  }
 176   3                  
 177   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 178   3              }
C51 COMPILER V9.54   PCA                                                                   05/25/2025 13:39:53 PAGE 4   

 179   2          }
 180   1      }
 181          
 182          void PCA_Init(void)
 183          {
 184   1          CCON = 0;                       // Initial PCA control register
 185   1                                          // PCA timer stop running
 186   1                                          // Clear CF flag
 187   1                                          // Clear all module interrupt flag
 188   1          CL = 0;                         // Reset PCA base timer
 189   1          CH = 0;
 190   1          CMOD = 0x00;                    // Set PCA timer clock source as Fosc/12
 191   1                                          // Disable PCA timer overflow interrupt
 192   1          
 193   1          // 初始化PCA模块1 (1000Hz)
 194   1          value1 = T1000Hz;
 195   1          CCAP1L = value1;
 196   1          CCAP1H = value1 >> 8;           // Initial PCA module-1
 197   1          value1 += T1000Hz;
 198   1          CCAPM1 = 0x49;                  // PCA module-1 work in 16-bit timer mode
 199   1                                          // and enable PCA interrupt
 200   1          
 201   1          // 初始化PCA模块0 (100Hz)
 202   1          value = T100Hz;
 203   1          CCAP0L = value;
 204   1          CCAP0H = value >> 8;            // Initial PCA module-0
 205   1          value += T100Hz;
 206   1          CCAPM0 = 0x49;                  // PCA module-0 work in 16-bit timer mode
 207   1                                          // and enable PCA interrupt
 208   1          
 209   1          CR = 1;                         // PCA timer start run
 210   1          EA = 1;                         // Enable global interrupt
 211   1          cnt = 0;
 212   1      
 213   1          // 初始化时钟显示
 214   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 215   1      }
 216          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    431    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
