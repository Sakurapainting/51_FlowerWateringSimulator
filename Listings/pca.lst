C51 COMPILER V9.54   PCA                                                                   05/26/2025 21:55:47 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PCA
OBJECT MODULE PLACED IN .\Objects\pca.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE pca.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\pca.lst
                    -) OBJECT(.\Objects\pca.obj)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          #include "pca.h"     // åŒ…å«å¤´æ–‡ä»¶
   4          #include "flowmeter.h" // æ·»åŠ flowmeter.hä»¥è·å–FLOW_MODE_OFFå®šä¹‰
   5          #include "keyboard_control.h" // æ·»åŠ æŒ‰é”®æ§åˆ¶å¤´æ–‡ä»¶
   6          
   7          #define FOSC    11059200L
   8          #define T100Hz  (FOSC / 12 / 100)
   9          #define T1000Hz (FOSC / 12 / 1000)
  10          
  11          // typedef unsigned char BYTE;
  12          // typedef unsigned int WORD;
  13          
  14          /*Declare SFR associated with the PCA */
  15          sfr CCON        =   0xD8;           //PCA control register
  16          sbit CCF0       =   CCON^0;         //PCA module-0 interrupt flag
  17          sbit CCF1       =   CCON^1;         //PCA module-1 interrupt flag
  18          sbit CR         =   CCON^6;         //PCA timer run control bit
  19          sbit CF         =   CCON^7;         //PCA timer overflow flag
  20          sfr CMOD        =   0xD9;           //PCA mode register
  21          sfr CL          =   0xE9;           //PCA base timer LOW
  22          sfr CH          =   0xF9;           //PCA base timer HIGH
  23          sfr CCAPM0      =   0xDA;           //PCA module-0 mode register
  24          sfr CCAP0L      =   0xEA;           //PCA module-0 capture register LOW
  25          sfr CCAP0H      =   0xFA;           //PCA module-0 capture register HIGH
  26          sfr CCAPM1      =   0xDB;           //PCA module-1 mode registers
  27          sfr CCAP1L      =   0xEB;           //PCA module-1 capture register LOW
  28          sfr CCAP1H      =   0xFB;           //PCA module-1 capture register HIGH
  29          sfr PCAPWM0     =   0xf2;
  30          sfr PCAPWM1     =   0xf3;
  31          
  32          sbit PCA_LED    =   P1^0;           //PCA test LED
  33          
  34          BYTE cnt;
  35          WORD value;
  36          WORD value1;
  37          
  38          
  39          
  40          SYS_PARAMS SysPara1 = {0, 0, 0};    // åˆå§‹åŒ–ç³»ç»Ÿå‚æ•°
  41          
  42          // æ˜¾ç¤ºç›¸å…³å¼•è„šå®šä¹‰
  43          sbit DATA = DISP_PORT^0;  // ä¸²è¡Œæ•°æ®è¾“å…¥
  44          sbit SCK  = DISP_PORT^1;  // ç§»ä½æ—¶é’Ÿ
  45          sbit RCK  = DISP_PORT^2;  // å­˜å‚¨æ—¶é’Ÿ
  46          sbit OE   = DISP_PORT^3;  // è¾“å‡ºä½¿èƒ½(ä½æœ‰æ•ˆ)
  47          
  48          #define CURRENTFLOW_MODE 0x39 // å½“å‰æµé‡æ¨¡å¼
  49          #define TOTALFLOW_MODE 0X71   // ç´¯è®¡æµé‡æ¨¡å¼
  50          
  51          /* å…±é˜´ææ•°ç ç®¡æ®µç å®šä¹‰ */
  52          static code const unsigned char LED[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,CURRENTFLOW_MOD
             -E,TOTALFLOW_MODE};
  53          
C51 COMPILER V9.54   PCA                                                                   05/26/2025 21:55:47 PAGE 2   

  54          // æ˜¾ç¤ºç¼“å†²åŒº
  55          unsigned char dispbuff[8] = {SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF};
  56          
  57          // å®ç°æ˜¾ç¤ºç›¸å…³å‡½æ•°
  58          void delay_ms(unsigned int ms) {
  59   1          unsigned int i, j;
  60   1          for (i = 0; i < ms; i++)
  61   1              for (j = 0; j < 120; j++);
  62   1      }
  63          
  64          // void SendTo595(unsigned char data_seg, unsigned char data_bit) {
  65          //     unsigned char i;
  66          //     OE = 1;
  67              
  68          //     for(i = 0; i < 8; i++) {
  69          //         DATA = (data_bit & 0x80) ? 1 : 0;
  70          //         SCK = 0; SCK = 1;
  71          //         data_bit <<= 1;
  72          //     }
  73              
  74          //     for(i = 0; i < 8; i++) {
  75          //         DATA = (data_seg & 0x80) ? 1 : 0;
  76          //         SCK = 0; SCK = 1;
  77          //         data_seg <<= 1;
  78          //     }
  79              
  80          //     RCK = 0; RCK = 1;
  81          //     OE = 0;
  82          //     delay_ms(1);
  83          // }
  84          
  85          void Resetdispbuff() {
  86   1          unsigned char i;
  87   1          for(i = 0; i < 8; i++) dispbuff[i] = SEG_OFF;
  88   1      }
  89          
  90          void FillDispBuf(BYTE hour, BYTE min, BYTE sec) {
  91   1          Resetdispbuff();
  92   1          // ç§’éƒ¨åˆ†ï¼ˆå³èµ·0-1ä½ï¼‰
  93   1          dispbuff[0] = LED[sec % 10]; // ç§’ä¸ªä½
  94   1          dispbuff[1] = LED[sec / 10]; // ç§’åä½
  95   1          
  96   1          // åˆ†é’Ÿéƒ¨åˆ†ï¼ˆå³èµ·2-3ä½ï¼‰
  97   1          dispbuff[2] = LED[min % 10];
  98   1          dispbuff[3] = LED[min / 10];
  99   1          
 100   1          // å°æ—¶éƒ¨åˆ†ï¼ˆå³èµ·4-5ä½ï¼‰
 101   1          dispbuff[4] = LED[hour % 10];
 102   1          dispbuff[5] = LED[hour / 10];
 103   1      }
 104          
 105          // è‡ªå®šä¹‰æ˜¾ç¤ºç¼“å†²åŒºå¡«å……å‡½æ•°
 106          void FillCustomDispBuf(BYTE val1, BYTE val2, BYTE val3, BYTE val4, BYTE val5, BYTE val6) {
 107   1          Resetdispbuff();
 108   1          
 109   1          // å¡«å……6ä¸ªæ•°å­—ä½
 110   1          dispbuff[0] = LED[val1];
 111   1          dispbuff[1] = LED[val2];
 112   1          dispbuff[2] = LED[val3];
 113   1          dispbuff[3] = LED[val4];
 114   1          dispbuff[4] = LED[val5];
 115   1          dispbuff[5] = LED[val6];
C51 COMPILER V9.54   PCA                                                                   05/26/2025 21:55:47 PAGE 3   

 116   1      }
 117          
 118          void disp(void) {
 119   1          unsigned char i;
 120   1          static unsigned char pos = 0;  // å½“å‰æ‰«æçš„ä½ç½®
 121   1          static unsigned char mark = 0x01;  // ä½é€‰æ©ç 
 122   1          unsigned char tmpdata;
 123   1          
 124   1          // è®¾ç½®è¾“å‡ºä½¿èƒ½ä¸ºé«˜ï¼Œå‡†å¤‡æ•°æ®ä¼ è¾“
 125   1          OE = 1;
 126   1          
 127   1          // å‡†å¤‡ä½é€‰æ•°æ®ï¼ˆä½ç”µå¹³æœ‰æ•ˆï¼‰
 128   1          tmpdata = ~mark;
 129   1          
 130   1          // å‘é€ä½é€‰æ•°æ®åˆ°74HC595
 131   1          for(i = 0; i < 8; i++) {
 132   2              // ä»æœ€é«˜ä½å¼€å§‹å‘é€
 133   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 134   2              SCK = 0;
 135   2              SCK = 1;
 136   2              tmpdata <<= 1;
 137   2          }
 138   1          
 139   1          // å‘é€æ®µç æ•°æ®åˆ°74HC595
 140   1          tmpdata = dispbuff[pos];
 141   1          for(i = 0; i < 8; i++) {
 142   2              // ä»æœ€é«˜ä½å¼€å§‹å‘é€
 143   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 144   2              SCK = 0;
 145   2              SCK = 1;
 146   2              tmpdata <<= 1;
 147   2          }
 148   1          
 149   1          // é”å­˜æ•°æ®å¹¶è¾“å‡º
 150   1          RCK = 0;
 151   1          RCK = 1;
 152   1          
 153   1          // ä½¿èƒ½è¾“å‡º
 154   1          OE = 0;
 155   1          
 156   1          // ç§»åŠ¨åˆ°ä¸‹ä¸€ä½
 157   1          pos = (pos + 1) % 8;
 158   1          mark = (mark << 1) | (mark >> 7);  // å¾ªç¯å·¦ç§»
 159   1          if(mark == 0) mark = 0x01;  // ç¡®ä¿éé›¶
 160   1      }
 161          
 162          // æ—¶é—´ç¼–è¾‘ç›¸å…³å˜é‡
 163          static BYTE timeEditMode = 0;  // 0: æ­£å¸¸æ˜¾ç¤º, 1: ç¼–è¾‘å°æ—¶, 2: ç¼–è¾‘åˆ†é’Ÿ, 3: ç¼–è¾‘ç§’
 164          static BYTE blinkState = 0;    // é—ªçƒçŠ¶æ€: 0 æ˜¾ç¤º, 1 ä¸æ˜¾ç¤º
 165          
 166          // è®¾ç½®æ—¶é—´ç¼–è¾‘æ¨¡å¼
 167          void PCA_SetTimeEditMode(BYTE position) {
 168   1          timeEditMode = position;
 169   1          blinkState = 0;  // å¼€å§‹æ—¶å¤„äºæ˜¾ç¤ºçŠ¶æ€
 170   1      }
 171          
 172          // é€€å‡ºæ—¶é—´ç¼–è¾‘æ¨¡å¼
 173          void PCA_ExitTimeEditMode(void) {
 174   1          timeEditMode = 0;
 175   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 176   1      }
 177          
C51 COMPILER V9.54   PCA                                                                   05/26/2025 21:55:47 PAGE 4   

 178          // å¢åŠ æ—¶é—´å€¼
 179          void PCA_IncreaseTimeValue(BYTE position) {
 180   1          switch (position) {
 181   2              case HOUR_POS:
 182   2                  SysPara1.hour = (SysPara1.hour + 1) % 24;
 183   2                  break;
 184   2              case MIN_POS:
 185   2                  SysPara1.min = (SysPara1.min + 1) % 60;
 186   2                  break;
 187   2              case SEC_POS:
 188   2                  SysPara1.sec = (SysPara1.sec + 1) % 60;
 189   2                  break;
 190   2          }
 191   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 192   1      }
 193          
 194          // ç›´æ¥è®¾ç½®æ—¶é—´å‡½æ•°
 195          void PCA_SetTime(BYTE hour, BYTE min, BYTE sec) {
 196   1          // éªŒè¯è¾“å…¥æ—¶é—´æ˜¯å¦æœ‰æ•ˆ
 197   1          if(hour < 24 && min < 60 && sec < 60) {
 198   2              SysPara1.hour = hour;
 199   2              SysPara1.min = min;
 200   2              SysPara1.sec = sec;
 201   2              
 202   2              // ğŸ’¡ æ–°å¢ï¼šæ—¶é—´ä¿®æ”¹åé‡æ–°è®¡ç®—ä»Šæ—¥è§¦å‘æ ‡å¿—
 203   2              if(timed_watering.enabled) {
 204   3                  // é‡æ–°åˆ¤æ–­ä»Šå¤©çš„æµ‡æ°´æ—¶é—´æ˜¯å¦å·²è¿‡
 205   3                  if(SysPara1.hour > timed_watering.start_hour || 
 206   3                     (SysPara1.hour == timed_watering.start_hour && SysPara1.min > timed_watering.start_min) ||
 207   3                     (SysPara1.hour == timed_watering.start_hour && SysPara1.min == timed_watering.start_min && 
             -SysPara1.sec > timed_watering.start_sec)) {
 208   4                      timed_watering.triggered_today = 1;  // ä»Šå¤©çš„æµ‡æ°´æ—¶é—´å·²è¿‡
 209   4                  } else {
 210   4                      timed_watering.triggered_today = 0;  // ä»Šå¤©çš„æµ‡æ°´æ—¶é—´è¿˜æ²¡åˆ°ï¼Œå¯ä»¥è§¦å‘
 211   4                  }
 212   3                  
 213   3                  // ä¿å­˜æ›´æ–°åçš„çŠ¶æ€
 214   3                  TimedWatering_SaveParams();
 215   3              }
 216   2              
 217   2              // å¦‚æœå½“å‰æ˜¯æ—¶é’Ÿæ˜¾ç¤ºæ¨¡å¼ï¼Œæ›´æ–°æ˜¾ç¤º
 218   2              if(FlowMeter_GetMode() == FLOW_MODE_OFF && timeEditMode == 0) {
 219   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 220   3              }
 221   2          }
 222   1      }
 223          
 224          // ä¿®æ”¹PCAä¸­æ–­æœåŠ¡å‡½æ•°ï¼Œç®€åŒ–æ˜¾ç¤ºé€»è¾‘
 225          void PCA_isr() interrupt 7
 226          {
 227   1          if(CCF1){
 228   2              CCF1 = 0;
 229   2              CCAP1L = value1;
 230   2              CCAP1H = value1 >> 8;
 231   2              value1 += T1000Hz;
 232   2              disp();
 233   2          }
 234   1      
 235   1          if(CCF0){
 236   2              CCF0 = 0;
 237   2              CCAP0L = value;
 238   2              CCAP0H = value >> 8;
C51 COMPILER V9.54   PCA                                                                   05/26/2025 21:55:47 PAGE 5   

 239   2              value += T100Hz;
 240   2              cnt++;
 241   2              
 242   2              if(cnt >= 100) {
 243   3                  cnt = 0;
 244   3                  PCA_LED = !PCA_LED;
 245   3                  
 246   3                  // ç¡®ä¿æ¯1ç§’è°ƒç”¨ä¸€æ¬¡æµé‡è®¡ç®—
 247   3                  FlowMeter_CalcFlow();  // æ¯ç§’è°ƒç”¨ä¸€æ¬¡ï¼Œç»Ÿè®¡è¿‡å»1ç§’çš„è„‰å†²æ•°
 248   3                  
 249   3                  // æ›´æ–°æ—¶é’Ÿ
 250   3                  SysPara1.sec++;
 251   3                  if(SysPara1.sec >= 60) {
 252   4                      SysPara1.sec = 0;
 253   4                      SysPara1.min++;
 254   4                      if(SysPara1.min >= 60) {
 255   5                          SysPara1.min = 0;
 256   5                          SysPara1.hour++;
 257   5                          if(SysPara1.hour >= 24)
 258   5                              SysPara1.hour = 0;
 259   5                      }
 260   4                  }
 261   3                  
 262   3                  // æ›´æ–°å®šæ—¶æµ‡æ°´çŠ¶æ€ - ç¡®ä¿åœ¨æ—¶é’Ÿæ›´æ–°åç«‹å³è°ƒç”¨
 263   3                  TimedWatering_Update();
 264   3                  
 265   3                  // æ—¶é—´ç¼–è¾‘æ¨¡å¼é—ªçƒæ§åˆ¶
 266   3                  if (timeEditMode > 0) {
 267   4                      blinkState = !blinkState;
 268   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 269   4                      
 270   4                      if (blinkState) {
 271   5                          switch (timeEditMode) {
 272   6                              case HOUR_POS:
 273   6                                  dispbuff[4] = SEG_OFF;
 274   6                                  dispbuff[5] = SEG_OFF;
 275   6                                  break;
 276   6                              case MIN_POS:
 277   6                                  dispbuff[2] = SEG_OFF;
 278   6                                  dispbuff[3] = SEG_OFF;
 279   6                                  break;
 280   6                              case SEC_POS:
 281   6                                  dispbuff[0] = SEG_OFF;
 282   6                                  dispbuff[1] = SEG_OFF;
 283   6                                  break;
 284   6                          }
 285   5                      }
 286   4                  }
 287   3                  // æ ¹æ®æ˜¾ç¤ºæ¨¡å¼æ›´æ–°æ˜¾ç¤ºç¼“å†²åŒº
 288   3                  else if (FlowMeter_GetMode() == FLOW_MODE_OFF) {
 289   4                      // æ—¶é’Ÿæ˜¾ç¤ºæ¨¡å¼ï¼šæ˜¾ç¤ºå½“å‰æ—¶é—´
 290   4                      if(auto_display_mode == DISPLAY_MODE_CLOCK) {
 291   5                          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 292   5                      }
 293   4                      // è‡ªåŠ¨æµ‡æ°´å‚æ•°æ˜¾ç¤ºæ¨¡å¼ï¼šè®¾ç½®æ›´æ–°æ ‡å¿—
 294   4                      else if(auto_display_mode == DISPLAY_MODE_AUTO) {
 295   5                          display_update_flag = 1;  // è®¾ç½®æ ‡å¿—ï¼Œåœ¨ä¸»å¾ªç¯ä¸­æ›´æ–°æ˜¾ç¤º
 296   5                      }
 297   4                  }
 298   3              }
 299   2              else if(cnt % 50 == 0 && timeEditMode > 0) {
 300   3                  blinkState = !blinkState;
C51 COMPILER V9.54   PCA                                                                   05/26/2025 21:55:47 PAGE 6   

 301   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 302   3                  
 303   3                  if (blinkState) {
 304   4                      switch (timeEditMode) {
 305   5                          case HOUR_POS:
 306   5                              dispbuff[4] = SEG_OFF;
 307   5                              dispbuff[5] = SEG_OFF;
 308   5                              break;
 309   5                          case MIN_POS:
 310   5                              dispbuff[2] = SEG_OFF;
 311   5                              dispbuff[3] = SEG_OFF;
 312   5                              break;
 313   5                          case SEC_POS:
 314   5                              dispbuff[0] = SEG_OFF;
 315   5                              dispbuff[1] = SEG_OFF;
 316   5                              break;
 317   5                      }
 318   4                  }
 319   3              }
 320   2          }
 321   1      }
 322          
 323          void PCA_Init(void)
 324          {
 325   1          CCON = 0;                       // Initial PCA control register
 326   1                                          // PCA timer stop running
 327   1                                          // Clear CF flag
 328   1                                          // Clear all module interrupt flag
 329   1          CL = 0;                         // Reset PCA base timer
 330   1          CH = 0;
 331   1          CMOD = 0x00;                    // Set PCA timer clock source as Fosc/12
 332   1                                          // Disable PCA timer overflow interrupt
 333   1          
 334   1          // åˆå§‹åŒ–PCAæ¨¡å—1 (1000Hz)
 335   1          value1 = T1000Hz;
 336   1          CCAP1L = value1;
 337   1          CCAP1H = value1 >> 8;           // Initial PCA module-1
 338   1          value1 += T1000Hz;
 339   1          CCAPM1 = 0x49;                  // PCA module-1 work in 16-bit timer mode
 340   1                                          // and enable PCA interrupt
 341   1          
 342   1          // åˆå§‹åŒ–PCAæ¨¡å—0 (100Hz)
 343   1          value = T100Hz;
 344   1          CCAP0L = value;
 345   1          CCAP0H = value >> 8;            // Initial PCA module-0
 346   1          value += T100Hz;
 347   1          CCAPM0 = 0x49;                  // PCA module-0 work in 16-bit timer mode
 348   1                                          // and enable PCA interrupt
 349   1          
 350   1          CR = 1;                         // PCA timer start run
 351   1          EA = 1;                         // Enable global interrupt
 352   1          cnt = 0;
 353   1      
 354   1          // åˆå§‹åŒ–æ—¶é’Ÿæ˜¾ç¤º
 355   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 356   1      }
 357          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    807    ----
   CONSTANT SIZE    =     12    ----
C51 COMPILER V9.54   PCA                                                                   05/26/2025 21:55:47 PAGE 7   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
