C51 COMPILER V9.54   PCA                                                                   05/27/2025 19:12:08 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PCA
OBJECT MODULE PLACED IN .\Objects\pca.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE pca.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\pca.lst
                    -) OBJECT(.\Objects\pca.obj)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          #include "pca.h"     // 包含头文件
   4          #include "flowmeter.h" // 添加flowmeter.h以获取FLOW_MODE_OFF定义
   5          #include "keyboard_control.h" // 添加按键控制头文件
   6          
   7          #define FOSC    11059200L
   8          #define T100Hz  (FOSC / 12 / 100)
   9          #define T1000Hz (FOSC / 12 / 1000)
  10          
  11          // typedef unsigned char BYTE;
  12          // typedef unsigned int WORD;
  13          
  14          /*Declare SFR associated with the PCA */
  15          sfr CCON        =   0xD8;           //PCA control register
  16          sbit CCF0       =   CCON^0;         //PCA module-0 interrupt flag
  17          sbit CCF1       =   CCON^1;         //PCA module-1 interrupt flag
  18          sbit CR         =   CCON^6;         //PCA timer run control bit
  19          sbit CF         =   CCON^7;         //PCA timer overflow flag
  20          sfr CMOD        =   0xD9;           //PCA mode register
  21          sfr CL          =   0xE9;           //PCA base timer LOW
  22          sfr CH          =   0xF9;           //PCA base timer HIGH
  23          sfr CCAPM0      =   0xDA;           //PCA module-0 mode register
  24          sfr CCAP0L      =   0xEA;           //PCA module-0 capture register LOW
  25          sfr CCAP0H      =   0xFA;           //PCA module-0 capture register HIGH
  26          sfr CCAPM1      =   0xDB;           //PCA module-1 mode registers
  27          sfr CCAP1L      =   0xEB;           //PCA module-1 capture register LOW
  28          sfr CCAP1H      =   0xFB;           //PCA module-1 capture register HIGH
  29          sfr PCAPWM0     =   0xf2;
  30          sfr PCAPWM1     =   0xf3;
  31          
  32          sbit PCA_LED    =   P1^0;           //PCA test LED
  33          
  34          BYTE cnt;
  35          WORD value;
  36          WORD value1;
  37          
  38          
  39          
  40          SYS_PARAMS SysPara1 = {0, 0, 0};    // 初始化系统参数
  41          
  42          // 显示相关引脚定义
  43          sbit DATA = DISP_PORT^0;  // 串行数据输入
  44          sbit SCK  = DISP_PORT^1;  // 移位时钟
  45          sbit RCK  = DISP_PORT^2;  // 存储时钟
  46          sbit OE   = DISP_PORT^3;  // 输出使能(低有效)
  47          
  48          #define CURRENTFLOW_MODE 0x39 // 当前流量模式
  49          #define TOTALFLOW_MODE 0X71   // 累计流量模式
  50          
  51          /* 共阴极数码管段码定义 */
  52          static code const unsigned char LED[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,CURRENTFLOW_MOD
             -E,TOTALFLOW_MODE};
  53          
C51 COMPILER V9.54   PCA                                                                   05/27/2025 19:12:08 PAGE 2   

  54          // 显示缓冲区
  55          unsigned char xdata dispbuff[8] = {SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF};
  56          
  57          // 实现显示相关函数
  58          void delay_ms(unsigned int ms) {
  59   1          unsigned int i, j;
  60   1          for (i = 0; i < ms; i++)
  61   1              for (j = 0; j < 120; j++);
  62   1      }
  63          
  64          // void SendTo595(unsigned char data_seg, unsigned char data_bit) {
  65          //     unsigned char i;
  66          //     OE = 1;
  67              
  68          //     for(i = 0; i < 8; i++) {
  69          //         DATA = (data_bit & 0x80) ? 1 : 0;
  70          //         SCK = 0; SCK = 1;
  71          //         data_bit <<= 1;
  72          //     }
  73              
  74          //     for(i = 0; i < 8; i++) {
  75          //         DATA = (data_seg & 0x80) ? 1 : 0;
  76          //         SCK = 0; SCK = 1;
  77          //         data_seg <<= 1;
  78          //     }
  79              
  80          //     RCK = 0; RCK = 1;
  81          //     OE = 0;
  82          //     delay_ms(1);
  83          // }
  84          
  85          void Resetdispbuff() {
  86   1          unsigned char i;
  87   1          for(i = 0; i < 8; i++) dispbuff[i] = SEG_OFF;
  88   1      }
  89          
  90          void FillDispBuf(BYTE hour, BYTE min, BYTE sec) {
  91   1          Resetdispbuff();
  92   1          // 秒部分（右起0-1位）
  93   1          dispbuff[0] = LED[sec % 10]; // 秒个位
  94   1          dispbuff[1] = LED[sec / 10]; // 秒十位
  95   1          
  96   1          // 分钟部分（右起2-3位）
  97   1          dispbuff[2] = LED[min % 10];
  98   1          dispbuff[3] = LED[min / 10];
  99   1          
 100   1          // 小时部分（右起4-5位）
 101   1          dispbuff[4] = LED[hour % 10];
 102   1          dispbuff[5] = LED[hour / 10];
 103   1      }
 104          
 105          // 自定义显示缓冲区填充函数
 106          void FillCustomDispBuf(BYTE val1, BYTE val2, BYTE val3, BYTE val4, BYTE val5, BYTE val6) {
 107   1          Resetdispbuff();
 108   1          
 109   1          // 填充6个数字位
 110   1          dispbuff[0] = LED[val1];
 111   1          dispbuff[1] = LED[val2];
 112   1          dispbuff[2] = LED[val3];
 113   1          dispbuff[3] = LED[val4];
 114   1          dispbuff[4] = LED[val5];
 115   1          dispbuff[5] = LED[val6];
C51 COMPILER V9.54   PCA                                                                   05/27/2025 19:12:08 PAGE 3   

 116   1      }
 117          
 118          void disp(void) {
 119   1          unsigned char i;
 120   1          static unsigned char pos = 0;  // 当前扫描的位置
 121   1          static unsigned char mark = 0x01;  // 位选掩码
 122   1          unsigned char tmpdata;
 123   1          
 124   1          // 设置输出使能为高，准备数据传输
 125   1          OE = 1;
 126   1          
 127   1          // 准备位选数据（低电平有效）
 128   1          tmpdata = ~mark;
 129   1          
 130   1          // 发送位选数据到74HC595
 131   1          for(i = 0; i < 8; i++) {
 132   2              // 从最高位开始发送
 133   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 134   2              SCK = 0;
 135   2              SCK = 1;
 136   2              tmpdata <<= 1;
 137   2          }
 138   1          
 139   1          // 发送段码数据到74HC595
 140   1          tmpdata = dispbuff[pos];
 141   1          for(i = 0; i < 8; i++) {
 142   2              // 从最高位开始发送
 143   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 144   2              SCK = 0;
 145   2              SCK = 1;
 146   2              tmpdata <<= 1;
 147   2          }
 148   1          
 149   1          // 锁存数据并输出
 150   1          RCK = 0;
 151   1          RCK = 1;
 152   1          
 153   1          // 使能输出
 154   1          OE = 0;
 155   1          
 156   1          // 移动到下一位
 157   1          pos = (pos + 1) % 8;
 158   1          mark = (mark << 1) | (mark >> 7);  // 循环左移
 159   1          if(mark == 0) mark = 0x01;  // 确保非零
 160   1      }
 161          
 162          // 时间编辑相关变量
 163          static BYTE timeEditMode = 0;  // 0: 正常显示, 1: 编辑小时, 2: 编辑分钟, 3: 编辑秒
 164          static BYTE blinkState = 0;    // 闪烁状态: 0 显示, 1 不显示
 165          
 166          // 设置时间编辑模式
 167          void PCA_SetTimeEditMode(BYTE position) {
 168   1          timeEditMode = position;
 169   1          blinkState = 0;  // 开始时处于显示状态
 170   1      }
 171          
 172          // 退出时间编辑模式
 173          void PCA_ExitTimeEditMode(void) {
 174   1          timeEditMode = 0;
 175   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 176   1      }
 177          
C51 COMPILER V9.54   PCA                                                                   05/27/2025 19:12:08 PAGE 4   

 178          // 增加时间值
 179          void PCA_IncreaseTimeValue(BYTE position) {
 180   1          switch (position) {
 181   2              case HOUR_POS:
 182   2                  SysPara1.hour = (SysPara1.hour + 1) % 24;
 183   2                  break;
 184   2              case MIN_POS:
 185   2                  SysPara1.min = (SysPara1.min + 1) % 60;
 186   2                  break;
 187   2              case SEC_POS:
 188   2                  SysPara1.sec = (SysPara1.sec + 1) % 60;
 189   2                  break;
 190   2          }
 191   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 192   1      }
 193          
 194          // 直接设置时间函数
 195          void PCA_SetTime(BYTE hour, BYTE min, BYTE sec) {
 196   1          // 验证输入时间是否有效
 197   1          if(hour < 24 && min < 60 && sec < 60) {
 198   2              SysPara1.hour = hour;
 199   2              SysPara1.min = min;
 200   2              SysPara1.sec = sec;
 201   2              
 202   2              // 时间修改后重新计算今日触发标志（不保存到24C02）
 203   2              if(timed_watering.enabled) {
 204   3                  // 重新判断今天的浇水时间是否已过
 205   3                  if(SysPara1.hour > timed_watering.start_hour || 
 206   3                     (SysPara1.hour == timed_watering.start_hour && SysPara1.min > timed_watering.start_min) ||
 207   3                     (SysPara1.hour == timed_watering.start_hour && SysPara1.min == timed_watering.start_min && 
             -SysPara1.sec > timed_watering.start_sec)) {
 208   4                      timed_watering.triggered_today = 1;  // 今天的浇水时间已过
 209   4                  } else {
 210   4                      timed_watering.triggered_today = 0;  // 今天的浇水时间还没到，可以触发
 211   4                  }
 212   3                  
 213   3                  // 移除保存调用
 214   3                  // TimedWatering_SaveParams();
 215   3              }
 216   2              
 217   2              // 如果当前是时钟显示模式，更新显示
 218   2              if(FlowMeter_GetMode() == FLOW_MODE_OFF && timeEditMode == 0) {
 219   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 220   3              }
 221   2          }
 222   1      }
 223          
 224          // 修改PCA中断服务函数，简化显示逻辑
 225          void PCA_isr() interrupt 7
 226          {
 227   1          if(CCF1){
 228   2              CCF1 = 0;
 229   2              CCAP1L = value1;
 230   2              CCAP1H = value1 >> 8;
 231   2              value1 += T1000Hz;
 232   2              disp();
 233   2          }
 234   1      
 235   1          if(CCF0){
 236   2              CCF0 = 0;
 237   2              CCAP0L = value;
 238   2              CCAP0H = value >> 8;
C51 COMPILER V9.54   PCA                                                                   05/27/2025 19:12:08 PAGE 5   

 239   2              value += T100Hz;
 240   2              cnt++;
 241   2              
 242   2              if(cnt >= 100) {
 243   3                  cnt = 0;
 244   3                  PCA_LED = !PCA_LED;
 245   3                  
 246   3                  // 确保每1秒调用一次流量计算
 247   3                  FlowMeter_CalcFlow();  // 每秒调用一次，统计过去1秒的脉冲数
 248   3                  
 249   3                  // 更新时钟
 250   3                  SysPara1.sec++;
 251   3                  if(SysPara1.sec >= 60) {
 252   4                      SysPara1.sec = 0;
 253   4                      SysPara1.min++;
 254   4                      if(SysPara1.min >= 60) {
 255   5                          SysPara1.min = 0;
 256   5                          SysPara1.hour++;
 257   5                          if(SysPara1.hour >= 24)
 258   5                              SysPara1.hour = 0;
 259   5                      }
 260   4                  }
 261   3                  
 262   3                  // 更新定时浇水状态 - 确保在时钟更新后立即调用
 263   3                  TimedWatering_Update();
 264   3                  
 265   3                  // 时间编辑模式闪烁控制
 266   3                  if (timeEditMode > 0) {
 267   4                      blinkState = !blinkState;
 268   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 269   4                      
 270   4                      if (blinkState) {
 271   5                          switch (timeEditMode) {
 272   6                              case HOUR_POS:
 273   6                                  dispbuff[4] = SEG_OFF;
 274   6                                  dispbuff[5] = SEG_OFF;
 275   6                                  break;
 276   6                              case MIN_POS:
 277   6                                  dispbuff[2] = SEG_OFF;
 278   6                                  dispbuff[3] = SEG_OFF;
 279   6                                  break;
 280   6                              case SEC_POS:
 281   6                                  dispbuff[0] = SEG_OFF;
 282   6                                  dispbuff[1] = SEG_OFF;
 283   6                                  break;
 284   6                          }
 285   5                      }
 286   4                  }
 287   3                  // 根据显示模式更新显示缓冲区
 288   3                  else if (FlowMeter_GetMode() == FLOW_MODE_OFF) {
 289   4                      // 时钟显示模式：显示当前时间
 290   4                      if(auto_display_mode == DISPLAY_MODE_CLOCK) {
 291   5                          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 292   5                      }
 293   4                      // 自动浇水参数显示模式：设置更新标志
 294   4                      else if(auto_display_mode == DISPLAY_MODE_AUTO) {
 295   5                          display_update_flag = 1;  // 设置标志，在主循环中更新显示
 296   5                      }
 297   4                  }
 298   3              }
 299   2              else if(cnt % 50 == 0 && timeEditMode > 0) {
 300   3                  blinkState = !blinkState;
C51 COMPILER V9.54   PCA                                                                   05/27/2025 19:12:08 PAGE 6   

 301   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 302   3                  
 303   3                  if (blinkState) {
 304   4                      switch (timeEditMode) {
 305   5                          case HOUR_POS:
 306   5                              dispbuff[4] = SEG_OFF;
 307   5                              dispbuff[5] = SEG_OFF;
 308   5                              break;
 309   5                          case MIN_POS:
 310   5                              dispbuff[2] = SEG_OFF;
 311   5                              dispbuff[3] = SEG_OFF;
 312   5                              break;
 313   5                          case SEC_POS:
 314   5                              dispbuff[0] = SEG_OFF;
 315   5                              dispbuff[1] = SEG_OFF;
 316   5                              break;
 317   5                      }
 318   4                  }
 319   3              }
 320   2          }
 321   1      }
 322          
 323          void PCA_Init(void)
 324          {
 325   1          CCON = 0;                       // Initial PCA control register
 326   1                                          // PCA timer stop running
 327   1                                          // Clear CF flag
 328   1                                          // Clear all module interrupt flag
 329   1          CL = 0;                         // Reset PCA base timer
 330   1          CH = 0;
 331   1          CMOD = 0x00;                    // Set PCA timer clock source as Fosc/12
 332   1                                          // Disable PCA timer overflow interrupt
 333   1          
 334   1          // 初始化PCA模块1 (1000Hz)
 335   1          value1 = T1000Hz;
 336   1          CCAP1L = value1;
 337   1          CCAP1H = value1 >> 8;           // Initial PCA module-1
 338   1          value1 += T1000Hz;
 339   1          CCAPM1 = 0x49;                  // PCA module-1 work in 16-bit timer mode
 340   1                                          // and enable PCA interrupt
 341   1          
 342   1          // 初始化PCA模块0 (100Hz)
 343   1          value = T100Hz;
 344   1          CCAP0L = value;
 345   1          CCAP0H = value >> 8;            // Initial PCA module-0
 346   1          value += T100Hz;
 347   1          CCAPM0 = 0x49;                  // PCA module-0 work in 16-bit timer mode
 348   1                                          // and enable PCA interrupt
 349   1          
 350   1          CR = 1;                         // PCA timer start run
 351   1          EA = 1;                         // Enable global interrupt
 352   1          cnt = 0;
 353   1      
 354   1          // 初始化时钟显示
 355   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 356   1      }
 357          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    875    ----
   CONSTANT SIZE    =     12    ----
C51 COMPILER V9.54   PCA                                                                   05/27/2025 19:12:08 PAGE 7   

   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
