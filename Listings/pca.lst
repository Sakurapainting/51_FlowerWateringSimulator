C51 COMPILER V9.54   PCA                                                                   05/25/2025 17:00:44 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PCA
OBJECT MODULE PLACED IN .\Objects\pca.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE pca.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\pca.lst
                    -) OBJECT(.\Objects\pca.obj)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          #include "pca.h"     // ÂåÖÂê´Â§¥Êñá‰ª∂
   4          #include "flowmeter.h" // Ê∑ªÂä†flowmeter.h‰ª•Ëé∑ÂèñFLOW_MODE_OFFÂÆö‰πâ
   5          
   6          #define FOSC    11059200L
   7          #define T100Hz  (FOSC / 12 / 100)
   8          #define T1000Hz (FOSC / 12 / 1000)
   9          
  10          // typedef unsigned char BYTE;
  11          // typedef unsigned int WORD;
  12          
  13          /*Declare SFR associated with the PCA */
  14          sfr CCON        =   0xD8;           //PCA control register
  15          sbit CCF0       =   CCON^0;         //PCA module-0 interrupt flag
  16          sbit CCF1       =   CCON^1;         //PCA module-1 interrupt flag
  17          sbit CR         =   CCON^6;         //PCA timer run control bit
  18          sbit CF         =   CCON^7;         //PCA timer overflow flag
  19          sfr CMOD        =   0xD9;           //PCA mode register
  20          sfr CL          =   0xE9;           //PCA base timer LOW
  21          sfr CH          =   0xF9;           //PCA base timer HIGH
  22          sfr CCAPM0      =   0xDA;           //PCA module-0 mode register
  23          sfr CCAP0L      =   0xEA;           //PCA module-0 capture register LOW
  24          sfr CCAP0H      =   0xFA;           //PCA module-0 capture register HIGH
  25          sfr CCAPM1      =   0xDB;           //PCA module-1 mode registers
  26          sfr CCAP1L      =   0xEB;           //PCA module-1 capture register LOW
  27          sfr CCAP1H      =   0xFB;           //PCA module-1 capture register HIGH
  28          sfr PCAPWM0     =   0xf2;
  29          sfr PCAPWM1     =   0xf3;
  30          
  31          sbit PCA_LED    =   P1^0;           //PCA test LED
  32          
  33          BYTE cnt;
  34          WORD value;
  35          WORD value1;
  36          
  37          
  38          
  39          SYS_PARAMS SysPara1 = {0, 0, 0};    // ÂàùÂßãÂåñÁ≥ªÁªüÂèÇÊï∞
  40          
  41          // ÊòæÁ§∫Áõ∏ÂÖ≥ÂºïËÑöÂÆö‰πâ
  42          sbit DATA = DISP_PORT^0;  // ‰∏≤Ë°åÊï∞ÊçÆËæìÂÖ•
  43          sbit SCK  = DISP_PORT^1;  // Áßª‰ΩçÊó∂Èíü
  44          sbit RCK  = DISP_PORT^2;  // Â≠òÂÇ®Êó∂Èíü
  45          sbit OE   = DISP_PORT^3;  // ËæìÂá∫‰ΩøËÉΩ(‰ΩéÊúâÊïà)
  46          
  47          #define CURRENTFLOW_MODE 0x39 // ÂΩìÂâçÊµÅÈáèÊ®°Âºè
  48          #define TOTALFLOW_MODE 0X71   // Á¥ØËÆ°ÊµÅÈáèÊ®°Âºè
  49          
  50          /* ÂÖ±Èò¥ÊûÅÊï∞Á†ÅÁÆ°ÊÆµÁ†ÅÂÆö‰πâ */
  51          static code const unsigned char LED[] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,CURRENTFLOW_MOD
             -E,TOTALFLOW_MODE};
  52          
  53          // ÊòæÁ§∫ÁºìÂÜ≤Âå∫
C51 COMPILER V9.54   PCA                                                                   05/25/2025 17:00:44 PAGE 2   

  54          unsigned char dispbuff[8] = {SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF,SEG_OFF};
  55          
  56          // ÂÆûÁé∞ÊòæÁ§∫Áõ∏ÂÖ≥ÂáΩÊï∞
  57          void delay_ms(unsigned int ms) {
  58   1          unsigned int i, j;
  59   1          for (i = 0; i < ms; i++)
  60   1              for (j = 0; j < 120; j++);
  61   1      }
  62          
  63          // void SendTo595(unsigned char data_seg, unsigned char data_bit) {
  64          //     unsigned char i;
  65          //     OE = 1;
  66              
  67          //     for(i = 0; i < 8; i++) {
  68          //         DATA = (data_bit & 0x80) ? 1 : 0;
  69          //         SCK = 0; SCK = 1;
  70          //         data_bit <<= 1;
  71          //     }
  72              
  73          //     for(i = 0; i < 8; i++) {
  74          //         DATA = (data_seg & 0x80) ? 1 : 0;
  75          //         SCK = 0; SCK = 1;
  76          //         data_seg <<= 1;
  77          //     }
  78              
  79          //     RCK = 0; RCK = 1;
  80          //     OE = 0;
  81          //     delay_ms(1);
  82          // }
  83          
  84          void Resetdispbuff() {
  85   1          unsigned char i;
  86   1          for(i = 0; i < 8; i++) dispbuff[i] = SEG_OFF;
  87   1      }
  88          
  89          void FillDispBuf(BYTE hour, BYTE min, BYTE sec) {
  90   1          Resetdispbuff();
  91   1          // ÁßíÈÉ®ÂàÜÔºàÂè≥Ëµ∑0-1‰ΩçÔºâ
  92   1          dispbuff[0] = LED[sec % 10]; // Áßí‰∏™‰Ωç
  93   1          dispbuff[1] = LED[sec / 10]; // ÁßíÂçÅ‰Ωç
  94   1          
  95   1          // ÂàÜÈíüÈÉ®ÂàÜÔºàÂè≥Ëµ∑2-3‰ΩçÔºâ
  96   1          dispbuff[2] = LED[min % 10];
  97   1          dispbuff[3] = LED[min / 10];
  98   1          
  99   1          // Â∞èÊó∂ÈÉ®ÂàÜÔºàÂè≥Ëµ∑4-5‰ΩçÔºâ
 100   1          dispbuff[4] = LED[hour % 10];
 101   1          dispbuff[5] = LED[hour / 10];
 102   1      }
 103          
 104          // Ëá™ÂÆö‰πâÊòæÁ§∫ÁºìÂÜ≤Âå∫Â°´ÂÖÖÂáΩÊï∞
 105          void FillCustomDispBuf(BYTE val1, BYTE val2, BYTE val3, BYTE val4, BYTE val5, BYTE val6) {
 106   1          Resetdispbuff();
 107   1          
 108   1          // Â°´ÂÖÖ6‰∏™Êï∞Â≠ó‰Ωç
 109   1          dispbuff[0] = LED[val1];
 110   1          dispbuff[1] = LED[val2];
 111   1          dispbuff[2] = LED[val3];
 112   1          dispbuff[3] = LED[val4];
 113   1          dispbuff[4] = LED[val5];
 114   1          dispbuff[5] = LED[val6];
 115   1      }
C51 COMPILER V9.54   PCA                                                                   05/25/2025 17:00:44 PAGE 3   

 116          
 117          void disp(void) {
 118   1          unsigned char i;
 119   1          static unsigned char pos = 0;  // ÂΩìÂâçÊâ´ÊèèÁöÑ‰ΩçÁΩÆ
 120   1          static unsigned char mark = 0x01;  // ‰ΩçÈÄâÊé©Á†Å
 121   1          unsigned char tmpdata;
 122   1          
 123   1          // ËÆæÁΩÆËæìÂá∫‰ΩøËÉΩ‰∏∫È´òÔºåÂáÜÂ§áÊï∞ÊçÆ‰º†Ëæì
 124   1          OE = 1;
 125   1          
 126   1          // ÂáÜÂ§á‰ΩçÈÄâÊï∞ÊçÆÔºà‰ΩéÁîµÂπ≥ÊúâÊïàÔºâ
 127   1          tmpdata = ~mark;
 128   1          
 129   1          // ÂèëÈÄÅ‰ΩçÈÄâÊï∞ÊçÆÂà∞74HC595
 130   1          for(i = 0; i < 8; i++) {
 131   2              // ‰ªéÊúÄÈ´ò‰ΩçÂºÄÂßãÂèëÈÄÅ
 132   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 133   2              SCK = 0;
 134   2              SCK = 1;
 135   2              tmpdata <<= 1;
 136   2          }
 137   1          
 138   1          // ÂèëÈÄÅÊÆµÁ†ÅÊï∞ÊçÆÂà∞74HC595
 139   1          tmpdata = dispbuff[pos];
 140   1          for(i = 0; i < 8; i++) {
 141   2              // ‰ªéÊúÄÈ´ò‰ΩçÂºÄÂßãÂèëÈÄÅ
 142   2              DATA = (tmpdata & 0x80) ? 1 : 0;
 143   2              SCK = 0;
 144   2              SCK = 1;
 145   2              tmpdata <<= 1;
 146   2          }
 147   1          
 148   1          // ÈîÅÂ≠òÊï∞ÊçÆÂπ∂ËæìÂá∫
 149   1          RCK = 0;
 150   1          RCK = 1;
 151   1          
 152   1          // ‰ΩøËÉΩËæìÂá∫
 153   1          OE = 0;
 154   1          
 155   1          // ÁßªÂä®Âà∞‰∏ã‰∏Ä‰Ωç
 156   1          pos = (pos + 1) % 8;
 157   1          mark = (mark << 1) | (mark >> 7);  // Âæ™ÁéØÂ∑¶Áßª
 158   1          if(mark == 0) mark = 0x01;  // Á°Æ‰øùÈùûÈõ∂
 159   1      }
 160          
 161          // Êó∂Èó¥ÁºñËæëÁõ∏ÂÖ≥ÂèòÈáè
 162          static BYTE timeEditMode = 0;  // 0: Ê≠£Â∏∏ÊòæÁ§∫, 1: ÁºñËæëÂ∞èÊó∂, 2: ÁºñËæëÂàÜÈíü, 3: ÁºñËæëÁßí
 163          static BYTE blinkState = 0;    // Èó™ÁÉÅÁä∂ÊÄÅ: 0 ÊòæÁ§∫, 1 ‰∏çÊòæÁ§∫
 164          
 165          // ËÆæÁΩÆÊó∂Èó¥ÁºñËæëÊ®°Âºè
 166          void PCA_SetTimeEditMode(BYTE position) {
 167   1          timeEditMode = position;
 168   1          blinkState = 0;  // ÂºÄÂßãÊó∂Â§Ñ‰∫éÊòæÁ§∫Áä∂ÊÄÅ
 169   1      }
 170          
 171          // ÈÄÄÂá∫Êó∂Èó¥ÁºñËæëÊ®°Âºè
 172          void PCA_ExitTimeEditMode(void) {
 173   1          timeEditMode = 0;
 174   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 175   1      }
 176          
 177          // Â¢ûÂä†Êó∂Èó¥ÂÄº
C51 COMPILER V9.54   PCA                                                                   05/25/2025 17:00:44 PAGE 4   

 178          void PCA_IncreaseTimeValue(BYTE position) {
 179   1          switch (position) {
 180   2              case HOUR_POS:
 181   2                  SysPara1.hour = (SysPara1.hour + 1) % 24;
 182   2                  break;
 183   2              case MIN_POS:
 184   2                  SysPara1.min = (SysPara1.min + 1) % 60;
 185   2                  break;
 186   2              case SEC_POS:
 187   2                  SysPara1.sec = (SysPara1.sec + 1) % 60;
 188   2                  break;
 189   2          }
 190   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 191   1      }
 192          
 193          // ‰øÆÊîπPCA‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞ÔºåÂä†ÂÖ•Èó™ÁÉÅÂ§ÑÁêÜÈÄªËæë
 194          void PCA_isr() interrupt 7
 195          {
 196   1          if(CCF1){
 197   2              CCF1 = 0;                       // Clear interrupt flag
 198   2              CCAP1L = value1;
 199   2              CCAP1H = value1 >> 8;           // Update compare value
 200   2              value1 += T1000Hz;
 201   2              disp();                         // Âà∑Êñ∞ÊòæÁ§∫
 202   2          }
 203   1      
 204   1          if(CCF0){
 205   2              CCF0 = 0;                       // Clear interrupt flag
 206   2              CCAP0L = value;
 207   2              CCAP0H = value >> 8;            // Update compare value
 208   2              value += T100Hz;
 209   2              cnt++;
 210   2              
 211   2              if(cnt >= 100) {                // Count 100 times
 212   3                  cnt = 0;                    // 1ÁßíËÆ°Êó∂
 213   3                  PCA_LED = !PCA_LED;         // Èó™ÁÉÅLEDÊåáÁ§∫ÁÅØ
 214   3                  
 215   3                  // Ë∞ÉÁî®ÊµÅÈáèËÆ°ËÆ°ÁÆóÂáΩÊï∞Ôºà‰∏çÊõ¥Êñ∞ÊòæÁ§∫ÔºâÔºåÊîπ‰∏∫Êõ¥È¢ëÁπÅË∞ÉÁî®
 216   3                  FlowMeter_CalcFlow();
 217   3                  
 218   3                  // Êõ¥Êñ∞Êó∂ÈíüÔºå‰ΩÜ‰∏çÁõ¥Êé•Êõ¥Êñ∞ÊòæÁ§∫
 219   3                  SysPara1.sec++;
 220   3                  if(SysPara1.sec >= 60) {
 221   4                      SysPara1.sec = 0;
 222   4                      SysPara1.min++;
 223   4                      if(SysPara1.min >= 60) {
 224   5                          SysPara1.min = 0;
 225   5                          SysPara1.hour++;
 226   5                          if(SysPara1.hour >= 24)
 227   5                              SysPara1.hour = 0;
 228   5                      }
 229   4                  }
 230   3                  
 231   3                  // Êó∂Èó¥ÁºñËæëÊ®°ÂºèÈó™ÁÉÅÊéßÂà∂ (ÊØèÁßíÂàáÊç¢‰∏ÄÊ¨°)
 232   3                  if (timeEditMode > 0) {
 233   4                      blinkState = !blinkState;
 234   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 235   4                      
 236   4                      // Ê†πÊçÆÁºñËæëÊ®°ÂºèÂíåÈó™ÁÉÅÁä∂ÊÄÅÔºåËÆæÁΩÆÁõ∏Â∫î‰Ωç‰∏∫‰∏çÊòæÁ§∫
 237   4                      if (blinkState) {
 238   5                          switch (timeEditMode) {
 239   6                              case HOUR_POS:  // ÁºñËæëÂ∞èÊó∂
C51 COMPILER V9.54   PCA                                                                   05/25/2025 17:00:44 PAGE 5   

 240   6                                  dispbuff[4] = SEG_OFF;
 241   6                                  dispbuff[5] = SEG_OFF;
 242   6                                  break;
 243   6                              case MIN_POS:  // ÁºñËæëÂàÜÈíü
 244   6                                  dispbuff[2] = SEG_OFF;
 245   6                                  dispbuff[3] = SEG_OFF;
 246   6                                  break;
 247   6                              case SEC_POS:  // ÁºñËæëÁßí
 248   6                                  dispbuff[0] = SEG_OFF;
 249   6                                  dispbuff[1] = SEG_OFF;
 250   6                                  break;
 251   6                          }
 252   5                      }
 253   4                  }
 254   3                  
 255   3                  // Âè™ÊúâÂú®ÊµÅÈáèËÆ°Ê®°Âºè‰∏∫ÂÖ≥Èó≠‰∏î‰∏çÂú®Êó∂Èó¥ÁºñËæëÊ®°ÂºèÊó∂ÊâçÊõ¥Êñ∞Êó∂ÈíüÊòæÁ§∫ÁöÑÁºìÂ
             -Ü≤Âå∫
 256   3                  else if (FlowMeter_GetMode() == FLOW_MODE_OFF) {
 257   4                      FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 258   4                  }
 259   3              }
 260   2              else if(cnt % 20 == 0 && FlowMeter_GetMode() != FLOW_MODE_OFF) {
 261   3                  // ÊØè0.2Áßí‰πüË∞ÉÁî®‰∏ÄÊ¨°ÊµÅÈáèËÆ°ÁÆóÔºå‰ª•ÂáèÂ∞ëÂà∑Êñ∞Âª∂Ëøü
 262   3                  FlowMeter_CalcFlow();
 263   3              }
 264   2              else if(cnt % 50 == 0 && timeEditMode > 0) {
 265   3                  // Âú®Êó∂Èó¥ÁºñËæëÊ®°Âºè‰∏ãÔºåÊØè0.5ÁßíÂàáÊç¢‰∏ÄÊ¨°Èó™ÁÉÅÁä∂ÊÄÅ
 266   3                  blinkState = !blinkState;
 267   3                  FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 268   3                  
 269   3                  // Ê†πÊçÆÁºñËæëÊ®°ÂºèÂíåÈó™ÁÉÅÁä∂ÊÄÅÔºåËÆæÁΩÆÁõ∏Â∫î‰Ωç‰∏∫‰∏çÊòæÁ§∫
 270   3                  if (blinkState) {
 271   4                      switch (timeEditMode) {
 272   5                          case HOUR_POS:  // ÁºñËæëÂ∞èÊó∂
 273   5                              dispbuff[4] = SEG_OFF;
 274   5                              dispbuff[5] = SEG_OFF;
 275   5                              break;
 276   5                          case MIN_POS:  // ÁºñËæëÂàÜÈíü
 277   5                              dispbuff[2] = SEG_OFF;
 278   5                              dispbuff[3] = SEG_OFF;
 279   5                              break;
 280   5                          case SEC_POS:  // ÁºñËæëÁßí
 281   5                              dispbuff[0] = SEG_OFF;
 282   5                              dispbuff[1] = SEG_OFF;
 283   5                              break;
 284   5                      }
 285   4                  }
 286   3              }
 287   2          }
 288   1      }
 289          
 290          void PCA_Init(void)
 291          {
 292   1          CCON = 0;                       // Initial PCA control register
 293   1                                          // PCA timer stop running
 294   1                                          // Clear CF flag
 295   1                                          // Clear all module interrupt flag
 296   1          CL = 0;                         // Reset PCA base timer
 297   1          CH = 0;
 298   1          CMOD = 0x00;                    // Set PCA timer clock source as Fosc/12
 299   1                                          // Disable PCA timer overflow interrupt
 300   1          
C51 COMPILER V9.54   PCA                                                                   05/25/2025 17:00:44 PAGE 6   

 301   1          // ÂàùÂßãÂåñPCAÊ®°Âùó1 (1000Hz)
 302   1          value1 = T1000Hz;
 303   1          CCAP1L = value1;
 304   1          CCAP1H = value1 >> 8;           // Initial PCA module-1
 305   1          value1 += T1000Hz;
 306   1          CCAPM1 = 0x49;                  // PCA module-1 work in 16-bit timer mode
 307   1                                          // and enable PCA interrupt
 308   1          
 309   1          // ÂàùÂßãÂåñPCAÊ®°Âùó0 (100Hz)
 310   1          value = T100Hz;
 311   1          CCAP0L = value;
 312   1          CCAP0H = value >> 8;            // Initial PCA module-0
 313   1          value += T100Hz;
 314   1          CCAPM0 = 0x49;                  // PCA module-0 work in 16-bit timer mode
 315   1                                          // and enable PCA interrupt
 316   1          
 317   1          CR = 1;                         // PCA timer start run
 318   1          EA = 1;                         // Enable global interrupt
 319   1          cnt = 0;
 320   1      
 321   1          // ÂàùÂßãÂåñÊó∂ÈíüÊòæÁ§∫
 322   1          FillDispBuf(SysPara1.hour, SysPara1.min, SysPara1.sec);
 323   1      }
 324          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    723    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
