C51 COMPILER V9.54   UART                                                                  05/25/2025 20:50:47 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\uart.l
                    -st) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "uart.h"
   2          #include "flowmeter.h"  // 添加这行以引入FlowMeter_GetMode()和FLOW_MODE_OFF
   3          #include <string.h>
   4          
   5          // 串口缓冲区及状态变量
   6          static char uart_buffer[UART_BUF_SIZE];  // 串口接收缓冲区
   7          static BYTE uart_count = 0;              // 当前缓冲区计数
   8          static bit uart_complete = 0;            // 接收完成标志
   9          
  10          // 初始化串口
  11          void UART_Init(void) {
  12   1          SCON = 0x50;    // 设置串口工作方式1，8位UART，可变波特率，REN=1允许接收
  13   1          PCON &= 0x7F;   // SMOD=0，波特率不加倍
  14   1          
  15   1          // 使用定时器1作为波特率发生器
  16   1          TMOD &= 0x0F;   // 清除T1的设置位
  17   1          TMOD |= 0x20;   // 设置T1为模式2（8位自动重载）
  18   1          
  19   1          // 9600波特率设置 (针对11.0592MHz晶振)
  20   1          TL1 = 0xFD;     // 设置初值
  21   1          TH1 = 0xFD;     // 设置重载值
  22   1          
  23   1          TR1 = 1;        // 启动定时器1
  24   1          ES = 1;         // 使能串口中断
  25   1          EA = 1;         // 使能总中断
  26   1          
  27   1          // 初始化缓冲区
  28   1          uart_count = 0;
  29   1          uart_complete = 0;
  30   1          memset(uart_buffer, 0, sizeof(uart_buffer));
  31   1          
  32   1          // 发送初始提示信息
  33   1          UART_SendString("\r\n============================\r\n");
  34   1          UART_SendString(" 浇花系统串口控制界面 \r\n");
  35   1          UART_SendString("============================\r\n");
  36   1          UART_SendString("命令格式: TIME:HH:MM:SS\r\n");
  37   1          UART_SendString("例如: TIME:14:30:00\r\n");
  38   1      }
  39          
  40          // 发送一个字节
  41          void UART_SendByte(BYTE dat) {
  42   1          SBUF = dat;             // 将数据写入发送缓冲区
  43   1          while(!TI);             // 等待发送完成
  44   1          TI = 0;                 // 清除发送中断标志
  45   1      }
  46          
  47          // 发送字符串
  48          void UART_SendString(char *s) {
  49   1          while(*s) {             // 发送字符串，直到遇到null结束符
  50   2              UART_SendByte(*s++);
  51   2          }
  52   1      }
  53          
  54          // 命令处理函数
C51 COMPILER V9.54   UART                                                                  05/25/2025 20:50:47 PAGE 2   

  55          static void UART_CommandHandler(void) {
  56   1          // 命令格式: "TIME:HH:MM:SS"
  57   1          if(strncmp(uart_buffer, "TIME:", 5) == 0) {
  58   2              BYTE hour = 0, min = 0, sec = 0;
  59   2              
  60   2              // 解析时间
  61   2              if(strlen(uart_buffer) >= 13) { // 确保格式正确且长度足够
  62   3                  hour = (uart_buffer[5] - '0') * 10 + (uart_buffer[6] - '0');
  63   3                  min = (uart_buffer[8] - '0') * 10 + (uart_buffer[9] - '0');
  64   3                  sec = (uart_buffer[11] - '0') * 10 + (uart_buffer[12] - '0');
  65   3                  
  66   3                  // 检查时间值是否有效
  67   3                  if(hour < 24 && min < 60 && sec < 60) {
  68   4                      // 直接修改SysPara1中的时间值
  69   4                      PCA_SetTime(hour, min, sec);
  70   4                      
  71   4                      UART_SendString("\r\n时间设置成功: ");
  72   4                      // 发送时间字符串
  73   4                      uart_buffer[7] = ':';
  74   4                      uart_buffer[10] = ':';
  75   4                      uart_buffer[13] = 0;
  76   4                      UART_SendString(uart_buffer + 5);
  77   4                      UART_SendString("\r\n");
  78   4                  }
  79   3                  else {
  80   4                      UART_SendString("\r\n错误: 无效的时间值\r\n");
  81   4                      UART_SendString("时间格式: HH(0-23):MM(0-59):SS(0-59)\r\n");
  82   4                  }
  83   3              }
  84   2              else {
  85   3                  UART_SendString("\r\n错误: 时间格式错误\r\n");
  86   3                  UART_SendString("正确格式: TIME:HH:MM:SS\r\n");
  87   3                  UART_SendString("例如: TIME:14:30:00\r\n");
  88   3              }
  89   2          }
  90   1          else {
  91   2              UART_SendString("\r\n错误: 未知命令\r\n");
  92   2              UART_SendString("支持的命令: TIME:HH:MM:SS\r\n");
  93   2          }
  94   1      }
  95          
  96          // 处理串口命令
  97          void UART_ProcessCommand(void) {
  98   1          if(uart_complete) {
  99   2              UART_CommandHandler();
 100   2              uart_complete = 0;
 101   2              uart_count = 0;
 102   2              memset(uart_buffer, 0, sizeof(uart_buffer));
 103   2          }
 104   1      }
 105          
 106          // 串口中断服务函数
 107          void UART_ISR() interrupt 4 {
 108   1          if(RI) {                // 接收中断
 109   2              RI = 0;             // 清除接收中断标志
 110   2              
 111   2              if(!uart_complete) { // 如果前一条命令还没处理完，则忽略当前接收的字符
 112   3                  char ch = SBUF;  // 获取接收到的字符
 113   3                  
 114   3                  // 回显接收到的字符
 115   3                  UART_SendByte(ch);
 116   3                  
C51 COMPILER V9.54   UART                                                                  05/25/2025 20:50:47 PAGE 3   

 117   3                  if(ch == '\n' || ch == '\r') { // 接收到回车或换行
 118   4                      uart_buffer[uart_count] = '\0';  // 字符串结束符
 119   4                      if (uart_count > 0) {  // 非空命令才进行处理
 120   5                          uart_complete = 1;  // 设置接收完成标志
 121   5                      }
 122   4                  }
 123   3                  else if(uart_count < UART_BUF_SIZE - 1) { // 缓冲区未满
 124   4                      uart_buffer[uart_count++] = ch;  // 存储接收到的字符
 125   4                  }
 126   3              }
 127   2          }
 128   1          
 129   1          if(TI) {                // 发送中断
 130   2              TI = 0;             // 清除发送中断标志
 131   2          }
 132   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    472    ----
   CONSTANT SIZE    =    378    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
