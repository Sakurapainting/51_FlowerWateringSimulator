C51 COMPILER V9.54   UART                                                                  05/28/2025 12:47:22 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\uart.l
                    -st) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "uart.h"
   2          #include "flowmeter.h"
   3          #include "keyboard_control.h"
   4          #include <string.h>
   5          
   6          // 串口缓冲区及状态变量
   7          static char xdata uart_buffer[32];  // 缓冲区大小
   8          static BYTE uart_count = 0;
   9          static bit uart_complete = 0;
  10          
  11          // 初始化串口
  12          void UART_Init(void) {
  13   1          SCON = 0x50;    // 设置串口工作方式1，8位UART，可变波特率，REN=1允许接收
  14   1          PCON &= 0x7F;   // SMOD=0，波特率不加倍
  15   1          
  16   1          // 使用定时器1作为波特率发生器
  17   1          TMOD &= 0x0F;   // 清除T1的设置位
  18   1          TMOD |= 0x20;   // 设置T1为模式2（8位自动重载）
  19   1          
  20   1          // 9600波特率设置 (针对11.0592MHz晶振)
  21   1          TL1 = 0xFD;     // 设置初值
  22   1          TH1 = 0xFD;     // 设置重载值
  23   1          
  24   1          TR1 = 1;        // 启动定时器1
  25   1          ES = 1;         // 使能串口中断
  26   1          EA = 1;         // 使能总中断
  27   1          
  28   1          // 初始化缓冲区
  29   1          uart_count = 0;
  30   1          uart_complete = 0;
  31   1          memset(uart_buffer, 0, sizeof(uart_buffer));
  32   1          
  33   1          // 发送启动信息（删除DATETIME命令说明）
  34   1          UART_SendString("\r\nWatering System Ready v2.1\r\n");
  35   1          UART_SendString("Commands Available:\r\n");
  36   1          UART_SendString("TIME:HH:MM:SS\r\n");
  37   1          UART_SendString("DATE:YYYY:MM:DD\r\n");
  38   1          UART_SendString("A:HH:MM:SS:MMMM\r\n");
  39   1          UART_SendString("DISPTIME/DISPDATE\r\n");
  40   1          UART_SendString("STOP\r\n");
  41   1      }
  42          
  43          // 发送一个字节
  44          void UART_SendByte(BYTE dat) {
  45   1          SBUF = dat;             // 将数据写入发送缓冲区
  46   1          while(!TI);             // 等待发送完成
  47   1          TI = 0;                 // 清除发送中断标志
  48   1      }
  49          
  50          // 发送字符串
  51          void UART_SendString(char *s) {
  52   1          while(*s) {             // 发送字符串，直到遇到null结束符
  53   2              UART_SendByte(*s++);
  54   2          }
C51 COMPILER V9.54   UART                                                                  05/28/2025 12:47:22 PAGE 2   

  55   1      }
  56          
  57          // 优化：内联数值输出，避免函数调用开销
  58          static void SendNumber(unsigned long num) {
  59   1          if(num == 0) {
  60   2              UART_SendByte('0');
  61   2              return;
  62   2          }
  63   1          
  64   1          // 直接计算并发送各位数字
  65   1          if(num >= 10000) UART_SendByte('0' + (num / 10000) % 10);
  66   1          if(num >= 1000) UART_SendByte('0' + (num / 1000) % 10);
  67   1          if(num >= 100) UART_SendByte('0' + (num / 100) % 10);
  68   1          if(num >= 10) UART_SendByte('0' + (num / 10) % 10);
  69   1          UART_SendByte('0' + num % 10);
  70   1      }
  71          
  72          // 优化：内联两位数输出
  73          static void Send2Digits(BYTE num) {
  74   1          UART_SendByte('0' + (num / 10));
  75   1          UART_SendByte('0' + (num % 10));
  76   1      }
  77          
  78          // 优化后的手动浇水记录输出 - 避免传参，直接访问全局变量
  79          void UART_SendManualWateringRecord(void) {
  80   1          UART_SendString("\r\n=== Watering Record ===\r\n");
  81   1          UART_SendString("Type: Manual Watering\r\n");
  82   1          
  83   1          // 开始时间 - 直接访问manual_watering_record
  84   1          UART_SendString("Start Time: 20");
  85   1          Send2Digits(manual_watering_record.start_year % 100);
  86   1          UART_SendByte('-');
  87   1          Send2Digits(manual_watering_record.start_month);
  88   1          UART_SendByte('-');
  89   1          Send2Digits(manual_watering_record.start_day);
  90   1          UART_SendByte(' ');
  91   1          Send2Digits(manual_watering_record.start_hour);
  92   1          UART_SendByte(':');
  93   1          Send2Digits(manual_watering_record.start_min);
  94   1          UART_SendByte(':');
  95   1          Send2Digits(manual_watering_record.start_sec);
  96   1          UART_SendString("\r\n");
  97   1          
  98   1          // 结束时间
  99   1          UART_SendString("End Time: 20");
 100   1          Send2Digits(manual_watering_record.end_year % 100);
 101   1          UART_SendByte('-');
 102   1          Send2Digits(manual_watering_record.end_month);
 103   1          UART_SendByte('-');
 104   1          Send2Digits(manual_watering_record.end_day);
 105   1          UART_SendByte(' ');
 106   1          Send2Digits(manual_watering_record.end_hour);
 107   1          UART_SendByte(':');
 108   1          Send2Digits(manual_watering_record.end_min);
 109   1          UART_SendByte(':');
 110   1          Send2Digits(manual_watering_record.end_sec);
 111   1          UART_SendString("\r\n");
 112   1          
 113   1          // 浇水量
 114   1          UART_SendString("Water Volume: ");
 115   1          SendNumber(manual_watering_record.water_volume);
 116   1          UART_SendString(" ml\r\n");
C51 COMPILER V9.54   UART                                                                  05/28/2025 12:47:22 PAGE 3   

 117   1          
 118   1          // 累计流量
 119   1          UART_SendString("Total Flow: ");
 120   1          SendNumber(manual_watering_record.total_flow);
 121   1          UART_SendString(" ml\r\n");
 122   1          
 123   1          // 持续时间 - 直接计算，避免传参
 124   1          UART_SendString("Duration: ");
 125   1          if(manual_watering_record.duration_min > 0) {
 126   2              SendNumber(manual_watering_record.duration_min);
 127   2              UART_SendString(" min ");
 128   2          }
 129   1          SendNumber(manual_watering_record.duration_sec);
 130   1          UART_SendString(" sec\r\n");
 131   1          
 132   1          UART_SendString("=======================\r\n");
 133   1      }
 134          
 135          // 优化后的自动浇水记录输出 - 避免传参，直接访问全局变量
 136          void UART_SendAutoWateringRecord(void) {
 137   1          UART_SendString("\r\n=== Watering Record ===\r\n");
 138   1          UART_SendString("Type: Auto Watering\r\n");
 139   1          
 140   1          // 开始时间 - 直接访问timed_watering.current_record
 141   1          UART_SendString("Start Time: 20");
 142   1          Send2Digits(timed_watering.current_record.start_year % 100);
 143   1          UART_SendByte('-');
 144   1          Send2Digits(timed_watering.current_record.start_month);
 145   1          UART_SendByte('-');
 146   1          Send2Digits(timed_watering.current_record.start_day);
 147   1          UART_SendByte(' ');
 148   1          Send2Digits(timed_watering.current_record.start_hour);
 149   1          UART_SendByte(':');
 150   1          Send2Digits(timed_watering.current_record.start_min);
 151   1          UART_SendByte(':');
 152   1          Send2Digits(timed_watering.current_record.start_sec);
 153   1          UART_SendString("\r\n");
 154   1          
 155   1          // 结束时间
 156   1          UART_SendString("End Time: 20");
 157   1          Send2Digits(timed_watering.current_record.end_year % 100);
 158   1          UART_SendByte('-');
 159   1          Send2Digits(timed_watering.current_record.end_month);
 160   1          UART_SendByte('-');
 161   1          Send2Digits(timed_watering.current_record.end_day);
 162   1          UART_SendByte(' ');
 163   1          Send2Digits(timed_watering.current_record.end_hour);
 164   1          UART_SendByte(':');
 165   1          Send2Digits(timed_watering.current_record.end_min);
 166   1          UART_SendByte(':');
 167   1          Send2Digits(timed_watering.current_record.end_sec);
 168   1          UART_SendString("\r\n");
 169   1          
 170   1          // 浇水量
 171   1          UART_SendString("Water Volume: ");
 172   1          SendNumber(timed_watering.current_record.water_volume);
 173   1          UART_SendString(" ml\r\n");
 174   1          
 175   1          // 累计流量
 176   1          UART_SendString("Total Flow: ");
 177   1          SendNumber(timed_watering.current_record.total_flow);
 178   1          UART_SendString(" ml\r\n");
C51 COMPILER V9.54   UART                                                                  05/28/2025 12:47:22 PAGE 4   

 179   1          
 180   1          // 持续时间
 181   1          UART_SendString("Duration: ");
 182   1          if(timed_watering.current_record.duration_min > 0) {
 183   2              SendNumber(timed_watering.current_record.duration_min);
 184   2              UART_SendString(" min ");
 185   2          }
 186   1          SendNumber(timed_watering.current_record.duration_sec);
 187   1          UART_SendString(" sec\r\n");
 188   1          
 189   1          UART_SendString("=======================\r\n");
 190   1      }
 191          
 192          // 数字转换辅助函数
 193          static WORD ParseNumber(char *str, BYTE len) {
 194   1          WORD result = 0;
 195   1          BYTE i;
 196   1          for(i = 0; i < len; i++) {
 197   2              if(str[i] >= '0' && str[i] <= '9') {
 198   3                  result = result * 10 + (str[i] - '0');
 199   3              } else {
 200   3                  return 0xFFFF;  // 错误标志
 201   3              }
 202   2          }
 203   1          return result;
 204   1      }
 205          
 206          // 命令处理函数
 207          static void UART_CommandHandler(void) {
 208   1          // 设置日期命令: "DATE:YYYY:MM:DD"
 209   1          if(strncmp(uart_buffer, "DATE:", 5) == 0) {
 210   2              WORD year;
 211   2              BYTE month, day;
 212   2              
 213   2              if(strlen(uart_buffer) >= 15) { // DATE:2025:05:27 = 15字符
 214   3                  year = ParseNumber(uart_buffer + 5, 4);
 215   3                  month = (BYTE)ParseNumber(uart_buffer + 10, 2);
 216   3                  day = (BYTE)ParseNumber(uart_buffer + 13, 2);
 217   3                  
 218   3                  // 验证参数有效性
 219   3                  if(year >= 2000 && year <= 2099 && month >= 1 && month <= 12 && 
 220   3                     day >= 1 && day <= PCA_GetDaysInMonth(year, month)) {
 221   4                      
 222   4                      PCA_SetDate(year, month, day);
 223   4                      
 224   4                      UART_SendString("\r\nDate Set: ");
 225   4                      uart_buffer[9] = '-';
 226   4                      uart_buffer[12] = '-';
 227   4                      uart_buffer[15] = 0;
 228   4                      UART_SendString(uart_buffer + 5);
 229   4                      UART_SendString("\r\n");
 230   4                  } else {
 231   4                      UART_SendString("\r\nError: Invalid date\r\n");
 232   4                      UART_SendString("Format: YYYY(2000-2099):MM(1-12):DD(1-31)\r\n");
 233   4                  }
 234   3              } else {
 235   3                  UART_SendString("\r\nError: Wrong format\r\n");
 236   3                  UART_SendString("Format: DATE:YYYY:MM:DD\r\n");
 237   3                  UART_SendString("Example: DATE:2025:05:27\r\n");
 238   3              }
 239   2          }
 240   1          // 时间设置命令格式: "TIME:HH:MM:SS"
C51 COMPILER V9.54   UART                                                                  05/28/2025 12:47:22 PAGE 5   

 241   1          else if(strncmp(uart_buffer, "TIME:", 5) == 0) {
 242   2              BYTE hour = 0, min = 0, sec = 0;
 243   2              
 244   2              // 解析时间
 245   2              if(strlen(uart_buffer) >= 13) { // 确保格式正确且长度足够
 246   3                  hour = (uart_buffer[5] - '0') * 10 + (uart_buffer[6] - '0');
 247   3                  min = (uart_buffer[8] - '0') * 10 + (uart_buffer[9] - '0');
 248   3                  sec = (uart_buffer[11] - '0') * 10 + (uart_buffer[12] - '0');
 249   3                  
 250   3                  // 检查时间值是否有效
 251   3                  if(hour < 24 && min < 60 && sec < 60) {
 252   4                      // 直接修改SysPara1中的时间值
 253   4                      PCA_SetTime(hour, min, sec);
 254   4                      
 255   4                      UART_SendString("\r\nTime Set: ");
 256   4                      // 发送时间字符串
 257   4                      uart_buffer[7] = ':';
 258   4                      uart_buffer[10] = ':';
 259   4                      uart_buffer[13] = 0;
 260   4                      UART_SendString(uart_buffer + 5);
 261   4                      UART_SendString("\r\n");
 262   4                  }
 263   3                  else {
 264   4                      UART_SendString("\r\nError: Invalid time\r\n");
 265   4                      UART_SendString("Format: HH(0-23):MM(0-59):SS(0-59)\r\n");
 266   4                  }
 267   3              }
 268   2              else {
 269   3                  UART_SendString("\r\nError: Wrong format\r\n");
 270   3                  UART_SendString("Format: TIME:HH:MM:SS\r\n");
 271   3                  UART_SendString("Example: TIME:14:30:00\r\n");
 272   3              }
 273   2          }
 274   1          // 显示模式切换命令: "DISPTIME" 或 "DISPDATE"
 275   1          else if(strncmp(uart_buffer, "DISPTIME", 8) == 0) {
 276   2              PCA_SetDisplayMode(DISPLAY_TIME_MODE);
 277   2              UART_SendString("\r\nDisplay Mode: Time\r\n");
 278   2          }
 279   1          else if(strncmp(uart_buffer, "DISPDATE", 8) == 0) {
 280   2              PCA_SetDisplayMode(DISPLAY_DATE_MODE);
 281   2              UART_SendString("\r\nDisplay Mode: Date\r\n");
 282   2          }
 283   1          // 定时浇水设置命令格式: "A:HH:MM:SS:MMMM"
 284   1          else if(strncmp(uart_buffer, "A:", 2) == 0) {
 285   2              BYTE hour, min, sec;
 286   2              unsigned int volume;
 287   2              
 288   2              // 解析定时浇水参数 A:HH:MM:SS:MMMM
 289   2              if(strlen(uart_buffer) >= 15) { // 确保格式正确且长度足够
 290   3                  hour = (uart_buffer[2] - '0') * 10 + (uart_buffer[3] - '0');
 291   3                  min = (uart_buffer[5] - '0') * 10 + (uart_buffer[6] - '0');
 292   3                  sec = (uart_buffer[8] - '0') * 10 + (uart_buffer[9] - '0');
 293   3                  
 294   3                  // 解析毫升数(最多4位)
 295   3                  volume = 0;
 296   3                  volume += (uart_buffer[11] - '0') * 1000;
 297   3                  volume += (uart_buffer[12] - '0') * 100;
 298   3                  volume += (uart_buffer[13] - '0') * 10;
 299   3                  volume += (uart_buffer[14] - '0');
 300   3                  
 301   3                  // 检查参数有效性
 302   3                  if(hour < 24 && min < 60 && sec < 60 && volume >= 50 && volume <= 9999) {
C51 COMPILER V9.54   UART                                                                  05/28/2025 12:47:22 PAGE 6   

 303   4                      // 设置定时浇水参数
 304   4                      timed_watering.start_hour = hour;
 305   4                      timed_watering.start_min = min;
 306   4                      timed_watering.start_sec = sec;
 307   4                      timed_watering.water_volume_ml = volume;
 308   4                      timed_watering.enabled = 1;
 309   4                      timed_watering.triggered_today = 0;
 310   4                      
 311   4                      UART_SendString("\r\nAuto Set OK\r\n");
 312   4                      UART_SendString("Time: ");
 313   4                      uart_buffer[4] = ':';
 314   4                      uart_buffer[7] = ':';
 315   4                      uart_buffer[10] = 0;
 316   4                      UART_SendString(uart_buffer + 2);
 317   4                      UART_SendString("\r\nVolume: ");
 318   4                      uart_buffer[15] = 0;
 319   4                      UART_SendString(uart_buffer + 11);
 320   4                      UART_SendString("ml\r\n");
 321   4                  }
 322   3                  else {
 323   4                      UART_SendString("\r\nError: Invalid params\r\n");
 324   4                      UART_SendString("Time: HH(0-23):MM(0-59):SS(0-59)\r\n");
 325   4                      UART_SendString("Volume: 50-9999ml\r\n");
 326   4                  }
 327   3              }
 328   2              else {
 329   3                  UART_SendString("\r\nError: Wrong format\r\n");
 330   3                  UART_SendString("Format: A:HH:MM:SS:MMMM\r\n");
 331   3                  UART_SendString("Example: A:06:00:01:0100\r\n");
 332   3              }
 333   2          }
 334   1          // 停止定时浇水命令: "STOP"
 335   1          else if(strncmp(uart_buffer, "STOP", 4) == 0) {
 336   2              TimedWatering_Stop();
 337   2              UART_SendString("\r\nAuto Stopped\r\n");
 338   2          }
 339   1          else {
 340   2              UART_SendString("\r\nError: Unknown cmd\r\n");
 341   2              UART_SendString("Commands:\r\n");
 342   2              UART_SendString("TIME:HH:MM:SS - Set time\r\n");
 343   2              UART_SendString("DATE:YYYY:MM:DD - Set date\r\n");
 344   2              UART_SendString("A:HH:MM:SS:MMMM - Set auto watering\r\n");
 345   2              UART_SendString("DISPTIME/DISPDATE - Display mode\r\n");
 346   2              UART_SendString("STOP - Stop auto watering\r\n");
 347   2          }
 348   1      }
 349          
 350          // 处理串口命令
 351          void UART_ProcessCommand(void) {
 352   1          if(uart_complete) {
 353   2              UART_CommandHandler();
 354   2              uart_complete = 0;
 355   2              uart_count = 0;
 356   2              memset(uart_buffer, 0, sizeof(uart_buffer));
 357   2          }
 358   1      }
 359          
 360          // 串口中断服务函数
 361          void UART_ISR() interrupt 4 {
 362   1          if(RI) {                // 接收中断
 363   2              RI = 0;             // 清除接收中断标志
 364   2              
C51 COMPILER V9.54   UART                                                                  05/28/2025 12:47:22 PAGE 7   

 365   2              if(!uart_complete) { // 如果前一条命令还没处理完，则忽略当前接收的字符
 366   3                  char ch = SBUF;  // 获取接收到的字符
 367   3                  
 368   3                  // 回显接收到的字符
 369   3                  UART_SendByte(ch);
 370   3                  
 371   3                  if(ch == '\n' || ch == '\r') { // 接收到回车或换行
 372   4                      uart_buffer[uart_count] = '\0';  // 字符串结束符
 373   4                      if (uart_count > 0) {  // 非空命令才进行处理
 374   5                          uart_complete = 1;  // 设置接收完成标志
 375   5                      }
 376   4                  }
 377   3                  else if(uart_count < UART_BUF_SIZE - 1) { // 缓冲区未满
 378   4                      uart_buffer[uart_count++] = ch;  // 存储接收到的字符
 379   4                  }
 380   3              }
 381   2          }
 382   1          
 383   1          if(TI) {                // 发送中断
 384   2              TI = 0;             // 清除发送中断标志
 385   2          }
 386   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2104    ----
   CONSTANT SIZE    =   1068    ----
   XDATA SIZE       =     32    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
