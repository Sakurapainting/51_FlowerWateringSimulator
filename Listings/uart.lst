C51 COMPILER V9.54   UART                                                                  05/26/2025 21:22:57 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\uart.l
                    -st) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "uart.h"
   2          #include "flowmeter.h"
   3          #include <string.h>
   4          
   5          // 串口缓冲区及状态变量 - 减少缓冲区大小
   6          static char uart_buffer[16];  // 减少缓冲区大小从32到16
   7          static BYTE uart_count = 0;
   8          static bit uart_complete = 0;
   9          
  10          // 初始化串口
  11          void UART_Init(void) {
  12   1          SCON = 0x50;    // 设置串口工作方式1，8位UART，可变波特率，REN=1允许接收
  13   1          PCON &= 0x7F;   // SMOD=0，波特率不加倍
  14   1          
  15   1          // 使用定时器1作为波特率发生器
  16   1          TMOD &= 0x0F;   // 清除T1的设置位
  17   1          TMOD |= 0x20;   // 设置T1为模式2（8位自动重载）
  18   1          
  19   1          // 9600波特率设置 (针对11.0592MHz晶振)
  20   1          TL1 = 0xFD;     // 设置初值
  21   1          TH1 = 0xFD;     // 设置重载值
  22   1          
  23   1          TR1 = 1;        // 启动定时器1
  24   1          ES = 1;         // 使能串口中断
  25   1          EA = 1;         // 使能总中断
  26   1          
  27   1          // 初始化缓冲区
  28   1          uart_count = 0;
  29   1          uart_complete = 0;
  30   1          memset(uart_buffer, 0, sizeof(uart_buffer));
  31   1          
  32   1          // 发送简化的初始提示信息
  33   1          UART_SendString("\r\n浇花系统启动\r\n");
  34   1          UART_SendString("TIME:HH:MM:SS\r\n");
  35   1      }
  36          
  37          // 发送一个字节
  38          void UART_SendByte(BYTE dat) {
  39   1          SBUF = dat;             // 将数据写入发送缓冲区
  40   1          while(!TI);             // 等待发送完成
  41   1          TI = 0;                 // 清除发送中断标志
  42   1      }
  43          
  44          // 发送字符串
  45          void UART_SendString(char *s) {
  46   1          while(*s) {             // 发送字符串，直到遇到null结束符
  47   2              UART_SendByte(*s++);
  48   2          }
  49   1      }
  50          
  51          // 命令处理函数
  52          static void UART_CommandHandler(void) {
  53   1          // 命令格式: "TIME:HH:MM:SS"
  54   1          if(strncmp(uart_buffer, "TIME:", 5) == 0) {
C51 COMPILER V9.54   UART                                                                  05/26/2025 21:22:57 PAGE 2   

  55   2              BYTE hour = 0, min = 0, sec = 0;
  56   2              
  57   2              // 解析时间
  58   2              if(strlen(uart_buffer) >= 13) { // 确保格式正确且长度足够
  59   3                  hour = (uart_buffer[5] - '0') * 10 + (uart_buffer[6] - '0');
  60   3                  min = (uart_buffer[8] - '0') * 10 + (uart_buffer[9] - '0');
  61   3                  sec = (uart_buffer[11] - '0') * 10 + (uart_buffer[12] - '0');
  62   3                  
  63   3                  // 检查时间值是否有效
  64   3                  if(hour < 24 && min < 60 && sec < 60) {
  65   4                      // 直接修改SysPara1中的时间值
  66   4                      PCA_SetTime(hour, min, sec);
  67   4                      
  68   4                      UART_SendString("\r\n时间设置成功: ");
  69   4                      // 发送时间字符串
  70   4                      uart_buffer[7] = ':';
  71   4                      uart_buffer[10] = ':';
  72   4                      uart_buffer[13] = 0;
  73   4                      UART_SendString(uart_buffer + 5);
  74   4                      UART_SendString("\r\n");
  75   4                  }
  76   3                  else {
  77   4                      UART_SendString("\r\n错误: 无效的时间值\r\n");
  78   4                      UART_SendString("时间格式: HH(0-23):MM(0-59):SS(0-59)\r\n");
  79   4                  }
  80   3              }
  81   2              else {
  82   3                  UART_SendString("\r\n错误: 时间格式错误\r\n");
  83   3                  UART_SendString("正确格式: TIME:HH:MM:SS\r\n");
  84   3                  UART_SendString("例如: TIME:14:30:00\r\n");
  85   3              }
  86   2          }
  87   1          else {
  88   2              UART_SendString("\r\n错误: 未知命令\r\n");
  89   2              UART_SendString("支持的命令: TIME:HH:MM:SS\r\n");
  90   2          }
  91   1      }
  92          
  93          // 处理串口命令
  94          void UART_ProcessCommand(void) {
  95   1          if(uart_complete) {
  96   2              UART_CommandHandler();
  97   2              uart_complete = 0;
  98   2              uart_count = 0;
  99   2              memset(uart_buffer, 0, sizeof(uart_buffer));
 100   2          }
 101   1      }
 102          
 103          // 串口中断服务函数
 104          void UART_ISR() interrupt 4 {
 105   1          if(RI) {                // 接收中断
 106   2              RI = 0;             // 清除接收中断标志
 107   2              
 108   2              if(!uart_complete) { // 如果前一条命令还没处理完，则忽略当前接收的字符
 109   3                  char ch = SBUF;  // 获取接收到的字符
 110   3                  
 111   3                  // 回显接收到的字符
 112   3                  UART_SendByte(ch);
 113   3                  
 114   3                  if(ch == '\n' || ch == '\r') { // 接收到回车或换行
 115   4                      uart_buffer[uart_count] = '\0';  // 字符串结束符
 116   4                      if (uart_count > 0) {  // 非空命令才进行处理
C51 COMPILER V9.54   UART                                                                  05/26/2025 21:22:57 PAGE 3   

 117   5                          uart_complete = 1;  // 设置接收完成标志
 118   5                      }
 119   4                  }
 120   3                  else if(uart_count < UART_BUF_SIZE - 1) { // 缓冲区未满
 121   4                      uart_buffer[uart_count++] = ch;  // 存储接收到的字符
 122   4                  }
 123   3              }
 124   2          }
 125   1          
 126   1          if(TI) {                // 发送中断
 127   2              TI = 0;             // 清除发送中断标志
 128   2          }
 129   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    445    ----
   CONSTANT SIZE    =    288    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
