C51 COMPILER V9.54   UART                                                                  05/27/2025 19:12:09 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\uart.l
                    -st) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "uart.h"
   2          #include "flowmeter.h"
   3          #include "keyboard_control.h"  // 添加此头文件以使用定时浇水功能
   4          #include <string.h>
   5          
   6          // 串口缓冲区及状态变量 - 减少缓冲区大小
   7          static char xdata uart_buffer[16];  // 移到xdata以节省内部RAM
   8          static BYTE uart_count = 0;
   9          static bit uart_complete = 0;
  10          
  11          // 初始化串口
  12          void UART_Init(void) {
  13   1          SCON = 0x50;    // 设置串口工作方式1，8位UART，可变波特率，REN=1允许接收
  14   1          PCON &= 0x7F;   // SMOD=0，波特率不加倍
  15   1          
  16   1          // 使用定时器1作为波特率发生器
  17   1          TMOD &= 0x0F;   // 清除T1的设置位
  18   1          TMOD |= 0x20;   // 设置T1为模式2（8位自动重载）
  19   1          
  20   1          // 9600波特率设置 (针对11.0592MHz晶振)
  21   1          TL1 = 0xFD;     // 设置初值
  22   1          TH1 = 0xFD;     // 设置重载值
  23   1          
  24   1          TR1 = 1;        // 启动定时器1
  25   1          ES = 1;         // 使能串口中断
  26   1          EA = 1;         // 使能总中断
  27   1          
  28   1          // 初始化缓冲区
  29   1          uart_count = 0;
  30   1          uart_complete = 0;
  31   1          memset(uart_buffer, 0, sizeof(uart_buffer));
  32   1          
  33   1          // 发送英文启动信息
  34   1          UART_SendString("\r\nSystem Ready\r\n");
  35   1          UART_SendString("TIME:HH:MM:SS\r\n");
  36   1          UART_SendString("A:HH:MM:SS:MMMM\r\n");
  37   1      }
  38          
  39          // 发送一个字节
  40          void UART_SendByte(BYTE dat) {
  41   1          SBUF = dat;             // 将数据写入发送缓冲区
  42   1          while(!TI);             // 等待发送完成
  43   1          TI = 0;                 // 清除发送中断标志
  44   1      }
  45          
  46          // 发送字符串
  47          void UART_SendString(char *s) {
  48   1          while(*s) {             // 发送字符串，直到遇到null结束符
  49   2              UART_SendByte(*s++);
  50   2          }
  51   1      }
  52          
  53          // 命令处理函数
  54          static void UART_CommandHandler(void) {
C51 COMPILER V9.54   UART                                                                  05/27/2025 19:12:09 PAGE 2   

  55   1          // 时间设置命令格式: "TIME:HH:MM:SS"
  56   1          if(strncmp(uart_buffer, "TIME:", 5) == 0) {
  57   2              BYTE hour = 0, min = 0, sec = 0;
  58   2              
  59   2              // 解析时间
  60   2              if(strlen(uart_buffer) >= 13) { // 确保格式正确且长度足够
  61   3                  hour = (uart_buffer[5] - '0') * 10 + (uart_buffer[6] - '0');
  62   3                  min = (uart_buffer[8] - '0') * 10 + (uart_buffer[9] - '0');
  63   3                  sec = (uart_buffer[11] - '0') * 10 + (uart_buffer[12] - '0');
  64   3                  
  65   3                  // 检查时间值是否有效
  66   3                  if(hour < 24 && min < 60 && sec < 60) {
  67   4                      // 直接修改SysPara1中的时间值
  68   4                      PCA_SetTime(hour, min, sec);
  69   4                      
  70   4                      UART_SendString("\r\nTime Set: ");
  71   4                      // 发送时间字符串
  72   4                      uart_buffer[7] = ':';
  73   4                      uart_buffer[10] = ':';
  74   4                      uart_buffer[13] = 0;
  75   4                      UART_SendString(uart_buffer + 5);
  76   4                      UART_SendString("\r\n");
  77   4                  }
  78   3                  else {
  79   4                      UART_SendString("\r\nError: Invalid time\r\n");
  80   4                      UART_SendString("Format: HH(0-23):MM(0-59):SS(0-59)\r\n");
  81   4                  }
  82   3              }
  83   2              else {
  84   3                  UART_SendString("\r\nError: Wrong format\r\n");
  85   3                  UART_SendString("Format: TIME:HH:MM:SS\r\n");
  86   3                  UART_SendString("Example: TIME:14:30:00\r\n");
  87   3              }
  88   2          }
  89   1          // 定时浇水设置命令格式: "A:HH:MM:SS:MMMM"
  90   1          else if(strncmp(uart_buffer, "A:", 2) == 0) {
  91   2              BYTE hour, min, sec;
  92   2              unsigned int volume;
  93   2              
  94   2              // 解析定时浇水参数 A:HH:MM:SS:MMMM
  95   2              if(strlen(uart_buffer) >= 15) { // 确保格式正确且长度足够
  96   3                  hour = (uart_buffer[2] - '0') * 10 + (uart_buffer[3] - '0');
  97   3                  min = (uart_buffer[5] - '0') * 10 + (uart_buffer[6] - '0');
  98   3                  sec = (uart_buffer[8] - '0') * 10 + (uart_buffer[9] - '0');
  99   3                  
 100   3                  // 解析毫升数(最多4位)
 101   3                  volume = 0;
 102   3                  volume += (uart_buffer[11] - '0') * 1000;
 103   3                  volume += (uart_buffer[12] - '0') * 100;
 104   3                  volume += (uart_buffer[13] - '0') * 10;
 105   3                  volume += (uart_buffer[14] - '0');
 106   3                  
 107   3                  // 检查参数有效性
 108   3                  if(hour < 24 && min < 60 && sec < 60 && volume >= 50 && volume <= 9999) {
 109   4                      // 设置定时浇水参数
 110   4                      timed_watering.start_hour = hour;
 111   4                      timed_watering.start_min = min;
 112   4                      timed_watering.start_sec = sec;
 113   4                      timed_watering.water_volume_ml = volume;
 114   4                      timed_watering.enabled = 1;
 115   4                      timed_watering.triggered_today = 0;
 116   4                      
C51 COMPILER V9.54   UART                                                                  05/27/2025 19:12:09 PAGE 3   

 117   4                      UART_SendString("\r\nAuto Set OK\r\n");
 118   4                      UART_SendString("Time: ");
 119   4                      uart_buffer[4] = ':';
 120   4                      uart_buffer[7] = ':';
 121   4                      uart_buffer[10] = 0;
 122   4                      UART_SendString(uart_buffer + 2);
 123   4                      UART_SendString("\r\nVolume: ");
 124   4                      uart_buffer[15] = 0;
 125   4                      UART_SendString(uart_buffer + 11);
 126   4                      UART_SendString("ml\r\n");
 127   4                  }
 128   3                  else {
 129   4                      UART_SendString("\r\nError: Invalid params\r\n");
 130   4                      UART_SendString("Time: HH(0-23):MM(0-59):SS(0-59)\r\n");
 131   4                      UART_SendString("Volume: 50-9999ml\r\n");
 132   4                  }
 133   3              }
 134   2              else {
 135   3                  UART_SendString("\r\nError: Wrong format\r\n");
 136   3                  UART_SendString("Format: A:HH:MM:SS:MMMM\r\n");
 137   3                  UART_SendString("Example: A:06:00:01:0100\r\n");
 138   3              }
 139   2          }
 140   1          // 停止定时浇水命令: "STOP"
 141   1          else if(strncmp(uart_buffer, "STOP", 4) == 0) {
 142   2              TimedWatering_Stop();
 143   2              UART_SendString("\r\nAuto Stopped\r\n");
 144   2          }
 145   1          else {
 146   2              UART_SendString("\r\nError: Unknown cmd\r\n");
 147   2              UART_SendString("Commands:\r\n");
 148   2              UART_SendString("TIME:HH:MM:SS - Set time\r\n");
 149   2              UART_SendString("A:HH:MM:SS:MMMM - Set auto\r\n");
 150   2              UART_SendString("STOP - Stop auto\r\n");
 151   2          }
 152   1      }
 153          
 154          // 处理串口命令
 155          void UART_ProcessCommand(void) {
 156   1          if(uart_complete) {
 157   2              UART_CommandHandler();
 158   2              uart_complete = 0;
 159   2              uart_count = 0;
 160   2              memset(uart_buffer, 0, sizeof(uart_buffer));
 161   2          }
 162   1      }
 163          
 164          // 串口中断服务函数
 165          void UART_ISR() interrupt 4 {
 166   1          if(RI) {                // 接收中断
 167   2              RI = 0;             // 清除接收中断标志
 168   2              
 169   2              if(!uart_complete) { // 如果前一条命令还没处理完，则忽略当前接收的字符
 170   3                  char ch = SBUF;  // 获取接收到的字符
 171   3                  
 172   3                  // 回显接收到的字符
 173   3                  UART_SendByte(ch);
 174   3                  
 175   3                  if(ch == '\n' || ch == '\r') { // 接收到回车或换行
 176   4                      uart_buffer[uart_count] = '\0';  // 字符串结束符
 177   4                      if (uart_count > 0) {  // 非空命令才进行处理
 178   5                          uart_complete = 1;  // 设置接收完成标志
C51 COMPILER V9.54   UART                                                                  05/27/2025 19:12:09 PAGE 4   

 179   5                      }
 180   4                  }
 181   3                  else if(uart_count < UART_BUF_SIZE - 1) { // 缓冲区未满
 182   4                      uart_buffer[uart_count++] = ch;  // 存储接收到的字符
 183   4                  }
 184   3              }
 185   2          }
 186   1          
 187   1          if(TI) {                // 发送中断
 188   2              TI = 0;             // 清除发送中断标志
 189   2          }
 190   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    991    ----
   CONSTANT SIZE    =    515    ----
   XDATA SIZE       =     16    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
